<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">HornetQ User Manual</title><link rel="stylesheet" href="css/jbossorg.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="description" content="The User manual is an in depth manual on all aspects of HornetQ"/></head><body><div class="book" lang="en"><div class="titlepage"><div><p id="title"><a href="http://www.jboss.org" class="site_href"><strong>JBoss.org</strong></a><a href="http://docs.jboss.org/" class="doc_href"><strong>Community Documentation</strong></a></p><div><h1 class="title"><a id="d0e3"/>HornetQ User Manual</h1></div><div><h2 class="subtitle">Putting the buzz in messaging</h2></div><div><h3 class="corpauthor">
    <span class="inlinemediaobject"><img src="images/hornetQ_logo_600px.png" alt="HornetQ Logo"/></span>
  </h3></div><div><div xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="authorgroup"><div class="authors">by <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Clebert</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Suconic</span> (Red Hat, Inc.), <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Andy</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Taylor</span> (Red Hat, Inc.), <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Tim</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Fox</span> (Red Hat, Inc.), <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Jeff</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Mesnil</span> (Red Hat, Inc.), <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Howard</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Gao</span> (Red Hat, Inc.), <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Francisco</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Borges</span>, and <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Justin</span> <span xmlns="http://www.w3.org/1999/xhtml" class="surname">Bertram</span> (Red Hat, Inc.)</div><div class="editors"/><div class="others"/></div></div><div><p class="copyright">Copyright © 2011 Red Hat Inc.</p></div><div><div class="abstract"><p class="title"><b>Abstract</b></p><p>The User manual is an in depth manual on all aspects of HornetQ</p></div></div></div><hr/></div><div class="toc"><dl><dt><span class="chapter"><a href="#notice">1. Legal Notice</a></span></dt><dt><span class="chapter"><a href="#preface">2. Preface</a></span></dt><dt><span class="chapter"><a href="#project-info">3. Project Information</a></span></dt><dd><dl><dt><span class="section"><a href="#download.software">3.1. Software Download</a></span></dt><dt><span class="section"><a href="#download.git">3.2. Project Information</a></span></dt></dl></dd><dt><span class="chapter"><a href="#messaging-concepts">4. Messaging Concepts</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e351">4.1. Messaging Concepts</a></span></dt><dt><span class="section"><a href="#d0e376">4.2. Messaging styles</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e390">4.2.1. The Message Queue Pattern</a></span></dt><dt><span class="section"><a href="#d0e410">4.2.2. The Publish-Subscribe Pattern</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e436">4.3. Delivery guarantees</a></span></dt><dt><span class="section"><a href="#d0e446">4.4. Transactions</a></span></dt><dt><span class="section"><a href="#d0e451">4.5. Durability</a></span></dt><dt><span class="section"><a href="#d0e456">4.6. Messaging APIs and protocols</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e467">4.6.1. Java Message Service (JMS)</a></span></dt><dt><span class="section"><a href="#d0e480">4.6.2. System specific APIs</a></span></dt><dt><span class="section"><a href="#d0e487">4.6.3. RESTful API</a></span></dt><dt><span class="section"><a href="#d0e504">4.6.4. STOMP</a></span></dt><dt><span class="section"><a href="#d0e515">4.6.5. AMQP</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e527">4.7. High Availability</a></span></dt><dt><span class="section"><a href="#d0e538">4.8. Clusters</a></span></dt><dt><span class="section"><a href="#d0e556">4.9. Bridges and routing</a></span></dt></dl></dd><dt><span class="chapter"><a href="#architecture">5. Architecture</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e595">5.1. Core Architecture</a></span></dt><dt><span class="section"><a href="#d0e638">5.2. HornetQ embedded in your own application</a></span></dt><dt><span class="section"><a href="#d0e647">5.3. HornetQ integrated with a JEE application server</a></span></dt><dt><span class="section"><a href="#d0e679">5.4. HornetQ stand-alone server</a></span></dt></dl></dd><dt><span class="chapter"><a href="#using-server">6. Using the Server</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e733">6.1. Starting and Stopping the standalone server</a></span></dt><dt><span class="section"><a href="#d0e785">6.2. Server JVM settings</a></span></dt><dt><span class="section"><a href="#d0e806">6.3. Server classpath</a></span></dt><dt><span class="section"><a href="#using-server.library.path">6.4. Library Path</a></span></dt><dt><span class="section"><a href="#d0e865">6.5. System properties</a></span></dt><dt><span class="section"><a href="#using-server.configuration">6.6. Configuration files</a></span></dt><dt><span class="section"><a href="#server.microcontainer.configuration">6.7. JBoss Microcontainer Beans File</a></span></dt><dt><span class="section"><a href="#server.microkernel.configuration">6.8. JBoss AS4 MBean Service.</a></span></dt><dt><span class="section"><a href="#usingserver.mainconfig">6.9. The main configuration file.</a></span></dt></dl></dd><dt><span class="chapter"><a href="#using-jms">7. Using JMS</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1122">7.1. A simple ordering system</a></span></dt><dt><span class="section"><a href="#using-jms.server.configuration">7.2. JMS Server Configuration</a></span></dt><dt><span class="section"><a href="#using-jms.configure.factory.types">7.3. Connection Factory Types</a></span></dt><dt><span class="section"><a href="#d0e1265">7.4. JNDI configuration</a></span></dt><dt><span class="section"><a href="#d0e1307">7.5. The code</a></span></dt><dt><span class="section"><a href="#d0e1364">7.6. Directly instantiating JMS Resources without using JNDI</a></span></dt><dt><span class="section"><a href="#using-jms.clientid">7.7. Setting The Client ID</a></span></dt><dt><span class="section"><a href="#using-jms.dupsokbatchsize">7.8. Setting The Batch Size for DUPS_OK </a></span></dt><dt><span class="section"><a href="#using-jms.txbatchsize">7.9. Setting The Transaction Batch Size</a></span></dt></dl></dd><dt><span class="chapter"><a href="#using-core">8. Using Core</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1472">8.1. Core Messaging Concepts</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1477">8.1.1. Message</a></span></dt><dt><span class="section"><a href="#d0e1514">8.1.2. Address</a></span></dt><dt><span class="section"><a href="#d0e1535">8.1.3. Queue</a></span></dt><dt><span class="section"><a href="#d0e1546">8.1.4. ServerLocator</a></span></dt><dt><span class="section"><a href="#d0e1572">8.1.5. ClientSessionFactory</a></span></dt><dt><span class="section"><a href="#d0e1595">8.1.6. ClientSession</a></span></dt><dt><span class="section"><a href="#d0e1615">8.1.7. ClientConsumer</a></span></dt><dt><span class="section"><a href="#d0e1626">8.1.8. ClientProducer</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1647">8.2. A simple example of using Core</a></span></dt></dl></dd><dt><span class="chapter"><a href="#jms-core-mapping">9. Mapping JMS Concepts to the Core API</a></span></dt><dt><span class="chapter"><a href="#client-classpath">10. The Client Classpath</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1725">10.1. HornetQ Core Client</a></span></dt><dt><span class="section"><a href="#d0e1739">10.2. JMS Client</a></span></dt><dt><span class="section"><a href="#d0e1758">10.3. JMS Client with JNDI</a></span></dt></dl></dd><dt><span class="chapter"><a href="#examples">11. Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1795">11.1. JMS Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#examples.aerogear">11.1.1. JMS AeroGear</a></span></dt><dt><span class="section"><a href="#examples.applet">11.1.2. Applet</a></span></dt><dt><span class="section"><a href="#application-level-failover">11.1.3. Application-Layer Failover</a></span></dt><dt><span class="section"><a href="#examples.bridge">11.1.4. Core Bridge Example</a></span></dt><dt><span class="section"><a href="#examples.browsers">11.1.5. Browser</a></span></dt><dt><span class="section"><a href="#d0e1863">11.1.6. Client Kickoff</a></span></dt><dt><span class="section"><a href="#d0e1871">11.1.7. Client side failover listener</a></span></dt><dt><span class="section"><a href="#d0e1879">11.1.8. Client-Side Load-Balancing</a></span></dt><dt><span class="section"><a href="#examples.clustered.durable">11.1.9. Clustered Durable Subscription</a></span></dt><dt><span class="section"><a href="#examples.clustered.grouping">11.1.10. Clustered Grouping</a></span></dt><dt><span class="section"><a href="#examples.clustered.queue">11.1.11. Clustered Queue</a></span></dt><dt><span class="section"><a href="#examples.clustered.jgroups">11.1.12. Clustering with JGroups</a></span></dt><dt><span class="section"><a href="#examples.clustered.standalone">11.1.13. Clustered Standalone</a></span></dt><dt><span class="section"><a href="#examples.clustered.static.discovery">11.1.14. Clustered Static Discovery</a></span></dt><dt><span class="section"><a href="#examples.clustered.static.oneway">11.1.15. Clustered Static Cluster One Way</a></span></dt><dt><span class="section"><a href="#d0e1934">11.1.16. Clustered Topic</a></span></dt><dt><span class="section"><a href="#examples.consumer-rate-limit">11.1.17. Message Consumer Rate Limiting</a></span></dt><dt><span class="section"><a href="#examples.dead-letter">11.1.18. Dead Letter</a></span></dt><dt><span class="section"><a href="#examples.delayed-redelivery">11.1.19. Delayed Redelivery</a></span></dt><dt><span class="section"><a href="#divert-example">11.1.20. Divert</a></span></dt><dt><span class="section"><a href="#d0e1976">11.1.21. Durable Subscription</a></span></dt><dt><span class="section"><a href="#examples.embedded.jms">11.1.22. Embedded</a></span></dt><dt><span class="section"><a href="#examples.embedded.jms.simple">11.1.23. Embedded Simple</a></span></dt><dt><span class="section"><a href="#examples.expiry">11.1.24. Message Expiration</a></span></dt><dt><span class="section"><a href="#examples.hornetq-ra-rar">11.1.25. HornetQ Resource Adapter example</a></span></dt><dt><span class="section"><a href="#d0e2017">11.1.26. HTTP Transport</a></span></dt><dt><span class="section"><a href="#d0e2025">11.1.27. Instantiate JMS Objects Directly</a></span></dt><dt><span class="section"><a href="#examples.interceptor">11.1.28. Interceptor</a></span></dt><dt><span class="section"><a href="#examples.jaas">11.1.29. JAAS</a></span></dt><dt><span class="section"><a href="#examples.jms.auto-closeable">11.1.30. JMS Auto Closable</a></span></dt><dt><span class="section"><a href="#examples.jms.completion-listener">11.1.31. JMS Completion Listener</a></span></dt><dt><span class="section"><a href="#examples.jms.jms-bridge">11.1.32. JMS Bridge</a></span></dt><dt><span class="section"><a href="#examples.jms.jms-context">11.1.33. JMS Context</a></span></dt><dt><span class="section"><a href="#examples.jms.jms-shared-consumer">11.1.34. JMS Shared Consumer</a></span></dt><dt><span class="section"><a href="#examples.jmx">11.1.35. JMX Management</a></span></dt><dt><span class="section"><a href="#examples.large-message">11.1.36. Large Message</a></span></dt><dt><span class="section"><a href="#examples.last-value-queue">11.1.37. Last-Value Queue</a></span></dt><dt><span class="section"><a href="#examples.management">11.1.38. Management</a></span></dt><dt><span class="section"><a href="#examples.management-notifications">11.1.39. Management Notification</a></span></dt><dt><span class="section"><a href="#examples.message-counters">11.1.40. Message Counter</a></span></dt><dt><span class="section"><a href="#examples.message-group">11.1.41. Message Group</a></span></dt><dt><span class="section"><a href="#examples.message-group2">11.1.42. Message Group</a></span></dt><dt><span class="section"><a href="#examples.message-priority">11.1.43. Message Priority</a></span></dt><dt><span class="section"><a href="#examples.multiple.failover">11.1.44. Multiple Failover</a></span></dt><dt><span class="section"><a href="#examples.multiple.failover.failback">11.1.45. Multiple Failover Failback</a></span></dt><dt><span class="section"><a href="#examples.no-consumer-buffering">11.1.46. No Consumer Buffering</a></span></dt><dt><span class="section"><a href="#examples.non-transaction-failover">11.1.47. Non-Transaction Failover With Server Data Replication</a></span></dt><dt><span class="section"><a href="#examples.paging">11.1.48. Paging</a></span></dt><dt><span class="section"><a href="#examples.pre-acknowledge">11.1.49. Pre-Acknowledge</a></span></dt><dt><span class="section"><a href="#producer-rate-limiting-example">11.1.50. Message Producer Rate Limiting</a></span></dt><dt><span class="section"><a href="#examples.proton-qpid">11.1.51. Proton Qpid</a></span></dt><dt><span class="section"><a href="#examples.proton-ruby">11.1.52. Proton Ruby</a></span></dt><dt><span class="section"><a href="#examples.queue">11.1.53. Queue</a></span></dt><dt><span class="section"><a href="#examples.message-redistribution">11.1.54. Message Redistribution</a></span></dt><dt><span class="section"><a href="#examples.queue-requestor">11.1.55. Queue Requestor</a></span></dt><dt><span class="section"><a href="#examples.queue-message-selector">11.1.56. Queue with Message Selector</a></span></dt><dt><span class="section"><a href="#examples.reattach-node">11.1.57. Reattach Node example</a></span></dt><dt><span class="section"><a href="#examples.replicated-failback">11.1.58. Replicated Failback example</a></span></dt><dt><span class="section"><a href="#examples.replicated-failback-static">11.1.59. Replicated Failback static example</a></span></dt><dt><span class="section"><a href="#examples.replicated-multiple-failover">11.1.60. Replicated multiple failover example</a></span></dt><dt><span class="section"><a href="#examples.replicated-failover-transaction">11.1.61. Replicated Failover transaction example</a></span></dt><dt><span class="section"><a href="#examples.request-reply">11.1.62. Request-Reply example</a></span></dt><dt><span class="section"><a href="#examples.rest">11.1.63. Rest example</a></span></dt><dt><span class="section"><a href="#examples.scheduled-message">11.1.64. Scheduled Message</a></span></dt><dt><span class="section"><a href="#examples.security">11.1.65. Security</a></span></dt><dt><span class="section"><a href="#asynchronous-send-acknowledgements-example">11.1.66. Send Acknowledgements</a></span></dt><dt><span class="section"><a href="#examples.jms.spring.integration">11.1.67. Spring Integration</a></span></dt><dt><span class="section"><a href="#examples.ssl-transport">11.1.68. SSL Transport</a></span></dt><dt><span class="section"><a href="#examples.static-message-selector">11.1.69. Static Message Selector</a></span></dt><dt><span class="section"><a href="#examples.static-message-selector-jms">11.1.70. Static Message Selector Using JMS</a></span></dt><dt><span class="section"><a href="#examples.stomp">11.1.71. Stomp</a></span></dt><dt><span class="section"><a href="#examples.stomp1.1">11.1.72. Stomp1.1</a></span></dt><dt><span class="section"><a href="#examples.stomp1.2">11.1.73. Stomp1.2</a></span></dt><dt><span class="section"><a href="#examples.stomp-web-socket">11.1.74. Stomp Over Web Sockets</a></span></dt><dt><span class="section"><a href="#examples.symmetric-cluster">11.1.75. Symmetric Cluster</a></span></dt><dt><span class="section"><a href="#examples.temporary-queue">11.1.76. Temporary Queue</a></span></dt><dt><span class="section"><a href="#examples.topic">11.1.77. Topic</a></span></dt><dt><span class="section"><a href="#topic-hierarchy-example">11.1.78. Topic Hierarchy</a></span></dt><dt><span class="section"><a href="#examples.topic-selector-1">11.1.79. Topic Selector 1</a></span></dt><dt><span class="section"><a href="#examples.topic-selector-2">11.1.80. Topic Selector 2</a></span></dt><dt><span class="section"><a href="#examples.transaction-failover">11.1.81. Transaction Failover</a></span></dt><dt><span class="section"><a href="#examples.no-transaction-failover">11.1.82. Failover Without Transactions</a></span></dt><dt><span class="section"><a href="#examples.transactional-session">11.1.83. Transactional Session</a></span></dt><dt><span class="section"><a href="#d0e2492">11.1.84. XA Heuristic</a></span></dt><dt><span class="section"><a href="#d0e2500">11.1.85. XA Receive</a></span></dt><dt><span class="section"><a href="#d0e2508">11.1.86. XA Send</a></span></dt><dt><span class="section"><a href="#d0e2516">11.1.87. XA with Transaction Manager</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2524">11.2. Core API Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#examples.embedded">11.2.1. Embedded</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2542">11.3. Java EE Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2550">11.3.1. EJB/JMS Transaction</a></span></dt><dt><span class="section"><a href="#d0e2555">11.3.2. Resource Adapter Configuration</a></span></dt><dt><span class="section"><a href="#d0e2560">11.3.3. Resource Adapter Remote Server Configuration</a></span></dt><dt><span class="section"><a href="#examples.javaee.jms-bridge">11.3.4. JMS Bridge</a></span></dt><dt><span class="section"><a href="#d0e2570">11.3.5. MDB (Message Driven Bean)</a></span></dt><dt><span class="section"><a href="#d0e2575">11.3.6. Servlet Transport</a></span></dt><dt><span class="section"><a href="#d0e2580">11.3.7. Servlet SSL Transport</a></span></dt><dt><span class="section"><a href="#xa-recovery-example">11.3.8. XA Recovery</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#wildcard-routing">12. Routing Messages With Wild Cards</a></span></dt><dt><span class="chapter"><a href="#wildcard-syntax">13. Understanding the HornetQ Wildcard Syntax</a></span></dt><dt><span class="chapter"><a href="#filter-expressions">14. Filter Expressions</a></span></dt><dt><span class="chapter"><a href="#persistence">15. Persistence</a></span></dt><dd><dl><dt><span class="section"><a href="#configuring.bindings.journal">15.1. Configuring the bindings journal</a></span></dt><dt><span class="section"><a href="#configuring.bindings.jms">15.2. Configuring the jms journal</a></span></dt><dt><span class="section"><a href="#configuring.message.journal">15.3. Configuring the message journal</a></span></dt><dt><span class="section"><a href="#disk-write-cache">15.4. An important note on disabling disk write cache.</a></span></dt><dt><span class="section"><a href="#installing-aio">15.5. Installing AIO</a></span></dt><dt><span class="section"><a href="#persistence.enabled">15.6. Configuring HornetQ for Zero Persistence</a></span></dt><dt><span class="section"><a href="#persistence.importexport">15.7. Import/Export the Journal Data</a></span></dt></dl></dd><dt><span class="chapter"><a href="#configuring-transports">16. Configuring the Transport</a></span></dt><dd><dl><dt><span class="section"><a href="#configuring-transports.acceptors">16.1. Understanding Acceptors</a></span></dt><dt><span class="section"><a href="#configuring-transports.connectors">16.2. Understanding Connectors</a></span></dt><dt><span class="section"><a href="#configuring-transports.client.side">16.3. Configuring the transport directly from the client side.</a></span></dt><dt><span class="section"><a href="#d0e3433">16.4. Configuring the Netty transport</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3445">16.4.1. Single Port Support</a></span></dt><dt><span class="section"><a href="#d0e3463">16.4.2. Configuring Netty TCP</a></span></dt><dt><span class="section"><a href="#d0e3620">16.4.3. Configuring Netty SSL</a></span></dt><dt><span class="section"><a href="#d0e3758">16.4.4. Configuring Netty HTTP</a></span></dt><dt><span class="section"><a href="#d0e3798">16.4.5. Configuring Netty Servlet</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#connection-ttl">17. Detecting Dead Connections</a></span></dt><dd><dl><dt><span class="section"><a href="#dead.connections">17.1. Cleaning up Dead Connection Resources on the Server</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3888">17.1.1. Closing core sessions or JMS connections that you have failed to close</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3904">17.2. Detecting failure from the client side.</a></span></dt><dt><span class="section"><a href="#connection-ttl.async-connection-execution">17.3. Configuring Asynchronous Connection Execution</a></span></dt></dl></dd><dt><span class="chapter"><a href="#transaction-config">18. Resource Manager Configuration</a></span></dt><dt><span class="chapter"><a href="#flow-control">19. Flow Control</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4023">19.1. Consumer Flow Control</a></span></dt><dd><dl><dt><span class="section"><a href="#flow-control.consumer.window">19.1.1. Window-Based Flow Control</a></span></dt><dt><span class="section"><a href="#d0e4143">19.1.2. Rate limited flow control</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e4196">19.2. Producer flow control</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4201">19.2.1. Window based flow control</a></span></dt><dt><span class="section"><a href="#d0e4285">19.2.2. Rate limited flow control</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#send-guarantees">20. Guarantees of sends and commits</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4348">20.1. Guarantees of Transaction Completion</a></span></dt><dt><span class="section"><a href="#non-transactional-sends">20.2. Guarantees of Non Transactional Message Sends</a></span></dt><dt><span class="section"><a href="#send-guarantees.nontrans.acks">20.3. Guarantees of Non Transactional Acknowledgements</a></span></dt><dt><span class="section"><a href="#asynchronous-send-acknowledgements">20.4. Asynchronous Send Acknowledgements</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4491">20.4.1. Asynchronous Send Acknowledgements</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#undelivered-messages">21. Message Redelivery and Undelivered Messages</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4556">21.1. Delayed Redelivery</a></span></dt><dd><dl><dt><span class="section"><a href="#undelivered-messages.delay">21.1.1. Configuring Delayed Redelivery</a></span></dt><dt><span class="section"><a href="#d0e4588">21.1.2. Example</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e4595">21.2. Dead Letter Addresses</a></span></dt><dd><dl><dt><span class="section"><a href="#undelivered-messages.configuring">21.2.1. Configuring Dead Letter Addresses</a></span></dt><dt><span class="section"><a href="#d0e4639">21.2.2. Dead Letter Properties</a></span></dt><dt><span class="section"><a href="#d0e4654">21.2.3. Example</a></span></dt></dl></dd><dt><span class="section"><a href="#configuring.delivery.count.persistence">21.3. Delivery Count Persistence</a></span></dt></dl></dd><dt><span class="chapter"><a href="#message-expiry">22. Message Expiry</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4733">22.1. Message Expiry</a></span></dt><dt><span class="section"><a href="#message-expiry.configuring">22.2. Configuring Expiry Addresses</a></span></dt><dt><span class="section"><a href="#configuring.expiry.reaper">22.3. Configuring The Expiry Reaper Thread</a></span></dt><dt><span class="section"><a href="#d0e4801">22.4. Example</a></span></dt></dl></dd><dt><span class="chapter"><a href="#large-messages">23. Large Messages</a></span></dt><dd><dl><dt><span class="section"><a href="#large.message.configuring">23.1. Configuring the server</a></span></dt><dt><span class="section"><a href="#d0e4867">23.2. Configuring Parameters</a></span></dt><dd><dl><dt><span class="section"><a href="#large-messages.core.config">23.2.1. Using Core API</a></span></dt><dt><span class="section"><a href="#d0e4889">23.2.2. Using JMS</a></span></dt><dt><span class="section"><a href="#d0e4903">23.2.3. Compressed Large Messages</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e4936">23.3. Streaming large messages</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4968">23.3.1. Streaming over Core API</a></span></dt><dt><span class="section"><a href="#large-messages.streaming.over.jms">23.3.2. Streaming over JMS</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5069">23.4. Streaming Alternative</a></span></dt><dt><span class="section"><a href="#large-messages.example">23.5. Large message example</a></span></dt></dl></dd><dt><span class="chapter"><a href="#paging">24. Paging</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5132">24.1. Page Files</a></span></dt><dt><span class="section"><a href="#paging.main.config">24.2. Configuration</a></span></dt><dt><span class="section"><a href="#paging.mode">24.3. Paging Mode</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5191">24.3.1. Configuration</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5257">24.4. Dropping messages</a></span></dt><dt><span class="section"><a href="#d0e5270">24.5. Dropping messages and throwing an exception to producers</a></span></dt><dt><span class="section"><a href="#d0e5283">24.6. Blocking producers</a></span></dt><dt><span class="section"><a href="#d0e5300">24.7. Caution with Addresses with Multiple Queues</a></span></dt><dt><span class="section"><a href="#d0e5324">24.8. Example</a></span></dt></dl></dd><dt><span class="chapter"><a href="#queue-attributes">25. Queue Attributes</a></span></dt><dd><dl><dt><span class="section"><a href="#predefined.queues">25.1. Predefined Queues</a></span></dt><dt><span class="section"><a href="#d0e5406">25.2. Using the API</a></span></dt><dt><span class="section"><a href="#queue-attributes.address-settings">25.3. Configuring Queues Via Address Settings</a></span></dt></dl></dd><dt><span class="chapter"><a href="#scheduled-messages">26. Scheduled Messages</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5560">26.1. Scheduled Delivery Property</a></span></dt><dt><span class="section"><a href="#d0e5580">26.2. Example</a></span></dt></dl></dd><dt><span class="chapter"><a href="#last-value-queues">27. Last-Value Queues</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5611">27.1. Configuring Last-Value Queues</a></span></dt><dt><span class="section"><a href="#d0e5625">27.2. Using Last-Value Property</a></span></dt><dt><span class="section"><a href="#d0e5640">27.3. Example</a></span></dt></dl></dd><dt><span class="chapter"><a href="#message-grouping">28. Message Grouping</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5688">28.1. Using Core API</a></span></dt><dt><span class="section"><a href="#message-grouping.jmsconfigure">28.2. Using JMS</a></span></dt><dt><span class="section"><a href="#d0e5738">28.3. Example</a></span></dt><dt><span class="section"><a href="#d0e5745">28.4. Example</a></span></dt><dt><span class="section"><a href="#d0e5752">28.5.  Clustered Grouping</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5782">28.5.1. Clustered Grouping Best Practices</a></span></dt><dt><span class="section"><a href="#d0e5797">28.5.2. Clustered Grouping Example</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#pre-acknowledge">29. Extra Acknowledge Modes</a></span></dt><dd><dl><dt><span class="section"><a href="#pre-acknowledge.configure">29.1. Using PRE_ACKNOWLEDGE</a></span></dt><dt><span class="section"><a href="#individual-ack">29.2. Individual Acknowledge</a></span></dt><dt><span class="section"><a href="#d0e5917">29.3. Example</a></span></dt></dl></dd><dt><span class="chapter"><a href="#management">30. Management</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5969">30.1. The Management API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6018">30.1.1. Core Management API</a></span></dt><dt><span class="section"><a href="#d0e6509">30.1.2. JMS Management API</a></span></dt></dl></dd><dt><span class="section"><a href="#management.jmx">30.2. Using Management Via JMX</a></span></dt><dd><dl><dt><span class="section"><a href="#management.jmx.configuration">30.2.1. Configuring JMX</a></span></dt><dt><span class="section"><a href="#d0e6927">30.2.2. Example</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6934">30.3. Using Management Via Core API</a></span></dt><dd><dl><dt><span class="section"><a href="#management.core.configuration">30.3.1. Configuring Core Management</a></span></dt></dl></dd><dt><span class="section"><a href="#management.jms">30.4. Using Management Via JMS</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7112">30.4.1. Configuring JMS Management</a></span></dt><dt><span class="section"><a href="#d0e7119">30.4.2. Example</a></span></dt></dl></dd><dt><span class="section"><a href="#management.notifications">30.5. Management Notifications</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7146">30.5.1. JMX Notifications</a></span></dt><dt><span class="section"><a href="#d0e7170">30.5.2. Core Messages Notifications</a></span></dt><dt><span class="section"><a href="#d0e7199">30.5.3. JMS Messages Notifications</a></span></dt><dt><span class="section"><a href="#d0e7223">30.5.4. Example</a></span></dt><dt><span class="section"><a href="#d0e7233">30.5.5. Notification Types and Headers</a></span></dt></dl></dd><dt><span class="section"><a href="#management.message-counters">30.6. Message Counters</a></span></dt><dd><dl><dt><span class="section"><a href="#configuring.message.counters">30.6.1. Configuring Message Counters</a></span></dt><dt><span class="section"><a href="#d0e7638">30.6.2. Example</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e7648">30.7. Administering HornetQ Resources Using The JBoss AS Admin Console</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7657">30.7.1. JMS Queues</a></span></dt><dt><span class="section"><a href="#d0e7681">30.7.2. JMS Topics</a></span></dt><dt><span class="section"><a href="#d0e7686">30.7.3. JMS Connection Factories</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#security">31. Security</a></span></dt><dd><dl><dt><span class="section"><a href="#security.settings.roles">31.1. Role based security for addresses</a></span></dt><dt><span class="section"><a href="#d0e7879">31.2. Secure Sockets Layer (SSL) Transport</a></span></dt><dt><span class="section"><a href="#d0e7888">31.3. Basic user credentials</a></span></dt><dt><span class="section"><a href="#change-security-manager">31.4. Changing the security manager</a></span></dt><dt><span class="section"><a href="#d0e7975">31.5. JAAS Security Manager</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8008">31.5.1. Example</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e8015">31.6. JBoss AS Security Manager</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8029">31.6.1. Configuring Client Login</a></span></dt><dt><span class="section"><a href="#d0e8048">31.6.2. Changing the Security Domain</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e8059">31.7. Changing the username/password for clustering</a></span></dt></dl></dd><dt><span class="chapter"><a href="#appserver-integration">32. Application Server Integration and Java EE</a></span></dt><dd><dl><dt><span class="section"><a href="#configuring-mdbs">32.1. Configuring Message-Driven Beans</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8151">32.1.1. Using Container-Managed Transactions</a></span></dt><dt><span class="section"><a href="#d0e8183">32.1.2. Using Bean-Managed Transactions</a></span></dt><dt><span class="section"><a href="#d0e8205">32.1.3. Using Message Selectors with Message-Driven Beans</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e8212">32.2. Sending Messages from within JEE components</a></span></dt><dt><span class="section"><a href="#d0e8229">32.3. MDB and Consumer pool size</a></span></dt><dt><span class="section"><a href="#d0e8242">32.4. Configuring the JCA Adaptor</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8271">32.4.1. Global Properties</a></span></dt><dt><span class="section"><a href="#d0e8646">32.4.2. Adapter Outbound Configuration</a></span></dt><dt><span class="section"><a href="#d0e8720">32.4.3. Adapter Inbound Configuration</a></span></dt><dt><span class="section"><a href="#d0e8839">32.4.4. Configuring the adapter to use a standalone HornetQ Server</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e8991">32.5. Configuring the JBoss Application Server to connect to Remote HornetQ Server</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8996">32.5.1. Configuring JBoss 5</a></span></dt><dt><span class="section"><a href="#d0e9100">32.5.2. Configuring JBoss 5</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e9112">32.6. High Availability JNDI (HA-JNDI)</a></span></dt><dt><span class="section"><a href="#xa-recovery">32.7. XA Recovery</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9139">32.7.1. XA Recovery Configuration</a></span></dt><dt><span class="section"><a href="#d0e9242">32.7.2. Example</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#jms-bridge">33. The JMS Bridge</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9297">33.1. JMS Bridge Parameters</a></span></dt><dt><span class="section"><a href="#d0e9506">33.2. Source and Target Connection Factories</a></span></dt><dt><span class="section"><a href="#d0e9516">33.3. Source and Target Destination Factories</a></span></dt><dt><span class="section"><a href="#quality-of-service">33.4. Quality Of Service</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9533">33.4.1. AT_MOST_ONCE</a></span></dt><dt><span class="section"><a href="#d0e9540">33.4.2. DUPLICATES_OK</a></span></dt><dt><span class="section"><a href="#d0e9547">33.4.3. ONCE_AND_ONLY_ONCE</a></span></dt><dt><span class="section"><a href="#d0e9557">33.4.4. Time outs and the JMS bridge</a></span></dt><dt><span class="section"><a href="#d0e9584">33.4.5. Examples</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#client-reconnection">34. Client Reconnection and Session Reattachment</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9617">34.1. 100% Transparent session re-attachment</a></span></dt><dt><span class="section"><a href="#d0e9666">34.2. Session reconnection</a></span></dt><dt><span class="section"><a href="#d0e9685">34.3. Configuring reconnection/reattachment attributes</a></span></dt><dt><span class="section"><a href="#client-reconnection.exceptionlistener">34.4. ExceptionListeners and SessionFailureListeners</a></span></dt></dl></dd><dt><span class="chapter"><a href="#diverts">35. Diverting and Splitting Message Flows</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9869">35.1. Exclusive Divert</a></span></dt><dt><span class="section"><a href="#d0e9907">35.2. Non-exclusive Divert</a></span></dt></dl></dd><dt><span class="chapter"><a href="#core-bridges">36. Core Bridges</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9981">36.1. Configuring Bridges</a></span></dt></dl></dd><dt><span class="chapter"><a href="#duplicate-detection">37. Duplicate Message Detection</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10254">37.1. Using Duplicate Detection for Message Sending</a></span></dt><dt><span class="section"><a href="#duplicate.id.cache">37.2. Configuring the Duplicate ID Cache</a></span></dt><dt><span class="section"><a href="#d0e10343">37.3. Duplicate Detection and Bridges</a></span></dt><dt><span class="section"><a href="#d0e10368">37.4. Duplicate Detection and Cluster Connections</a></span></dt></dl></dd><dt><span class="chapter"><a href="#clusters">38. Clusters</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10413">38.1. Clusters Overview</a></span></dt><dt><span class="section"><a href="#clusters.server-discovery">38.2. Server discovery</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10490">38.2.1. Dynamic Discovery</a></span></dt><dt><span class="section"><a href="#d0e10813">38.2.2. Discovery using static Connectors</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e10861">38.3. Server-Side Message Load Balancing</a></span></dt><dd><dl><dt><span class="section"><a href="#clusters.cluster-connections">38.3.1. Configuring Cluster Connections</a></span></dt><dt><span class="section"><a href="#clusters.clusteruser">38.3.2. Cluster User Credentials</a></span></dt></dl></dd><dt><span class="section"><a href="#clusters.client.loadbalancing">38.4. Client-Side Load balancing</a></span></dt><dt><span class="section"><a href="#d0e11190">38.5. Specifying Members of a Cluster Explicitly</a></span></dt><dt><span class="section"><a href="#clusters.message-redistribution">38.6. Message Redistribution</a></span></dt><dt><span class="section"><a href="#d0e11262">38.7. Cluster topologies</a></span></dt><dd><dl><dt><span class="section"><a href="#symmetric-cluster">38.7.1. Symmetric cluster</a></span></dt><dt><span class="section"><a href="#d0e11289">38.7.2. Chain cluster</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#ha">39. High Availability and Failover</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e11342">39.1. Live - Backup Groups</a></span></dt><dd><dl><dt><span class="section"><a href="#ha.mode">39.1.1. HA modes</a></span></dt><dt><span class="section"><a href="#ha.mode.replicated">39.1.2. Data Replication</a></span></dt><dt><span class="section"><a href="#ha.mode.shared">39.1.3. Shared Store</a></span></dt><dt><span class="section"><a href="#ha.allow-fail-back">39.1.4. Failing Back to live Server</a></span></dt></dl></dd><dt><span class="section"><a href="#failover">39.2. Failover Modes</a></span></dt><dd><dl><dt><span class="section"><a href="#ha.automatic.failover">39.2.1. Automatic Client Failover</a></span></dt><dt><span class="section"><a href="#d0e11784">39.2.2. Getting Notified of Connection Failure</a></span></dt><dt><span class="section"><a href="#d0e11836">39.2.3. Application-Level Failover</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#libaio">40. Libaio Native Libraries</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e11917">40.1. Compiling the native libraries</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e11922">40.1.1. Install requirements</a></span></dt><dt><span class="section"><a href="#d0e11972">40.1.2. Invoking the compilation</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#thread-pooling">41. Thread management</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e12031">41.1. Server-Side Thread Management</a></span></dt><dd><dl><dt><span class="section"><a href="#server.scheduled.thread.pool">41.1.1. Server Scheduled Thread Pool</a></span></dt><dt><span class="section"><a href="#d0e12077">41.1.2. General Purpose Server Thread Pool</a></span></dt><dt><span class="section"><a href="#d0e12119">41.1.3. Expiry Reaper Thread</a></span></dt><dt><span class="section"><a href="#d0e12128">41.1.4. Asynchronous IO</a></span></dt></dl></dd><dt><span class="section"><a href="#thread-pooling.client.side">41.2. Client-Side Thread Management</a></span></dt></dl></dd><dt><span class="chapter"><a href="#logging">42. Logging</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e12252">42.1. Logging in a client or with an Embedded server</a></span></dt><dt><span class="section"><a href="#d0e12290">42.2. Logging With The JBoss Application Server</a></span></dt></dl></dd><dt><span class="chapter"><a href="#rest">43. REST Interface</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e12321">43.1. Goals of REST Interface</a></span></dt><dt><span class="section"><a href="#install">43.2. Installation and Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e12353">43.2.1. Installing Within Pre-configured Environment</a></span></dt><dt><span class="section"><a href="#d0e12381">43.2.2. Bootstrapping HornetQ Along with REST</a></span></dt><dt><span class="section"><a href="#configuration">43.2.3. REST Configuration</a></span></dt></dl></dd><dt><span class="section"><a href="#basics">43.3. HornetQ REST Interface Basics</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e12474">43.3.1. Queue and Topic Resources</a></span></dt><dt><span class="section"><a href="#d0e12504">43.3.2. Queue Resource Response Headers</a></span></dt><dt><span class="section"><a href="#d0e12545">43.3.3. Topic Resource Response Headers</a></span></dt></dl></dd><dt><span class="section"><a href="#posting-messages">43.4. Posting Messages</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e12670">43.4.1. Duplicate Detection</a></span></dt><dt><span class="section"><a href="#d0e12791">43.4.2. Persistent Messages</a></span></dt><dt><span class="section"><a href="#d0e12810">43.4.3. TTL, Expiration and Priority</a></span></dt></dl></dd><dt><span class="section"><a href="#message-pull">43.5. Consuming Messages via Pull</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e12900">43.5.1. Auto-Acknowledge</a></span></dt><dt><span class="section"><a href="#d0e13030">43.5.2. Manual Acknowledgement</a></span></dt><dt><span class="section"><a href="#d0e13218">43.5.3. Blocking Pulls with Accept-Wait</a></span></dt><dt><span class="section"><a href="#d0e13230">43.5.4. Clean Up Your Consumers!</a></span></dt></dl></dd><dt><span class="section"><a href="#message-push">43.6. Pushing Messages</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e13246">43.6.1. The Queue Push Subscription XML</a></span></dt><dt><span class="section"><a href="#d0e13328">43.6.2. The Topic Push Subscription XML</a></span></dt><dt><span class="section"><a href="#d0e13338">43.6.3. Creating a Push Subscription at Runtime</a></span></dt><dt><span class="section"><a href="#d0e13371">43.6.4. Creating a Push Subscription by Hand</a></span></dt><dt><span class="section"><a href="#d0e13384">43.6.5. Pushing to Authenticated Servers</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e13397">43.7. Creating Destinations</a></span></dt><dt><span class="section"><a href="#d0e13410">43.8. Securing the HornetQ REST Interface</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e13413">43.8.1. Within JBoss Application server</a></span></dt><dt><span class="section"><a href="#d0e13418">43.8.2. Security in other environments</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e13476">43.9. Mixing JMS and REST</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e13481">43.9.1. JMS Producers - REST Consumers</a></span></dt><dt><span class="section"><a href="#d0e13490">43.9.2. REST Producers - JMS Consumers</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#embedding-hornetq">44. Embedding HornetQ</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e13535">44.1. Simple Config File Embedding</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e13540">44.1.1. Core API Only</a></span></dt><dt><span class="section"><a href="#simple.embedded.jms">44.1.2. JMS API</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e13588">44.2. POJO instantiation - Embedding Programmatically</a></span></dt><dt><span class="section"><a href="#d0e13629">44.3. Dependency Frameworks</a></span></dt></dl></dd><dt><span class="chapter"><a href="#spring.integration">45. Spring Integration</a></span></dt><dt><span class="chapter"><a href="#aerogear-integration">46. AeroGear Integration</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e13765">46.1. Configuring an AeroGear Connector Service</a></span></dt><dt><span class="section"><a href="#d0e13847">46.2. How to send a message for AeroGear</a></span></dt></dl></dd><dt><span class="chapter"><a href="#intercepting-operations">47. Intercepting Operations</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e13894">47.1. Implementing The Interceptors</a></span></dt><dt><span class="section"><a href="#d0e13919">47.2. Configuring The Interceptors</a></span></dt><dt><span class="section"><a href="#d0e13933">47.3. Interceptors on the Client Side</a></span></dt><dt><span class="section"><a href="#d0e13984">47.4. Example</a></span></dt></dl></dd><dt><span class="chapter"><a href="#interoperability">48. Interoperability</a></span></dt><dd><dl><dt><span class="section"><a href="#stomp">48.1. Stomp</a></span></dt><dd><dl><dt><span class="section"><a href="#stomp.native">48.1.1. Native Stomp support</a></span></dt><dt><span class="section"><a href="#d0e14067">48.1.2. Mapping Stomp destinations to HornetQ addresses and queues</a></span></dt><dt><span class="section"><a href="#d0e14092">48.1.3. STOMP and connection-ttl</a></span></dt><dt><span class="section"><a href="#d0e14112">48.1.4. Stomp and JMS interoperability</a></span></dt><dt><span class="section"><a href="#stomp.websockets">48.1.5. Stomp Over Web Sockets</a></span></dt><dt><span class="section"><a href="#stompconnect">48.1.6. StompConnect</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e14312">48.2. REST</a></span></dt><dt><span class="section"><a href="#d0e14318">48.3. AMQP</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e14332">48.3.1. AMQP and security</a></span></dt><dt><span class="section"><a href="#d0e14337">48.3.2. AMQP Links</a></span></dt><dt><span class="section"><a href="#d0e14342">48.3.3. AMQP and destinations</a></span></dt><dt><span class="section"><a href="#d0e14350">48.3.4. AMQP and Coordinations - Handling Transactions</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#perf-tuning">49. Performance Tuning</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e14383">49.1. Tuning persistence</a></span></dt><dt><span class="section"><a href="#d0e14414">49.2. Tuning JMS</a></span></dt><dt><span class="section"><a href="#d0e14474">49.3. Other Tunings</a></span></dt><dt><span class="section"><a href="#d0e14579">49.4. Tuning Transport Settings</a></span></dt><dt><span class="section"><a href="#d0e14628">49.5. Tuning the VM</a></span></dt><dt><span class="section"><a href="#d0e14663">49.6. Avoiding Anti-Patterns</a></span></dt></dl></dd><dt><span class="chapter"><a href="#configuration-index">50. Configuration Reference</a></span></dt><dd><dl><dt><span class="section"><a href="#server.configuration">50.1. Server Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e14707">50.1.1. hornetq-configuration.xml</a></span></dt><dt><span class="section"><a href="#d0e17285">50.1.2. hornetq-jms.xml</a></span></dt><dt><span class="section"><a href="#configuration.masked-password">50.1.3. Using Masked Passwords in Configuration Files</a></span></dt></dl></dd></dl></dd></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="notice"/>Chapter 1. Legal Notice</h2></div></div></div><p>Copyright © 2010 Red Hat, Inc. and others.</p><p>The text of and illustrations in this document are licensed by Red Hat under
            a Creative Commons Attribution–Share Alike 3.0 Unported license ("CC-BY-SA").</p><p>An explanation of CC-BY-SA is available at 
            <a class="ulink" href="http://creativecommons.org/licenses/by-sa/3.0/">http://creativecommons.org/licenses/by-sa/3.0/</a>. 
            In accordance with CC-BY-SA, if you distribute this document or an adaptation
            of it, you must provide the URL for the original version.</p><p>Red Hat, as the licensor of this document, waives the right to enforce, 
            and agrees not to assert, Section 4d of CC-BY-SA to the fullest extent 
            permitted by applicable law.</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="preface"/>Chapter 2. Preface</h2></div></div></div><p>What is HornetQ?</p><div class="itemizedlist"><ul><li><p>HornetQ is an open source project to build a multi-protocol, embeddable, very high
                performance, clustered, asynchronous messaging system.</p></li><li><p>HornetQ is an example of Message Oriented Middleware (MoM). For a description of
                MoMs and other messaging concepts please see the <a class="xref" href="#messaging-concepts" title="Chapter 4. Messaging Concepts">Chapter 4, <i>Messaging Concepts</i></a>.</p></li><li><p>For answers to more questions about what HornetQ is and what it isn't please visit
                the <a class="ulink" href="http://www.jboss.org/community/wiki/HornetQGeneralFAQs">FAQs wiki
                    page</a>.</p></li></ul></div><p>Why use HornetQ? Here are just a few of the reasons:</p><div class="itemizedlist"><ul><li><p>100% open source software. HornetQ is licensed using the Apache Software License v
                2.0 to minimise barriers to adoption.</p></li><li><p>HornetQ is designed with usability in mind.</p></li><li><p>Written in Java. Runs on any platform with a Java 6+ runtime, that's everything
                from Windows desktops to IBM mainframes.</p></li><li><p>Amazing performance. Our ground-breaking high performance journal provides
                persistent messaging performance at rates normally seen for non-persistent
                messaging, our non-persistent messaging performance rocks the boat too.</p></li><li><p>Full feature set. All the features you'd expect in any serious messaging system,
                and others you won't find anywhere else.</p></li><li><p>Elegant, clean-cut design with minimal third party dependencies. Run HornetQ
                stand-alone, run it in integrated in your favourite JEE application server, or run
                it embedded inside your own product. It's up to you.</p></li><li><p>Seamless high availability. We provide a HA solution with automatic client
                failover so you can guarantee zero message loss or duplication in event of server
                failure.</p></li><li><p>Hugely flexible clustering. Create clusters of servers that know how to load
                balance messages. Link geographically distributed clusters over unreliable
                connections to form a global network. Configure routing of messages in a highly
                flexible way.</p></li><li><p>For a full list of features, please see the <a class="ulink" href="http://www.jboss.org/community/wiki/HornetQFeatures">features wiki
                    page</a> .</p></li></ul></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="project-info"/>Chapter 3. Project Information</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#download.software">3.1. Software Download</a></span></dt><dt><span class="section"><a href="#download.git">3.2. Project Information</a></span></dt></dl></div><p>The official HornetQ project page is <a class="ulink" href="http://hornetq.org/">http://hornetq.org/</a>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="download.software"/>3.1. Software Download</h2></div></div></div><p>The software can be download from the Download page:<a class="ulink" href="http://hornetq.org/downloads.html">http://hornetq.org/downloads.html</a></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="download.git"/>3.2. Project Information</h2></div></div></div><p>
         </p><div class="itemizedlist"><ul><li><p>Please take a look at our project <a class="ulink" href="http://www.jboss.org/community/wiki/HornetQ">wiki</a></p></li><li><p>If you have any user questions please use our <a class="ulink" href="https://community.jboss.org/en/hornetq">user
                     forum</a></p></li><li><p>If you have development related questions, please use our <a class="ulink" href="https://community.jboss.org/en/hornetq/dev">developer forum</a></p></li><li><p>Pop in and chat to us in our <a class="ulink" href="irc://irc.freenode.net:6667/hornetq">IRC channel</a></p></li><li><p>Our project <a class="ulink" href="http://hornetq.blogspot.com/">blog</a></p></li><li><p>Follow us on <a class="ulink" href="http://twitter.com/hornetq">twitter</a></p></li><li><p>HornetQ Git repository is <a class="ulink" href="https://github.com/hornetq/hornetq">https://github.com/hornetq/hornetq</a></p></li><li><p>All release tags are available from <a class="ulink" href="https://github.com/hornetq/hornetq/tags">https://github.com/hornetq/hornetq/tags</a></p></li></ul></div><p>
      </p><p>Red Hat kindly employs developers to work full time on HornetQ, they are: </p><div class="itemizedlist"><ul><li><p>Clebert Suconic (project lead)</p></li><li><p>Andy Taylor</p></li><li><p>Howard Gao</p></li><li><p>Justin Bertram</p></li></ul></div><p> And many thanks to all our contributors, both old and new who helped create HornetQ,
         for a full list of the people who made it happen, take a look at our <a class="ulink" href="http://jboss.org/hornetq/community/team.html">team page</a>. </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="messaging-concepts"/>Chapter 4. Messaging Concepts</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e351">4.1. Messaging Concepts</a></span></dt><dt><span class="section"><a href="#d0e376">4.2. Messaging styles</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e390">4.2.1. The Message Queue Pattern</a></span></dt><dt><span class="section"><a href="#d0e410">4.2.2. The Publish-Subscribe Pattern</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e436">4.3. Delivery guarantees</a></span></dt><dt><span class="section"><a href="#d0e446">4.4. Transactions</a></span></dt><dt><span class="section"><a href="#d0e451">4.5. Durability</a></span></dt><dt><span class="section"><a href="#d0e456">4.6. Messaging APIs and protocols</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e467">4.6.1. Java Message Service (JMS)</a></span></dt><dt><span class="section"><a href="#d0e480">4.6.2. System specific APIs</a></span></dt><dt><span class="section"><a href="#d0e487">4.6.3. RESTful API</a></span></dt><dt><span class="section"><a href="#d0e504">4.6.4. STOMP</a></span></dt><dt><span class="section"><a href="#d0e515">4.6.5. AMQP</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e527">4.7. High Availability</a></span></dt><dt><span class="section"><a href="#d0e538">4.8. Clusters</a></span></dt><dt><span class="section"><a href="#d0e556">4.9. Bridges and routing</a></span></dt></dl></div><p>HornetQ is an asynchronous messaging system, an example of <a class="ulink" href="http://en.wikipedia.org/wiki/Message_oriented_middleware">Message Oriented
            Middleware</a> , we'll just call them messaging systems in the remainder of this
        book.</p><p>We'll first present a brief overview of what kind of things messaging systems do,
        where they're useful and the kind of concepts you'll hear about in the messaging
        world.</p><p>If you're already familiar with what a messaging system is and what it's capable of, then
        you can skip this chapter.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e351"/>4.1. Messaging Concepts</h2></div></div></div><p>Messaging systems allow you to loosely couple heterogeneous systems together, whilst
            typically providing reliability, transactions and many other features.</p><p>Unlike systems based on a <a class="ulink" href="http://en.wikipedia.org/wiki/Remote_procedure_call">Remote Procedure
                Call</a> (RPC) pattern, messaging systems primarily use an asynchronous message
            passing pattern with no tight relationship between requests and responses. Most
            messaging systems also support a request-response mode but this is not a primary feature
            of messaging systems.</p><p>Designing systems to be asynchronous from end-to-end allows you to really take
            advantage of your hardware resources, minimizing the amount of threads blocking on IO
            operations, and to use your network bandwidth to its full capacity. With an RPC approach
            you have to wait for a response for each request you make so are limited by the network
            round trip time, or <span class="italic">latency</span> of your network. With an
            asynchronous system you can pipeline flows of messages in different directions, so are
            limited by the network <span class="italic">bandwidth</span> not the latency.
            This typically allows you to create much higher performance applications.</p><p>Messaging systems decouple the senders of messages from the consumers of messages. The
            senders and consumers of messages are completely independent and know nothing of each
            other. This allows you to create flexible, loosely coupled systems.</p><p>Often, large enterprises use a messaging system to implement a message bus which
            loosely couples heterogeneous systems together. Message buses often form the core of an
                <a class="ulink" href="http://en.wikipedia.org/wiki/Enterprise_service_bus">Enterprise Service
                Bus</a>. (ESB). Using a message bus to de-couple disparate systems can allow the
            system to grow and adapt more easily. It also allows more flexibility to add new systems
            or retire old ones since they don't have brittle dependencies on each other.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e376"/>4.2. Messaging styles</h2></div></div></div><p>Messaging systems normally support two main styles of asynchronous messaging: <a class="ulink" href="http://en.wikipedia.org/wiki/Message_queue"> message queue</a> messaging
            (also known as <span class="italic">point-to-point messaging</span>) and <a class="ulink" href="http://en.wikipedia.org/wiki/Publish_subscribe">publish subscribe</a>
            messaging. We'll summarise them briefly here:</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e390"/>4.2.1. The Message Queue Pattern</h3></div></div></div><p>With this type of messaging you send a message to a queue. The message is then
                typically persisted to provide a guarantee of delivery, then some time later the
                messaging system delivers the message to a consumer. The consumer then processes the
                message and when it is done, it acknowledges the message. Once the message is
                acknowledged it disappears from the queue and is not available to be delivered
                again. If the system crashes before the messaging server receives an acknowledgement
                from the consumer, then on recovery, the message will be available to be delivered
                to a consumer again.</p><p>With point-to-point messaging, there can be many consumers on the queue but a
                particular message will only ever be consumed by a maximum of one of them. Senders
                (also known as<span class="italic"> producers</span>) to the queue are
                completely decoupled from receivers (also known as <span class="italic">consumers</span>) of the queue - they do not know of each other's
                existence.</p><p>A classic example of point to point messaging would be an order queue in a
                company's book ordering system. Each order is represented as a message which is sent
                to the order queue. Let's imagine there are many front end ordering systems which
                send orders to the order queue. When a message arrives on the queue it is persisted
                - this ensures that if the server crashes the order is not lost. Let's also imagine
                there are many consumers on the order queue - each representing an instance of an
                order processing component - these can be on different physical machines but
                consuming from the same queue. The messaging system delivers each message to one and
                only one of the ordering processing components. Different messages can be processed
                by different order processors, but a single order is only processed by one order
                processor - this ensures orders aren't processed twice.</p><p>As an order processor receives a message, it fulfills the order, sends order
                information to the warehouse system and then updates the order database with the
                order details. Once it's done that it acknowledges the message to tell the server
                that the order has been processed and can be forgotten about. Often the send to the
                warehouse system, update in database and acknowledgement will be completed in a
                single transaction to ensure <a class="ulink" href="http://en.wikipedia.org/wiki/ACID">ACID</a> properties.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e410"/>4.2.2. The Publish-Subscribe Pattern</h3></div></div></div><p>With publish-subscribe messaging many senders can send messages to an entity on
                the server, often called a <span class="italic">topic</span> (e.g. in the JMS
                world).</p><p>There can be many <span class="emphasis"><em>subscriptions</em></span> on a topic, a subscription is
                just another word for a consumer of a topic. Each subscription receives a
                    <span class="emphasis"><em>copy</em></span> of <span class="italic">each</span> message
                sent to the topic. This differs from the message queue pattern where each message is
                only consumed by a single consumer.</p><p>Subscriptions can optionally be <span class="italic">durable</span> which
                means they retain a copy of each message sent to the topic until the subscriber
                consumes them - even if the server crashes or is restarted in between. Non-durable
                subscriptions only last a maximum of the lifetime of the connection that created
                them.</p><p>An example of publish-subscribe messaging would be a news feed. As news articles
                are created by different editors around the world they are sent to a news feed
                topic. There are many subscribers around the world who are interested in receiving
                news items - each one creates a subscription and the messaging system ensures that a
                copy of each news message is delivered to each subscription.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e436"/>4.3. Delivery guarantees</h2></div></div></div><p>A key feature of most messaging systems is <span class="italic">reliable
                messaging</span>. With reliable messaging the server gives a guarantee that the
            message will be delivered once and only once to each consumer of a queue or each durable
            subscription of a topic, even in the event of system failure. This is crucial for many
            businesses; e.g. you don't want your orders fulfilled more than once or any of your
            orders to be lost.</p><p>In other cases you may not care about a once and only once delivery guarantee and are
            happy to cope with duplicate deliveries or lost messages - an example of this might be
            transient stock price updates - which are quickly superseded by the next update on the
            same stock. The messaging system allows you to configure which delivery guarantees you
            require.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e446"/>4.4. Transactions</h2></div></div></div><p>Messaging systems typically support the sending and acknowledgement of multiple
            messages in a single local transaction. HornetQ also supports the sending and
            acknowledgement of message as part of a large global transaction - using the Java
            mapping of XA: JTA.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e451"/>4.5. Durability</h2></div></div></div><p>Messages are either durable or non durable. Durable messages will be persisted in
            permanent storage and will survive server failure or restart. Non durable messages will
            not survive server failure or restart. Examples of durable messages might be orders or
            trades, where they cannot be lost. An example of a non durable message might be a stock
            price update which is transitory and doesn't need to survive a restart.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e456"/>4.6. Messaging APIs and protocols</h2></div></div></div><p>How do client applications interact with messaging systems in order to send and
            consume messages?</p><p>Several messaging systems provide their own proprietary APIs with which the client
            communicates with the messaging system.</p><p>There are also some standard ways of operating with messaging systems and some
            emerging standards in this space.</p><p>Let's take a brief look at these:</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e467"/>4.6.1. Java Message Service (JMS)</h3></div></div></div><p><a class="ulink" href="http://en.wikipedia.org/wiki/Java_Message_Service">JMS</a> is part
                of Sun's JEE specification. It's a Java API that encapsulates both message queue and
                publish-subscribe messaging patterns. JMS is a lowest common denominator
                specification - i.e. it was created to encapsulate common functionality of the
                already existing messaging systems that were available at the time of its
                creation.</p><p>JMS is a very popular API and is implemented by most messaging systems. JMS is
                only available to clients running Java.</p><p>JMS does not define a standard wire format - it only defines a programmatic API so
                JMS clients and servers from different vendors cannot directly interoperate since
                each will use the vendor's own internal wire protocol.</p><p>HornetQ provides a fully compliant JMS 1.1 and JMS 2.0 API.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e480"/>4.6.2. System specific APIs</h3></div></div></div><p>Many systems provide their own programmatic API for which to interact with the
                messaging system. The advantage of this it allows the full set of system
                functionality to be exposed to the client application. API's like JMS are not
                normally rich enough to expose all the extra features that most messaging systems
                provide.</p><p>HornetQ provides its own core client API for clients to use if they wish to have
                access to functionality over and above that accessible via the JMS API.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e487"/>4.6.3. RESTful API</h3></div></div></div><p><a class="ulink" href="http://en.wikipedia.org/wiki/Representational_State_Transfer">REST</a> approaches to messaging are showing a lot interest
                recently.</p><p>It seems plausible that API standards for cloud computing may converge on a REST
                style set of interfaces and consequently a REST messaging approach is a very strong
                contender for becoming the de-facto method for messaging interoperability.</p><p>With a REST approach messaging resources are manipulated as resources defined by a
                URI and typically using a simple set of operations on those resources, e.g. PUT,
                POST, GET etc. REST approaches to messaging often use HTTP as their underlying
                protocol.</p><p>The advantage of a REST approach with HTTP is in its simplicity and the fact the
                internet is already tuned to deal with HTTP optimally.</p><p>Please see <a class="xref" href="#rest" title="Chapter 43. REST Interface">Chapter 43, <i>REST Interface</i></a> for using HornetQ's RESTful interface.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e504"/>4.6.4. STOMP</h3></div></div></div><p><a class="ulink" href="http://stomp.github.io/">Stomp</a> is a very simple text protocol for interoperating with messaging
                systems. It defines a wire format, so theoretically any Stomp client can work with
                any messaging system that supports Stomp. Stomp clients are available in many
                different programming languages.</p><p>Please see <a class="xref" href="#stomp" title="48.1. Stomp">Section 48.1, “Stomp”</a> for using STOMP with HornetQ.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e515"/>4.6.5. AMQP</h3></div></div></div><p><a class="ulink" href="http://en.wikipedia.org/wiki/AMQP">AMQP</a> is a specification for
                interoperable messaging. It also defines a wire format, so any AMQP client can work
                with any messaging system that supports AMQP. AMQP clients are available in many
                different programming languages.</p><p>HornetQ implements the <a class="ulink" href="https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=amqp">AMQP 1.0</a>
            specification. Any client that supports the 1.0 specification will be able to interact with HornetQ.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e527"/>4.7. High Availability</h2></div></div></div><p>High Availability (HA) means that the system should remain operational after failure
            of one or more of the servers. The degree of support for HA varies between various
            messaging systems.</p><p>HornetQ provides automatic failover where your sessions are automatically reconnected
            to the backup server on event of live server failure.</p><p>For more information on HA, please see <a class="xref" href="#ha" title="Chapter 39. High Availability and Failover">Chapter 39, <i>High Availability and Failover</i></a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e538"/>4.8. Clusters</h2></div></div></div><p>Many messaging systems allow you to create groups of messaging servers called
                <span class="italic">clusters</span>. Clusters allow the load of sending and
            consuming messages to be spread over many servers. This allows your system to scale
            horizontally by adding new servers to the cluster.</p><p>Degrees of support for clusters varies between messaging systems, with some systems
            having fairly basic clusters with the cluster members being hardly aware of each
            other.</p><p>HornetQ provides very configurable state-of-the-art clustering model where messages
            can be intelligently load balanced between the servers in the cluster, according to the
            number of consumers on each node, and whether they are ready for messages.</p><p>HornetQ also has the ability to automatically redistribute messages between nodes of a
            cluster to prevent starvation on any particular node.</p><p>For full details on clustering, please see <a class="xref" href="#clusters" title="Chapter 38. Clusters">Chapter 38, <i>Clusters</i></a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e556"/>4.9. Bridges and routing</h2></div></div></div><p>Some messaging systems allow isolated clusters or single nodes to be bridged together,
            typically over unreliable connections like a wide area network (WAN), or the
            internet.</p><p>A bridge normally consumes from a queue on one server and forwards messages to another
            queue on a different server. Bridges cope with unreliable connections, automatically
            reconnecting when the connections becomes available again.</p><p>HornetQ bridges can be configured with filter expressions to only forward certain
            messages, and transformation can also be hooked in.</p><p>HornetQ also allows routing between queues to be configured in server side
            configuration. This allows complex routing networks to be set up forwarding or copying
            messages from one destination to another, forming a global network of interconnected
            brokers.</p><p>For more information please see <a class="xref" href="#core-bridges" title="Chapter 36. Core Bridges">Chapter 36, <i>Core Bridges</i></a> and <a class="xref" href="#diverts" title="Chapter 35. Diverting and Splitting Message Flows">Chapter 35, <i>Diverting and Splitting Message Flows</i></a>.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="architecture"/>Chapter 5. Architecture</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e595">5.1. Core Architecture</a></span></dt><dt><span class="section"><a href="#d0e638">5.2. HornetQ embedded in your own application</a></span></dt><dt><span class="section"><a href="#d0e647">5.3. HornetQ integrated with a JEE application server</a></span></dt><dt><span class="section"><a href="#d0e679">5.4. HornetQ stand-alone server</a></span></dt></dl></div><p>In this section we will give an overview of the HornetQ high level architecture.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e595"/>5.1. Core Architecture</h2></div></div></div><p>HornetQ core is designed simply as set of Plain Old Java Objects (POJOs) - we hope you
            like its clean-cut design.</p><p>We've also designed it to have as few dependencies on external jars as possible. In
            fact, HornetQ core has only one jar dependency, netty.jar,
            other than the standard JDK classes! This is because we use some of the netty buffer classes
        internally.</p><p>This allows HornetQ to be easily embedded in your own project, or instantiated in any
            dependency injection framework such as JBoss Microcontainer, Spring or Google
            Guice.</p><p>Each HornetQ server has its own ultra high performance persistent journal, which it
            uses for message and other persistence.</p><p>Using a high performance journal allows outrageous persistence message performance,
            something not achievable when using a relational database for persistence.</p><p>HornetQ clients, potentially on different physical machines interact with the HornetQ
            server. HornetQ currently provides two APIs for messaging at the client side:</p><p>
            </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>Core client API. This is a simple intuitive Java API that allows the full
                        set of messaging functionality without some of the complexities of
                        JMS.</p></li><li><p>JMS client API. The standard JMS API is available at the client
                        side.</p></li></ol></div><p>
        </p><p>JMS semantics are implemented by a thin JMS facade layer on the client side.</p><p>The HornetQ server does not speak JMS and in fact does not know anything about JMS,
            it is a protocol agnostic messaging server designed to be used with multiple different
            protocols.</p><p>When a user uses the JMS API on the client side, all JMS interactions are translated
            into operations on the HornetQ core client API before being transferred over the wire
            using the HornetQ wire format.</p><p>The server always just deals with core API interactions.</p><p>A schematic illustrating this relationship is shown in figure 3.1 below:</p><p>
            </p><div align="center"><img src="images/architecture1.jpg" align="middle"/></div><p>
        </p><p>Figure 3.1 shows two user applications interacting with a HornetQ server. User
            Application 1 is using the JMS API, while User Application 2 is using the core client
            API directly.</p><p>You can see from the diagram that the JMS API is implemented by a thin facade layer on
            the client side.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e638"/>5.2. HornetQ embedded in your own application</h2></div></div></div><p>HornetQ core is designed as a set of simple POJOs so if you have an application that
            requires messaging functionality internally but you don't want to expose that as a
            HornetQ server you can directly instantiate and embed HornetQ servers in your own
            application.</p><p>For more information on embedding HornetQ, see <a class="xref" href="#embedding-hornetq" title="Chapter 44. Embedding HornetQ">Chapter 44, <i>Embedding HornetQ</i></a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e647"/>5.3. HornetQ integrated with a JEE application server</h2></div></div></div><p>HornetQ provides its own fully functional Java Connector Architecture (JCA) adaptor
            which enables it to be integrated easily into any JEE compliant application server or
            servlet engine.</p><p>JEE application servers provide Message Driven Beans (MDBs), which are a special type
            of Enterprise Java Beans (EJBs) that can process messages from sources such as JMS
            systems or mail systems.</p><p>Probably the most common use of an MDB is to consume messages from a JMS messaging
            system.</p><p>According to the JEE specification, a JEE application server uses a JCA adapter to
            integrate with a JMS messaging system so it can consume messages for MDBs.</p><p>However, the JCA adapter is not only used by the JEE application server for <span class="italic">consuming</span> messages via MDBs, it is also used when sending
            message to the JMS messaging system e.g. from inside an EJB or servlet.</p><p>When integrating with a JMS messaging system from inside a JEE application server it
            is always recommended that this is done via a JCA adaptor. In fact, communicating with a
            JMS messaging system directly, without using JCA would be illegal according to the JEE
            specification.</p><p>The application server's JCA service provides extra functionality such as connection
            pooling and automatic transaction enlistment, which are desirable when using messaging,
            say, from inside an EJB. It is possible to talk to a JMS messaging system directly from
            an EJB, MDB or servlet without going through a JCA adapter, but this is not recommended
            since you will not be able to take advantage of the JCA features, such as caching of JMS
            sessions, which can result in poor performance.</p><p>Figure 3.2 below shows a JEE application server integrating with a HornetQ server via
            the HornetQ JCA adaptor. Note that all communication between EJB sessions or entity
            beans and Message Driven beans go through the adaptor and not directly to
            HornetQ.</p><p>The large arrow with the prohibited sign shows an EJB session bean talking directly to
            the HornetQ server. This is not recommended as you'll most likely end up creating a new
            connection and session every time you want to interact from the EJB, which is an
            anti-pattern.</p><p>
            </p><div><img src="images/architecture2.jpg"/></div><p>
        </p><p>For more information on using the JCA adaptor, please see <a class="xref" href="#appserver-integration" title="Chapter 32. Application Server Integration and Java EE">Chapter 32, <i>Application Server Integration and Java EE</i></a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e679"/>5.4. HornetQ stand-alone server</h2></div></div></div><p>HornetQ can also be deployed as a stand-alone server. This means a fully independent
            messaging server not dependent on a JEE application server.</p><p>The standard stand-alone messaging server configuration comprises a core messaging
            server, a JMS service and a JNDI service.</p><p>The role of the JMS Service is to deploy any JMS Queue, Topic and ConnectionFactory
            instances from any server side <code class="literal">hornetq-jms.xml</code> configuration files.
            It also provides a simple management API for creating and destroying Queues, Topics and
            ConnectionFactory instances which can be accessed via JMX or the connection. It is a
            separate service to the HornetQ core server, since the core server is JMS agnostic. If
            you don't want to deploy any JMS Queue, Topic or ConnectionFactory instances via server
            side XML configuration and don't require a JMS management API on the server side then
            you can disable this service.</p><p>We also include a JNDI server since JNDI is a common requirement when using JMS to
            lookup Queues, Topics and ConnectionFactory instances. If you do not require JNDI then
            this service can also be disabled. HornetQ allows you to programmatically create JMS and
            core objects directly on the client side as opposed to looking them up from JNDI, so a
            JNDI server is not always a requirement.</p><p>The stand-alone server configuration uses JBoss Microcontainer to instantiate and
            enforce dependencies between the components. JBoss Microcontainer is a very lightweight
            POJO bootstrapper.</p><p>The stand-alone server architecture is shown in figure 3.3 below:</p><p>
            </p><div><img src="images/architecture3.jpg"/></div><p>
        </p><p>For more information on server configuration files see <a class="xref" href="#server.configuration" title="50.1. Server Configuration">Section 50.1, “Server Configuration”</a>. $ </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="using-server"/>Chapter 6. Using the Server</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e733">6.1. Starting and Stopping the standalone server</a></span></dt><dt><span class="section"><a href="#d0e785">6.2. Server JVM settings</a></span></dt><dt><span class="section"><a href="#d0e806">6.3. Server classpath</a></span></dt><dt><span class="section"><a href="#using-server.library.path">6.4. Library Path</a></span></dt><dt><span class="section"><a href="#d0e865">6.5. System properties</a></span></dt><dt><span class="section"><a href="#using-server.configuration">6.6. Configuration files</a></span></dt><dt><span class="section"><a href="#server.microcontainer.configuration">6.7. JBoss Microcontainer Beans File</a></span></dt><dt><span class="section"><a href="#server.microkernel.configuration">6.8. JBoss AS4 MBean Service.</a></span></dt><dt><span class="section"><a href="#usingserver.mainconfig">6.9. The main configuration file.</a></span></dt></dl></div><p>This chapter will familiarise you with how to use the HornetQ server.</p><p>We'll show where it is, how to start and stop it, and we'll describe the directory layout
        and what all the files are and what they do.</p><p>For the remainder of this chapter when we talk about the HornetQ server we mean the
        HornetQ standalone server, in its default configuration with a JMS Service and JNDI service
        enabled.</p><p>When running embedded in JBoss Application Server the layout may be slightly different but
        by-and-large will be the same.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e733"/>6.1. Starting and Stopping the standalone server</h2></div></div></div><p>In the distribution you will find a directory called <code class="literal">bin</code>.</p><p><code class="literal">cd</code> into that directory and you will find a Unix/Linux script called
                <code class="literal">run.sh</code> and a windows batch file called <code class="literal">run.bat</code></p><p>To run on Unix/Linux type <code class="literal">./run.sh</code></p><p>To run on Windows type <code class="literal">run.bat</code></p><p>These scripts are very simple and basically just set-up the classpath and some JVM
            parameters and start the JBoss Microcontainer. The Microcontainer is a light weight
            container used to deploy the HornetQ POJO's</p><p>To stop the server you will also find a Unix/Linux script <code class="literal">stop.sh</code> and
            a windows batch file <code class="literal">stop.bat</code></p><p>To run on Unix/Linux type <code class="literal">./stop.sh</code></p><p>To run on Windows type <code class="literal">stop.bat</code></p><p>Please note that HornetQ requires a Java 6 or later runtime to run.</p><p>Both the run and the stop scripts use the config under <code class="literal">config/stand-alone/non-clustered</code> by default. The configuration can be
            changed by running <code class="literal">./run.sh ../config/stand-alone/clustered</code> or
            another config of your choosing. This is the same for the stop script and the windows
            bat files.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e785"/>6.2. Server JVM settings</h2></div></div></div><p>The run scripts <code class="literal">run.sh</code> and <code class="literal">run.bat</code> set some JVM
            settings for tuning running on Java 6 and choosing the garbage collection policy. We
            recommend using a parallel garbage collection algorithm to smooth out latency and
            minimise large GC pauses.</p><p>By default HornetQ runs in a maximum of 1GiB of RAM. To increase the memory settings
            change the <code class="literal">-Xms</code> and <code class="literal">-Xmx</code> memory settings as you
            would for any Java program.</p><p>If you wish to add any more JVM arguments or tune the existing ones, the run scripts
            are the place to do it.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e806"/>6.3. Server classpath</h2></div></div></div><p>HornetQ looks for its configuration files on the Java classpath.</p><p>The scripts <code class="literal">run.sh</code> and <code class="literal">run.bat</code> specify the
            classpath when calling Java to run the server.</p><p>In the distribution, the run scripts will add the non clustered configuration
            directory to the classpath. This is a directory which contains a set of configuration
            files for running the HornetQ server in a basic non-clustered configuration. In the
            distribution this directory is <code class="literal">config/stand-alone/non-clustered/</code> from
            the root of the distribution.</p><p>The distribution contains several standard configuration sets for running:</p><div class="itemizedlist"><ul><li><p>Non clustered stand-alone.</p></li><li><p>Clustered stand-alone</p></li><li><p>Non clustered in JBoss Application Server</p></li><li><p>Clustered in JBoss Application Server</p></li></ul></div><p>You can of course create your own configuration and specify any configuration
            directory when running the run script.</p><p>Just make sure the directory is on the classpath and HornetQ will search there when
            starting up.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="using-server.library.path"/>6.4. Library Path</h2></div></div></div><p>If you're using the <a class="link" href="#aio-journal">Asynchronous IO Journal</a> on
            Linux, you need to specify <code class="literal">java.library.path</code> as a property on your
            Java options. This is done automatically in the <code class="literal">run.sh</code> script.</p><p>If you don't specify <code class="literal">java.library.path</code> at your Java options then
            the JVM will use the environment variable <code class="literal">LD_LIBRARY_PATH</code>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e865"/>6.5. System properties</h2></div></div></div><p>HornetQ can take a system property on the command line for configuring logging.</p><p>For more information on configuring logging, please see <a class="xref" href="#logging" title="Chapter 42. Logging">Chapter 42, <i>Logging</i></a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="using-server.configuration"/>6.6. Configuration files</h2></div></div></div><p>The configuration directory is specified on the classpath in the run scripts <code class="literal">run.sh</code> and <code class="literal">run.bat</code> This directory can contain the
            following files.</p><div class="itemizedlist"><ul><li><p><code class="literal">hornetq-beans.xml</code> (or <code class="literal">hornetq-jboss-beans.xml</code> if you're running inside JBoss
                    Application Server). This is the JBoss Microcontainer beans file which defines
                    what beans the Microcontainer should create and what dependencies to enforce
                    between them. Remember that HornetQ is just a set of POJOs. In the stand-alone
                    server, it's the JBoss Microcontainer which instantiates these POJOs and
                    enforces dependencies between them and other beans. </p></li><li><p><code class="literal">hornetq-configuration.xml</code>. This is the main HornetQ
                    configuration file. All the parameters in this file are described in <a class="xref" href="#configuration-index" title="Chapter 50. Configuration Reference">Chapter 50, <i>Configuration Reference</i></a>. Please see <a class="xref" href="#usingserver.mainconfig" title="6.9. The main configuration file.">Section 6.9, “The main configuration file.”</a> for more information on this file.</p></li><li><p><code class="literal">hornetq-queues.xml</code>. This file contains predefined queues,
                    queue settings and security settings. The file is optional - all this
                    configuration can also live in <code class="literal">hornetq-configuration.xml</code>. In
                    fact, the default configuration sets do not have a <code class="literal">hornetq-queues.xml</code> file. The purpose of allowing queues to be
                    configured in these files is to allow you to manage your queue configuration
                    over many files instead of being forced to maintain it in a single file. There
                    can be many <code class="literal">hornetq-queues.xml</code> files on the classpath. All
                    will be loaded if found.</p></li><li><p><code class="literal">hornetq-users.xml</code> HornetQ ships with a basic security
                    manager implementation which obtains user credentials from the <code class="literal">hornetq-users.xml</code> file. This file contains user, password and
                    role information. For more information on security, please see <a class="xref" href="#security" title="Chapter 31. Security">Chapter 31, <i>Security</i></a>.</p></li><li><p><code class="literal">hornetq-jms.xml</code> The distro configuration by default
                    includes a server side JMS service which mainly deploys JMS Queues, Topics and
                    ConnectionFactorys from this file into JNDI. If you're not using JMS, or you
                    don't need to deploy JMS objects on the server side, then you don't need this
                    file. For more information on using JMS, please see <a class="xref" href="#using-jms" title="Chapter 7. Using JMS">Chapter 7, <i>Using JMS</i></a>.</p></li><li><p><code class="literal">logging.properties</code> This is used to configure the logging
                    handlers used by the Java logger. For more information on configuring logging,
                    please see <a class="xref" href="#logging" title="Chapter 42. Logging">Chapter 42, <i>Logging</i></a>.</p></li></ul></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>The property <code class="literal">file-deployment-enabled</code> in the <code class="literal">hornetq-configuration.xml</code> configuration when set to false means that
                the other configuration files are not loaded. This is true by default.</p></div><p>It is also possible to use system property substitution in all the configuration
            files. by replacing a value with the name of a system property. Here is an example of
            this with a connector configuration:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;connector name="netty"&gt;
   &lt;factory-class&gt;org.hornetq.core.remoting.impl.netty.NettyConnectorFactory&lt;/factory-class&gt;
   &lt;param key="host" value="${hornetq.remoting.netty.host:localhost}"/&gt;
   &lt;param key="port" value="${hornetq.remoting.netty.port:5445}"/&gt;
&lt;/connector&gt;</pre><p>Here you can see we have replaced 2 values with system properties <code class="literal">hornetq.remoting.netty.host</code> and <code class="literal">hornetq.remoting.netty.port</code>. These values will be replaced by the value
            found in the system property if there is one, if not they default back to localhost or
            5445 respectively. It is also possible to not supply a default. i.e. <code class="literal">${hornetq.remoting.netty.host}</code>, however the system property
                <span class="emphasis"><em>must</em></span> be supplied in that case.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="server.microcontainer.configuration"/>6.7. JBoss Microcontainer Beans File</h2></div></div></div><p>The stand-alone server is basically a set of POJOs which are instantiated by the light
                weight<a class="ulink" href="http://www.jboss.org/jbossmc/"> JBoss Microcontainer
            </a>engine.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>A beans file is also needed when the server is deployed in the JBoss Application
                Server but this will deploy a slightly different set of objects since the
                Application Server will already have things like security etc deployed.</p></div><p>Let's take a look at an example beans file from the stand-alone server:</p><p>
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;deployment xmlns="urn:jboss:bean-deployer:2.0"&gt;

   &lt;!-- MBean server --&gt;
   &lt;bean name="MBeanServer" class="javax.management.MBeanServer"&gt;
      &lt;constructor factoryClass="java.lang.management.ManagementFactory"
                   factoryMethod="getPlatformMBeanServer"/&gt;
   &lt;/bean&gt;

   &lt;!-- The core configuration --&gt;
   &lt;bean name="Configuration" class="org.hornetq.core.config.impl.FileConfiguration"&gt;
   &lt;/bean&gt;

    &lt;!-- The security manager --&gt;
   &lt;bean name="HornetQSecurityManager" class="org.hornetq.spi.core.security.HornetQSecurityManagerImpl"&gt;
      &lt;start ignored="true"/&gt;
      &lt;stop ignored="true"/&gt;
   &lt;/bean&gt;

    &lt;!-- The core server --&gt;
   &lt;bean name="HornetQServer" class="org.hornetq.core.server.impl.HornetQServerImpl"&gt;
      &lt;constructor&gt;
         &lt;parameter&gt;
            &lt;inject bean="Configuration"/&gt;
         &lt;/parameter&gt;
         &lt;parameter&gt;
            &lt;inject bean="MBeanServer"/&gt;
         &lt;/parameter&gt;
         &lt;parameter&gt;
            &lt;inject bean="HornetQSecurityManager"/&gt;
         &lt;/parameter&gt;
      &lt;/constructor&gt;
      &lt;start ignored="true"/&gt;
      &lt;stop ignored="true"/&gt;
   &lt;/bean&gt;

    &lt;!-- The Stand alone server that controls the jndi server--&gt;
   &lt;bean name="StandaloneServer" class="org.hornetq.jms.server.impl.StandaloneNamingServer"&gt;
      &lt;constructor&gt;
         &lt;parameter&gt;
            &lt;inject bean="HornetQServer"/&gt;
         &lt;/parameter&gt;
      &lt;/constructor&gt;
      &lt;property name="port"&gt;${jnp.port:1099}&lt;/property&gt;
      &lt;property name="bindAddress"&gt;${jnp.host:localhost}&lt;/property&gt;
      &lt;property name="rmiPort"&gt;${jnp.rmiPort:1098}&lt;/property&gt;
      &lt;property name="rmiBindAddress"&gt;${jnp.host:localhost}&lt;/property&gt;
   &lt;/bean&gt;

   &lt;!-- The JMS server --&gt;
   &lt;bean name="JMSServerManager" class="org.hornetq.jms.server.impl.JMSServerManagerImpl"&gt;
      &lt;constructor&gt;
         &lt;parameter&gt;
            &lt;inject bean="HornetQServer"/&gt;
         &lt;/parameter&gt;
      &lt;/constructor&gt;
   &lt;/bean&gt;


&lt;/deployment&gt;</pre><p>
        </p><p>We can see that, as well as the core HornetQ server, the stand-alone server
            instantiates various different POJOs, let's look at them in turn:</p><div class="itemizedlist"><ul><li><p>MBeanServer</p><p>In order to provide a JMX management interface a JMS MBean server is necessary
                    in which to register the management objects. Normally this is just the default
                    platform MBean server available in the JVM instance. If you don't want to
                    provide a JMX management interface this can be commented out or removed.</p></li><li><p>Configuration</p><p>The HornetQ server is configured with a Configuration object. In the default
                    stand-alone set-up it uses a FileConfiguration object which knows to read
                    configuration information from the file system. In different configurations such
                    as embedded you might want to provide configuration information from somewhere
                    else.</p></li><li><p>Security Manager. The security manager used by the messaging server is
                    pluggable. The default one used just reads user-role information from the
                        <code class="literal">hornetq-users.xml</code> file on disk. However it can be
                    replaced by a JAAS security manager, or when running inside JBoss Application
                    Server it can be configured to use the JBoss AS security manager for tight
                    integration with JBoss AS security. If you've disabled security altogether you
                    can remove this too.</p></li><li><p>HornetQServer</p><p>This is the core server. It's where 99% of the magic happens</p></li><li><p>StandaloneServer</p><p>Many clients like to look up JMS Objects from JNDI so we provide a JNDI server
                    for them to do that. This class is a wrapper around the JBoss naming server.
                   If you don't need JNDI this can be commented out or removed.</p></li><li><p><a id="bean-jmsservermanager"/>JMSServerManager</p><p>This deploys any JMS Objects such as JMS Queues, Topics and ConnectionFactory
                    instances from <code class="literal">hornetq-jms.xml</code> files on the disk. It also
                    provides a simple management API for manipulating JMS Objects. On the whole it
                    just translates and delegates its work to the core server. If you don't need to
                    deploy JMS Queues, Topics and ConnectionFactorys from server side configuration
                    and don't require the JMS management interface this can be disabled.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="server.microkernel.configuration"/>6.8. JBoss AS4 MBean Service.</h2></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>The section is only to configure HornetQ on JBoss AS4. The service functionality is
                similar to Microcontainer Beans</p></div><p>
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;server&gt;
   &lt;mbean code="org.hornetq.service.HornetQFileConfigurationService"
      name="org.hornetq:service=HornetQFileConfigurationService"&gt;
   &lt;/mbean&gt;

   &lt;mbean code="org.hornetq.service.JBossASSecurityManagerService"
      name="org.hornetq:service=JBossASSecurityManagerService"&gt;
   &lt;/mbean&gt;

   &lt;mbean code="org.hornetq.service.HornetQStarterService" 
      name="org.hornetq:service=HornetQStarterService"&gt;
      &lt;!--let's let the JMS Server start us--&gt;
         &lt;attribute name="Start"&gt;false&lt;/attribute&gt;

      &lt;depends optional-attribute-name="SecurityManagerService"
         proxy-type="attribute"&gt;org.hornetq:service=JBossASSecurityManagerService&lt;/depends&gt;
      &lt;depends optional-attribute-name="ConfigurationService"
         proxy-type="attribute"&gt;org.hornetq:service=HornetQFileConfigurationService&lt;/depends&gt;
   &lt;/mbean&gt;

   &lt;mbean code="org.hornetq.service.HornetQJMSStarterService"
      name="org.hornetq:service=HornetQJMSStarterService"&gt;
      &lt;depends optional-attribute-name="HornetQServer"
         proxy-type="attribute"&gt;org.hornetq:service=HornetQStarterService&lt;/depends&gt;
   &lt;/mbean&gt;
&lt;/server&gt;</pre><p>
        </p><p>This jboss-service.xml configuration file is included inside the hornetq-service.sar
            on AS4 with embedded HornetQ. As you can see, on this configuration file we are starting
            various services:</p><div class="itemizedlist"><ul><li><p>HornetQFileConfigurationService</p><p>This is an MBean Service that takes care of the life cycle of the <code class="literal">FileConfiguration POJO</code></p></li><li><p>JBossASSecurityManagerService</p><p>This is an MBean Service that takes care of the lifecycle of the <code class="literal">JBossASSecurityManager</code> POJO</p></li><li><p>HornetQStarterService</p><p>This is an MBean Service that controls the main <code class="literal">HornetQServer</code> POJO.
                   this has a dependency on JBossASSecurityManagerService and HornetQFileConfigurationService MBeans</p></li><li><p>HornetQJMSStarterService</p><p>This is an MBean Service that controls the <code class="literal">JMSServerManagerImpl</code> POJO.
                   If you aren't using jms this can be removed.</p></li><li><p>JMSServerManager</p><p>Has the responsibility to start the JMSServerManager and the same behaviour that JMSServerManager Bean</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="usingserver.mainconfig"/>6.9. The main configuration file.</h2></div></div></div><p>The configuration for the HornetQ core server is contained in <code class="literal">hornetq-configuration.xml</code>. This is what the FileConfiguration bean uses
            to configure the messaging server.</p><p>There are many attributes which you can configure HornetQ. In most cases the defaults
            will do fine, in fact every attribute can be defaulted which means a file with a single
            empty <code class="literal">configuration</code> element is a valid configuration file. The
            different configuration will be explained throughout the manual or you can refer to the
            configuration reference <a class="link" href="#configuration-index" title="Chapter 50. Configuration Reference">here</a>.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="using-jms"/>Chapter 7. Using JMS</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e1122">7.1. A simple ordering system</a></span></dt><dt><span class="section"><a href="#using-jms.server.configuration">7.2. JMS Server Configuration</a></span></dt><dt><span class="section"><a href="#using-jms.configure.factory.types">7.3. Connection Factory Types</a></span></dt><dt><span class="section"><a href="#d0e1265">7.4. JNDI configuration</a></span></dt><dt><span class="section"><a href="#d0e1307">7.5. The code</a></span></dt><dt><span class="section"><a href="#d0e1364">7.6. Directly instantiating JMS Resources without using JNDI</a></span></dt><dt><span class="section"><a href="#using-jms.clientid">7.7. Setting The Client ID</a></span></dt><dt><span class="section"><a href="#using-jms.dupsokbatchsize">7.8. Setting The Batch Size for DUPS_OK </a></span></dt><dt><span class="section"><a href="#using-jms.txbatchsize">7.9. Setting The Transaction Batch Size</a></span></dt></dl></div><p>Although HornetQ provides a JMS agnostic messaging API, many users will be more
        comfortable using JMS.</p><p>JMS is a very popular API standard for messaging, and most messaging systems provide a JMS
        API. If you are completely new to JMS we suggest you follow the<a class="ulink" href="http://docs.oracle.com/javaee/1.3/jms/tutorial"> Sun
            JMS tutorial</a> - a full JMS tutorial is out of scope for this guide.</p><p>HornetQ also ships with a wide range of examples, many of which demonstrate JMS API usage.
        A good place to start would be to play around with the simple JMS Queue and Topic example,
        but we also provide examples for many other parts of the JMS API. A full description of the
        examples is available in <a class="xref" href="#examples" title="Chapter 11. Examples">Chapter 11, <i>Examples</i></a>.</p><p>In this section we'll go through the main steps in configuring the server for JMS and
        creating a simple JMS program. We'll also show how to configure and use JNDI, and also how
        to use JMS with HornetQ without using any JNDI.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1122"/>7.1. A simple ordering system</h2></div></div></div><p>For this chapter we're going to use a very simple ordering system as our example. It is
            a somewhat contrived example because of its extreme simplicity, but it serves to
            demonstrate the very basics of setting up and using JMS.</p><p>We will have a single JMS Queue called <code class="literal">OrderQueue</code>, and we will have
            a single <code class="literal">MessageProducer</code> sending an order message to the queue and a
            single <code class="literal">MessageConsumer</code> consuming the order message from the
            queue.</p><p>The queue will be a <code class="literal">durable</code> queue, i.e. it will survive a server
            restart or crash. We also want to pre-deploy the queue, i.e. specify the queue in the
            server JMS configuration so it is created automatically without us having to explicitly
            create it from the client.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="using-jms.server.configuration"/>7.2. JMS Server Configuration</h2></div></div></div><p>The file <code class="literal">hornetq-jms.xml</code> on the server classpath contains any JMS
            Queue, Topic and ConnectionFactory instances that we wish to create and make available
            to lookup via the JNDI.</p><p>A JMS ConnectionFactory object is used by the client to make connections to the
            server. It knows the location of the server it is connecting to, as well as many other
            configuration parameters. In most cases the defaults will be acceptable.</p><p>We'll deploy a single JMS Queue and a single JMS Connection Factory instance on the
            server for this example but there are no limits to the number of Queues, Topics and
            Connection Factory instances you can deploy from the file. Here's our
            configuration:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;configuration xmlns="urn:hornetq" 
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="urn:hornetq ../schemas/hornetq-jms.xsd "&gt;
    
   &lt;connection-factory name="ConnectionFactory"&gt;
      &lt;connectors&gt;
         &lt;connector-ref connector-name="netty"/&gt;
      &lt;/connectors&gt;
      &lt;entries&gt;
         &lt;entry name="ConnectionFactory"/&gt;
      &lt;/entries&gt;
   &lt;/connection-factory&gt;

   &lt;queue name="OrderQueue"&gt;
      &lt;entry name="queues/OrderQueue"/&gt;
   &lt;/queue&gt;
&lt;/configuration&gt;</pre><p>We deploy one ConnectionFactory called <code class="literal">ConnectionFactory</code> and bind
            it in just one place in JNDI as given by the <code class="literal">entry</code> element.
            ConnectionFactory instances can be bound in many places in JNDI if you require. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>The JMS connection factory references a <code class="literal">connector</code> called
                    <code class="literal">netty</code>. This is a reference to a connector object deployed in
                the main core configuration file <code class="literal">hornetq-configuration.xml</code> which
                defines the transport and parameters used to actually connect to the server.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="using-jms.configure.factory.types"/>7.3. Connection Factory Types</h2></div></div></div><p>The JMS API doc provides several connection factories for applications. HornetQ JMS users
              can choose to configure the types for their connection factories. Each connection factory
              has a <code class="literal">signature</code> attribute and a <code class="literal">xa</code> parameter, the
              combination of which determines the type of the factory. Attribute <code class="literal">signature</code>
              has three possible string values, i.e. <span class="emphasis"><em>generic</em></span>, 
              <span class="emphasis"><em>queue</em></span> and <span class="emphasis"><em>topic</em></span>; <code class="literal">xa</code> is a boolean
              type parameter. The following table gives their configuration values for different 
              connection factory interfaces.</p><div class="table"><a id="using-jms.table.configure.factory.types"/><p class="title"><b>Table 7.1. Configuration for Connection Factory Types</b></p><div class="table-contents"><table summary="Configuration for Connection Factory Types" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>signature</th><th>xa</th><th>Connection Factory Type</th></tr></thead><tbody><tr><td>generic (default)</td><td>false (default)</td><td>javax.jms.ConnectionFactory</td></tr><tr><td>generic</td><td>true</td><td>javax.jms.XAConnectionFactory</td></tr><tr><td>queue</td><td>false</td><td>javax.jms.QueueConnectionFactory</td></tr><tr><td>queue</td><td>true</td><td>javax.jms.XAQueueConnectionFactory</td></tr><tr><td>topic</td><td>false</td><td>javax.jms.TopicConnectionFactory</td></tr><tr><td>topic</td><td>true</td><td>javax.jms.XATopicConnectionFactory</td></tr></tbody></table></div></div><br class="table-break"/><p>As an example, the following configures an XAQueueConnectionFactory:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;configuration xmlns="urn:hornetq" 
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="urn:hornetq ../schemas/hornetq-jms.xsd "&gt;

   &lt;connection-factory name="ConnectionFactory" signature="queue"&gt;
      &lt;xa&gt;true&lt;/xa&gt;
      &lt;connectors&gt;
         &lt;connector-ref connector-name="netty"/&gt;
      &lt;/connectors&gt;
      &lt;entries&gt;
         &lt;entry name="ConnectionFactory"/&gt;
      &lt;/entries&gt;
   &lt;/connection-factory&gt;
&lt;/configuration&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1265"/>7.4. JNDI configuration</h2></div></div></div><p>When using JNDI from the client side you need to specify a set of JNDI properties
            which tell the JNDI client where to locate the JNDI server, amongst other things. These
            are often specified in a file called <code class="literal">jndi.properties</code> on the client
            classpath, or you can specify them directly when creating the JNDI initial context. A
            full JNDI tutorial is outside the scope of this document, please see the <a class="ulink" href="http://docs.oracle.com/javase/jndi/tutorial">Sun JNDI tutorial</a>
            for more information on how to use JNDI.</p><p>For talking to the JBoss JNDI Server, the jndi properties will look something like
            this:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
java.naming.factory.initial=org.jnp.interfaces.NamingContextFactory
java.naming.provider.url=jnp://myhost:1099
java.naming.factory.url.pkgs=org.jboss.naming:org.jnp.interfaces</pre><p>Where <code class="literal">myhost</code> is the hostname or IP address of the JNDI server. 1099
            is the port used by the JNDI server and may vary depending on how you have configured
            your JNDI server.</p><p>In the default standalone configuration, JNDI server ports are configured in the file
                <code class="literal">hornetq-beans.xml</code> by setting properties on the <code class="literal">JNDIServer</code> bean:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;bean name="StandaloneServer" class="org.hornetq.jms.server.impl.StandaloneNamingServer"&gt;
   &lt;constructor&gt;
      &lt;parameter&gt;
         &lt;inject bean="HornetQServer"/&gt;
      &lt;/parameter&gt;
   &lt;/constructor&gt;
   &lt;property name="port"&gt;${jnp.port:1099}&lt;/property&gt;
   &lt;property name="bindAddress"&gt;${jnp.host:localhost}&lt;/property&gt;
   &lt;property name="rmiPort"&gt;${jnp.rmiPort:1098}&lt;/property&gt;
   &lt;property name="rmiBindAddress"&gt;${jnp.host:localhost}&lt;/property&gt;
&lt;/bean&gt;</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>If you want your JNDI server to be available to non local clients make sure you
                change its bind address to something other than <code class="literal">localhost</code>!</p></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>The JNDIServer bean must be defined <span class="emphasis"><em>only when HornetQ is running in
                    stand-alone mode</em></span>. When HornetQ is integrated to JBoss Application
                Server, JBoss AS will provide a ready-to-use JNDI server without any additional
                configuration.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1307"/>7.5. The code</h2></div></div></div><p>Here's the code for the example:</p><p>First we'll create a JNDI initial context from which to lookup our JMS objects:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">InitialContext ic = new InitialContext();</pre><p>Now we'll look up the connection factory:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">ConnectionFactory cf = (ConnectionFactory)ic.lookup("/ConnectionFactory");</pre><p>And look up the Queue:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">Queue orderQueue = (Queue)ic.lookup("/queues/OrderQueue");</pre><p>Next we create a JMS connection using the connection factory:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">Connection connection = cf.createConnection();</pre><p>And we create a non transacted JMS Session, with AUTO_ACKNOWLEDGE acknowledge
            mode:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);</pre><p>We create a MessageProducer that will send orders to the queue:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">MessageProducer producer = session.createProducer(orderQueue);</pre><p>And we create a MessageConsumer which will consume orders from the queue:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">MessageConsumer consumer = session.createConsumer(orderQueue);</pre><p>We make sure we start the connection, or delivery won't occur on it:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">connection.start();</pre><p>We create a simple TextMessage and send it:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">TextMessage message = session.createTextMessage("This is an order");
producer.send(message);</pre><p>And we consume the message:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">TextMessage receivedMessage = (TextMessage)consumer.receive();
System.out.println("Got order: " + receivedMessage.getText());</pre><p>It is as simple as that. For a wide range of working JMS examples please see the
            examples directory in the distribution.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>Please note that JMS connections, sessions, producers and consumers are
                    <span class="emphasis"><em>designed to be re-used</em></span>.</p><p>It is an anti-pattern to create new connections, sessions, producers and consumers
                for each message you produce or consume. If you do this, your application will
                perform very poorly. This is discussed further in the section on performance tuning
                    <a class="xref" href="#perf-tuning" title="Chapter 49. Performance Tuning">Chapter 49, <i>Performance Tuning</i></a>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1364"/>7.6. Directly instantiating JMS Resources without using JNDI</h2></div></div></div><p>Although it is a very common JMS usage pattern to lookup JMS <span class="emphasis"><em>Administered
                Objects</em></span> (that's JMS Queue, Topic and ConnectionFactory instances) from
            JNDI, in some cases a JNDI server is not available and you still want to use JMS, or you
            just think "Why do I need JNDI? Why can't I just instantiate these objects
            directly?"</p><p>With HornetQ you can do exactly that. HornetQ supports the direct instantiation of JMS
            Queue, Topic and ConnectionFactory instances, so you don't have to use JNDI at
            all.</p><p>For a full working example of direct instantiation please see the JMS examples in
                <a class="xref" href="#examples" title="Chapter 11. Examples">Chapter 11, <i>Examples</i></a>.</p><p>Here's our simple example, rewritten to not use JNDI at all:</p><p>We create the JMS ConnectionFactory object via the HornetQJMSClient Utility class,
            note we need to provide connection parameters and specify which transport we are using,
            for more information on connectors please see <a class="xref" href="#configuring-transports" title="Chapter 16. Configuring the Transport">Chapter 16, <i>Configuring the Transport</i></a>.</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">              
TransportConfiguration transportConfiguration = new TransportConfiguration(NettyConnectorFactory.class.getName());
ConnectionFactory cf = HornetQJMSClient.createConnectionFactoryWithoutHA(JMSFactoryType.CF,transportConfiguration);</pre><p>We also create the JMS Queue object via the HornetQJMSClient Utility class:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">Queue orderQueue = HornetQJMSClient.createQueue("OrderQueue");</pre><p>Next we create a JMS connection using the connection factory:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">Connection connection = cf.createConnection();</pre><p>And we create a non transacted JMS Session, with AUTO_ACKNOWLEDGE acknowledge
            mode:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);</pre><p>We create a MessageProducer that will send orders to the queue:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">MessageProducer producer = session.createProducer(orderQueue);</pre><p>And we create a MessageConsumer which will consume orders from the queue:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">MessageConsumer consumer = session.createConsumer(orderQueue);</pre><p>We make sure we start the connection, or delivery won't occur on it:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">connection.start();</pre><p>We create a simple TextMessage and send it:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">TextMessage message = session.createTextMessage("This is an order");
producer.send(message);</pre><p>And we consume the message:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">TextMessage receivedMessage = (TextMessage)consumer.receive();
System.out.println("Got order: " + receivedMessage.getText());</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="using-jms.clientid"/>7.7. Setting The Client ID</h2></div></div></div><p>This represents the client id for a JMS client and is needed for creating durable
            subscriptions. It is possible to configure this on the connection factory and can be set
            via the <code class="literal">client-id</code> element. Any connection created by this connection
            factory will have this set as its client id.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="using-jms.dupsokbatchsize"/>7.8. Setting The Batch Size for DUPS_OK </h2></div></div></div><p>When the JMS acknowledge mode is set to <code class="literal">DUPS_OK</code> it is possible to
            configure the consumer so that it sends acknowledgements in batches rather that one at a
            time, saving valuable bandwidth. This can be configured via the connection factory via
            the <code class="literal">dups-ok-batch-size</code> element and is set in bytes. The default is
            1024 * 1024 bytes = 1 MiB.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="using-jms.txbatchsize"/>7.9. Setting The Transaction Batch Size</h2></div></div></div><p>When receiving messages in a transaction it is possible to configure the consumer to
            send acknowledgements in batches rather than individually saving valuable bandwidth.
            This can be configured on the connection factory via the <code class="literal">transaction-batch-size</code> element and is set in bytes. The default is 1024 *
            1024.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="using-core"/>Chapter 8. Using Core</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e1472">8.1. Core Messaging Concepts</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1477">8.1.1. Message</a></span></dt><dt><span class="section"><a href="#d0e1514">8.1.2. Address</a></span></dt><dt><span class="section"><a href="#d0e1535">8.1.3. Queue</a></span></dt><dt><span class="section"><a href="#d0e1546">8.1.4. ServerLocator</a></span></dt><dt><span class="section"><a href="#d0e1572">8.1.5. ClientSessionFactory</a></span></dt><dt><span class="section"><a href="#d0e1595">8.1.6. ClientSession</a></span></dt><dt><span class="section"><a href="#d0e1615">8.1.7. ClientConsumer</a></span></dt><dt><span class="section"><a href="#d0e1626">8.1.8. ClientProducer</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1647">8.2. A simple example of using Core</a></span></dt></dl></div><p>HornetQ core is a completely JMS-agnostic messaging system with its own non-JMS API. We
        call this the <span class="emphasis"><em>core API</em></span>.</p><p>If you don't want to use JMS you can use the core API directly. The core API provides all
        the functionality of JMS but without much of the complexity. It also provides features that
        are not available using JMS.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1472"/>8.1. Core Messaging Concepts</h2></div></div></div><p>Some of the core messaging concepts are similar to JMS concepts, but core messaging
            concepts differ in some ways. In general the core messaging API is simpler than the JMS
            API, since we remove distinctions between queues, topics and subscriptions. We'll
            discuss each of the major core messaging concepts in turn, but to see the API in detail,
            please consult the Javadoc.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1477"/>8.1.1. Message</h3></div></div></div><div class="itemizedlist"><ul><li><p>A message is the unit of data which is sent between clients and
                        servers.</p></li><li><p>A message has a body which is a buffer containing convenient methods for
                        reading and writing data into it.</p></li><li><p>A message has a set of properties which are key-value pairs. Each property
                        key is a string and property values can be of type integer, long, short,
                        byte, byte[], String, double, float or boolean.</p></li><li><p>A message has an <span class="emphasis"><em>address</em></span> it is being sent to. When
                        the message arrives on the server it is routed to any queues that are bound
                        to the address - if the queues are bound with any filter, the message will
                        only be routed to that queue if the filter matches. An address may have many
                        queues bound to it or even none. There may also be entities other than
                        queues, like <span class="italic">diverts</span> bound to
                        addresses.</p></li><li><p>Messages can be either durable or non durable. Durable messages in a
                        durable queue will survive a server crash or restart. Non durable messages
                        will never survive a server crash or restart.</p></li><li><p>Messages can be specified with a priority value between 0 and 9. 0
                        represents the lowest priority and 9 represents the highest. HornetQ will
                        attempt to deliver higher priority messages before lower priority
                        ones.</p></li><li><p>Messages can be specified with an optional expiry time. HornetQ will not
                        deliver messages after its expiry time has been exceeded.</p></li><li><p>Messages also have an optional timestamp which represents the time the
                        message was sent.</p></li><li><p>HornetQ also supports the sending/consuming of very large messages - much
                        larger than can fit in available RAM at any one time.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1514"/>8.1.2. Address</h3></div></div></div><p>A server maintains a mapping between an address and a set of queues. Zero or more
                queues can be bound to a single address. Each queue can be bound with an optional
                message filter. When a message is routed, it is routed to the set of queues bound to
                the message's address. If any of the queues are bound with a filter expression, then
                the message will only be routed to the subset of bound queues which match that
                filter expression.</p><p>Other entities, such as <span class="italic">diverts</span> can also be
                bound to an address and messages will also be routed there.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>In core, there is no concept of a Topic, Topic is a JMS only term. Instead, in
                    core, we just deal with <span class="emphasis"><em>addresses</em></span> and
                        <span class="emphasis"><em>queues</em></span>.</p><p>For example, a JMS topic would be implemented by a single address to which
                    many queues are bound. Each queue represents a subscription of the topic. A JMS
                    Queue would be implemented as a single address to which one queue is bound -
                    that queue represents the JMS queue.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1535"/>8.1.3. Queue</h3></div></div></div><p>Queues can be durable, meaning the messages they contain survive a server crash or
                restart, as long as the messages in them are durable. Non durable queues do not
                survive a server restart or crash even if the messages they contain are
                durable.</p><p>Queues can also be temporary, meaning they are automatically deleted when the
                client connection is closed, if they are not explicitly deleted before that.</p><p>Queues can be bound with an optional filter expression. If a filter expression is
                supplied then the server will only route messages that match that filter expression
                to any queues bound to the address.</p><p>Many queues can be bound to a single address. A particular queue is only bound to
                a maximum of one address.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1546"/>8.1.4. ServerLocator</h3></div></div></div><p>Clients use <code class="literal">ServerLocator</code> instances to create <code class="literal">ClientSessionFactory</code> instances. <code class="literal">ServerLocator</code>
                instances are used to locate servers and create connections to them. </p><p>In JMS terms think of a <code class="literal">ServerLocator</code> in the same way you would
                a JMS Connection Factory.</p><p><code class="literal">ServerLocator</code> instances are created using the <code class="literal">HornetQClient</code> factory class.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1572"/>8.1.5. ClientSessionFactory</h3></div></div></div><p>Clients use <code class="literal">ClientSessionFactory</code> instances to create <code class="literal">ClientSession</code> instances. <code class="literal">ClientSessionFactory</code>
                instances are basically the connection to a server</p><p> In JMS terms think of them as JMS Connections.</p><p><code class="literal">ClientSessionFactory</code> instances are created using the <code class="literal">ServerLocator</code> class.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1595"/>8.1.6. ClientSession</h3></div></div></div><p>A client uses a ClientSession for consuming and producing messages and for
                grouping them in transactions. ClientSession instances can support both
                transactional and non transactional semantics and also provide an <code class="literal">XAResource</code> interface so messaging operations can be performed as part
                of a <a class="ulink" href="http://www.oracle.com/technetwork/java/javaee/tech/jta-138684.html">JTA</a>
                transaction.</p><p>ClientSession instances group ClientConsumers and ClientProducers.</p><p>ClientSession instances can be registered with an optional <code class="literal">SendAcknowledgementHandler</code>. This allows your client code to be
                notified asynchronously when sent messages have successfully reached the server.
                This unique HornetQ feature, allows you to have full guarantees that sent messages
                have reached the server without having to block on each message sent until a
                response is received. Blocking on each messages sent is costly since it requires a
                network round trip for each message sent. By not blocking and receiving send
                acknowledgements asynchronously you can create true end to end asynchronous systems
                which is not possible using the standard JMS API. For more information on this
                advanced feature please see the section <a class="xref" href="#send-guarantees" title="Chapter 20. Guarantees of sends and commits">Chapter 20, <i>Guarantees of sends and commits</i></a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1615"/>8.1.7. ClientConsumer</h3></div></div></div><p>Clients use <code class="literal">ClientConsumer</code> instances to consume messages from a
                queue. Core Messaging supports both synchronous and asynchronous message consumption
                semantics. <code class="literal">ClientConsumer</code> instances can be configured with an
                optional filter expression and will only consume messages which match that
                expression.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1626"/>8.1.8. ClientProducer</h3></div></div></div><p>Clients create <code class="literal">ClientProducer</code> instances on <code class="literal">ClientSession</code> instances so they can send messages. ClientProducer
                instances can specify an address to which all sent messages are routed, or they can
                have no specified address, and the address is specified at send time for the
                message.</p></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>Please note that ClientSession, ClientProducer and ClientConsumer instances are
                    <span class="emphasis"><em>designed to be re-used</em></span>.</p><p>It's an anti-pattern to create new ClientSession, ClientProducer and
                ClientConsumer instances for each message you produce or consume. If you do this,
                your application will perform very poorly. This is discussed further in the section
                on performance tuning <a class="xref" href="#perf-tuning" title="Chapter 49. Performance Tuning">Chapter 49, <i>Performance Tuning</i></a>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1647"/>8.2. A simple example of using Core</h2></div></div></div><p>Here's a very simple program using the core messaging API to send and receive a
            message:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
ServerLocator locator = HornetQClient.createServerLocatorWithoutHA(new TransportConfiguration(
                                           InVMConnectorFactory.class.getName()));

ClientSessionFactory factory =  locator.createClientSessionFactory();

ClientSession session = factory.createSession();

session.createQueue("example", "example", true);

ClientProducer producer = session.createProducer("example");

ClientMessage message = session.createMessage(true);

message.getBodyBuffer().writeString("Hello");

producer.send(message);

session.start();

ClientConsumer consumer = session.createConsumer("example");

ClientMessage msgReceived = consumer.receive();

System.out.println("message = " + msgReceived.getBodyBuffer().readString());

session.close();</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="jms-core-mapping"/>Chapter 9. Mapping JMS Concepts to the Core API</h2></div></div></div><p>This chapter describes how JMS destinations are mapped to HornetQ addresses.</p><p>HornetQ core is JMS-agnostic. It does not have any concept of a JMS topic. A JMS topic is
        implemented in core as an address (the topic name) with zero or more queues bound to it.
        Each queue bound to that address represents a topic subscription. Likewise, a JMS queue is
        implemented as an address (the JMS queue name) with one single queue bound to it which
        represents the JMS queue.</p><p>By convention, all JMS queues map to core queues where the core queue name has the string
            <code class="literal">jms.queue.</code> prepended to it. E.g. the JMS queue with the name
        "orders.europe" would map to the core queue with the name "jms.queue.orders.europe". The
        address at which the core queue is bound is also given by the core queue name.</p><p>For JMS topics the address at which the queues that represent the subscriptions are bound
        is given by prepending the string "jms.topic." to the name of the JMS topic. E.g. the JMS
        topic with name "news.europe" would map to the core address "jms.topic.news.europe"</p><p>In other words if you send a JMS message to a JMS queue with name "orders.europe" it will
        get routed on the server to any core queues bound to the address "jms.queue.orders.europe".
        If you send a JMS message to a JMS topic with name "news.europe" it will get routed on the
        server to any core queues bound to the address "jms.topic.news.europe".</p><p>If you want to configure settings for a JMS Queue with the name "orders.europe", you need
        to configure the corresponding core queue "jms.queue.orders.europe":</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;!-- expired messages in JMS Queue "orders.europe" will be sent to the JMS Queue "expiry.europe" --&gt;
&lt;address-setting match="jms.queue.orders.europe"&gt;
   &lt;expiry-address&gt;jms.queue.expiry.europe&lt;/expiry-address&gt;
   ...
&lt;/address-setting&gt;</pre></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="client-classpath"/>Chapter 10. The Client Classpath</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e1725">10.1. HornetQ Core Client</a></span></dt><dt><span class="section"><a href="#d0e1739">10.2. JMS Client</a></span></dt><dt><span class="section"><a href="#d0e1758">10.3. JMS Client with JNDI</a></span></dt></dl></div><p>HornetQ requires several jars on the <span class="emphasis"><em>Client Classpath</em></span> depending on
        whether the client uses HornetQ Core API, JMS, and JNDI.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>All the jars mentioned here can be found in the <code class="literal">lib</code> directory of
            the HornetQ distribution. Be sure you only use the jars from the correct version of the
            release, you <span class="emphasis"><em>must not</em></span> mix and match versions of jars from different
            HornetQ versions. Mixing and matching different jar versions may cause subtle errors and
            failures to occur.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1725"/>10.1. HornetQ Core Client</h2></div></div></div><p>If you are using just a pure HornetQ Core client (i.e. no JMS) then you need <code class="literal">hornetq-core-client.jar</code>, <code class="literal">hornetq-commons.jar</code>, and
                <code class="literal">netty.jar</code> on your client classpath.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1739"/>10.2. JMS Client</h2></div></div></div><p>If you are using JMS on the client side, then you will also need to include <code class="literal">hornetq-jms-client.jar</code> and <code class="literal">jboss-jms-api.jar</code>.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p><code class="literal">jboss-jms-api.jar</code> just contains Java EE API interface classes
                needed for the <code class="literal">javax.jms.*</code> classes. If you already have a jar
                with these interface classes on your classpath, you will not need it.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1758"/>10.3. JMS Client with JNDI</h2></div></div></div><p>If you are looking up JMS resources from the JNDI server co-located with the HornetQ
            standalone server, you will also need the jar <code class="literal">jnp-client.jar</code> jar on
            your client classpath as well as any other jars mentioned previously.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="examples"/>Chapter 11. Examples</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e1795">11.1. JMS Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#examples.aerogear">11.1.1. JMS AeroGear</a></span></dt><dt><span class="section"><a href="#examples.applet">11.1.2. Applet</a></span></dt><dt><span class="section"><a href="#application-level-failover">11.1.3. Application-Layer Failover</a></span></dt><dt><span class="section"><a href="#examples.bridge">11.1.4. Core Bridge Example</a></span></dt><dt><span class="section"><a href="#examples.browsers">11.1.5. Browser</a></span></dt><dt><span class="section"><a href="#d0e1863">11.1.6. Client Kickoff</a></span></dt><dt><span class="section"><a href="#d0e1871">11.1.7. Client side failover listener</a></span></dt><dt><span class="section"><a href="#d0e1879">11.1.8. Client-Side Load-Balancing</a></span></dt><dt><span class="section"><a href="#examples.clustered.durable">11.1.9. Clustered Durable Subscription</a></span></dt><dt><span class="section"><a href="#examples.clustered.grouping">11.1.10. Clustered Grouping</a></span></dt><dt><span class="section"><a href="#examples.clustered.queue">11.1.11. Clustered Queue</a></span></dt><dt><span class="section"><a href="#examples.clustered.jgroups">11.1.12. Clustering with JGroups</a></span></dt><dt><span class="section"><a href="#examples.clustered.standalone">11.1.13. Clustered Standalone</a></span></dt><dt><span class="section"><a href="#examples.clustered.static.discovery">11.1.14. Clustered Static Discovery</a></span></dt><dt><span class="section"><a href="#examples.clustered.static.oneway">11.1.15. Clustered Static Cluster One Way</a></span></dt><dt><span class="section"><a href="#d0e1934">11.1.16. Clustered Topic</a></span></dt><dt><span class="section"><a href="#examples.consumer-rate-limit">11.1.17. Message Consumer Rate Limiting</a></span></dt><dt><span class="section"><a href="#examples.dead-letter">11.1.18. Dead Letter</a></span></dt><dt><span class="section"><a href="#examples.delayed-redelivery">11.1.19. Delayed Redelivery</a></span></dt><dt><span class="section"><a href="#divert-example">11.1.20. Divert</a></span></dt><dt><span class="section"><a href="#d0e1976">11.1.21. Durable Subscription</a></span></dt><dt><span class="section"><a href="#examples.embedded.jms">11.1.22. Embedded</a></span></dt><dt><span class="section"><a href="#examples.embedded.jms.simple">11.1.23. Embedded Simple</a></span></dt><dt><span class="section"><a href="#examples.expiry">11.1.24. Message Expiration</a></span></dt><dt><span class="section"><a href="#examples.hornetq-ra-rar">11.1.25. HornetQ Resource Adapter example</a></span></dt><dt><span class="section"><a href="#d0e2017">11.1.26. HTTP Transport</a></span></dt><dt><span class="section"><a href="#d0e2025">11.1.27. Instantiate JMS Objects Directly</a></span></dt><dt><span class="section"><a href="#examples.interceptor">11.1.28. Interceptor</a></span></dt><dt><span class="section"><a href="#examples.jaas">11.1.29. JAAS</a></span></dt><dt><span class="section"><a href="#examples.jms.auto-closeable">11.1.30. JMS Auto Closable</a></span></dt><dt><span class="section"><a href="#examples.jms.completion-listener">11.1.31. JMS Completion Listener</a></span></dt><dt><span class="section"><a href="#examples.jms.jms-bridge">11.1.32. JMS Bridge</a></span></dt><dt><span class="section"><a href="#examples.jms.jms-context">11.1.33. JMS Context</a></span></dt><dt><span class="section"><a href="#examples.jms.jms-shared-consumer">11.1.34. JMS Shared Consumer</a></span></dt><dt><span class="section"><a href="#examples.jmx">11.1.35. JMX Management</a></span></dt><dt><span class="section"><a href="#examples.large-message">11.1.36. Large Message</a></span></dt><dt><span class="section"><a href="#examples.last-value-queue">11.1.37. Last-Value Queue</a></span></dt><dt><span class="section"><a href="#examples.management">11.1.38. Management</a></span></dt><dt><span class="section"><a href="#examples.management-notifications">11.1.39. Management Notification</a></span></dt><dt><span class="section"><a href="#examples.message-counters">11.1.40. Message Counter</a></span></dt><dt><span class="section"><a href="#examples.message-group">11.1.41. Message Group</a></span></dt><dt><span class="section"><a href="#examples.message-group2">11.1.42. Message Group</a></span></dt><dt><span class="section"><a href="#examples.message-priority">11.1.43. Message Priority</a></span></dt><dt><span class="section"><a href="#examples.multiple.failover">11.1.44. Multiple Failover</a></span></dt><dt><span class="section"><a href="#examples.multiple.failover.failback">11.1.45. Multiple Failover Failback</a></span></dt><dt><span class="section"><a href="#examples.no-consumer-buffering">11.1.46. No Consumer Buffering</a></span></dt><dt><span class="section"><a href="#examples.non-transaction-failover">11.1.47. Non-Transaction Failover With Server Data Replication</a></span></dt><dt><span class="section"><a href="#examples.paging">11.1.48. Paging</a></span></dt><dt><span class="section"><a href="#examples.pre-acknowledge">11.1.49. Pre-Acknowledge</a></span></dt><dt><span class="section"><a href="#producer-rate-limiting-example">11.1.50. Message Producer Rate Limiting</a></span></dt><dt><span class="section"><a href="#examples.proton-qpid">11.1.51. Proton Qpid</a></span></dt><dt><span class="section"><a href="#examples.proton-ruby">11.1.52. Proton Ruby</a></span></dt><dt><span class="section"><a href="#examples.queue">11.1.53. Queue</a></span></dt><dt><span class="section"><a href="#examples.message-redistribution">11.1.54. Message Redistribution</a></span></dt><dt><span class="section"><a href="#examples.queue-requestor">11.1.55. Queue Requestor</a></span></dt><dt><span class="section"><a href="#examples.queue-message-selector">11.1.56. Queue with Message Selector</a></span></dt><dt><span class="section"><a href="#examples.reattach-node">11.1.57. Reattach Node example</a></span></dt><dt><span class="section"><a href="#examples.replicated-failback">11.1.58. Replicated Failback example</a></span></dt><dt><span class="section"><a href="#examples.replicated-failback-static">11.1.59. Replicated Failback static example</a></span></dt><dt><span class="section"><a href="#examples.replicated-multiple-failover">11.1.60. Replicated multiple failover example</a></span></dt><dt><span class="section"><a href="#examples.replicated-failover-transaction">11.1.61. Replicated Failover transaction example</a></span></dt><dt><span class="section"><a href="#examples.request-reply">11.1.62. Request-Reply example</a></span></dt><dt><span class="section"><a href="#examples.rest">11.1.63. Rest example</a></span></dt><dt><span class="section"><a href="#examples.scheduled-message">11.1.64. Scheduled Message</a></span></dt><dt><span class="section"><a href="#examples.security">11.1.65. Security</a></span></dt><dt><span class="section"><a href="#asynchronous-send-acknowledgements-example">11.1.66. Send Acknowledgements</a></span></dt><dt><span class="section"><a href="#examples.jms.spring.integration">11.1.67. Spring Integration</a></span></dt><dt><span class="section"><a href="#examples.ssl-transport">11.1.68. SSL Transport</a></span></dt><dt><span class="section"><a href="#examples.static-message-selector">11.1.69. Static Message Selector</a></span></dt><dt><span class="section"><a href="#examples.static-message-selector-jms">11.1.70. Static Message Selector Using JMS</a></span></dt><dt><span class="section"><a href="#examples.stomp">11.1.71. Stomp</a></span></dt><dt><span class="section"><a href="#examples.stomp1.1">11.1.72. Stomp1.1</a></span></dt><dt><span class="section"><a href="#examples.stomp1.2">11.1.73. Stomp1.2</a></span></dt><dt><span class="section"><a href="#examples.stomp-web-socket">11.1.74. Stomp Over Web Sockets</a></span></dt><dt><span class="section"><a href="#examples.symmetric-cluster">11.1.75. Symmetric Cluster</a></span></dt><dt><span class="section"><a href="#examples.temporary-queue">11.1.76. Temporary Queue</a></span></dt><dt><span class="section"><a href="#examples.topic">11.1.77. Topic</a></span></dt><dt><span class="section"><a href="#topic-hierarchy-example">11.1.78. Topic Hierarchy</a></span></dt><dt><span class="section"><a href="#examples.topic-selector-1">11.1.79. Topic Selector 1</a></span></dt><dt><span class="section"><a href="#examples.topic-selector-2">11.1.80. Topic Selector 2</a></span></dt><dt><span class="section"><a href="#examples.transaction-failover">11.1.81. Transaction Failover</a></span></dt><dt><span class="section"><a href="#examples.no-transaction-failover">11.1.82. Failover Without Transactions</a></span></dt><dt><span class="section"><a href="#examples.transactional-session">11.1.83. Transactional Session</a></span></dt><dt><span class="section"><a href="#d0e2492">11.1.84. XA Heuristic</a></span></dt><dt><span class="section"><a href="#d0e2500">11.1.85. XA Receive</a></span></dt><dt><span class="section"><a href="#d0e2508">11.1.86. XA Send</a></span></dt><dt><span class="section"><a href="#d0e2516">11.1.87. XA with Transaction Manager</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2524">11.2. Core API Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#examples.embedded">11.2.1. Embedded</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2542">11.3. Java EE Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2550">11.3.1. EJB/JMS Transaction</a></span></dt><dt><span class="section"><a href="#d0e2555">11.3.2. Resource Adapter Configuration</a></span></dt><dt><span class="section"><a href="#d0e2560">11.3.3. Resource Adapter Remote Server Configuration</a></span></dt><dt><span class="section"><a href="#examples.javaee.jms-bridge">11.3.4. JMS Bridge</a></span></dt><dt><span class="section"><a href="#d0e2570">11.3.5. MDB (Message Driven Bean)</a></span></dt><dt><span class="section"><a href="#d0e2575">11.3.6. Servlet Transport</a></span></dt><dt><span class="section"><a href="#d0e2580">11.3.7. Servlet SSL Transport</a></span></dt><dt><span class="section"><a href="#xa-recovery-example">11.3.8. XA Recovery</a></span></dt></dl></dd></dl></div><p>The HornetQ distribution comes with over 70 run out-of-the-box examples demonstrating many
        of the features.</p><p>The examples are available in the distribution, in the <code class="literal">examples</code>
        directory. Examples are split into JMS and core examples. JMS examples show how a particular
        feature can be used by a normal JMS client. Core examples show how the equivalent feature
        can be used by a core messaging client.</p><p>A set of Java EE examples are also provided which need the JBoss Application Server
        installed to be able to run.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1795"/>11.1. JMS Examples</h2></div></div></div><p>To run a JMS example, simply <code class="literal">cd</code> into the appropriate example
            directory and type <code class="literal">mvn verify</code> (For details please read the readme.html
            in each example directory).</p><p>Here's a listing of the examples with a brief description.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.aerogear"/>11.1.1. JMS AeroGear</h3></div></div></div><p>This example shows how you can send a message to a mobile device by leveraging 
            AeroGears push technology which provides support for different push notification technologies
            like Google Cloud Messaging, Apple's APNs or Mozilla's SimplePush.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.applet"/>11.1.2. Applet</h3></div></div></div><p>This example shows you how to send and receive JMS messages from an Applet.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="application-level-failover"/>11.1.3. Application-Layer Failover</h3></div></div></div><p>HornetQ also supports Application-Layer failover, useful in the case that
                replication is not enabled on the server side.</p><p>With Application-Layer failover, it's up to the application to register a JMS
                    <code class="literal">ExceptionListener</code> with HornetQ which will be called by
                HornetQ in the event that connection failure is detected.</p><p>The code in the <code class="literal">ExceptionListener</code> then recreates the JMS
                connection, session, etc on another node and the application can continue.</p><p>Application-layer failover is an alternative approach to High Availability (HA).
                Application-layer failover differs from automatic failover in that some client side
                coding is required in order to implement this. Also, with Application-layer
                failover, since the old session object dies and a new one is created, any
                uncommitted work in the old session will be lost, and any unacknowledged messages
                might be redelivered.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.bridge"/>11.1.4. Core Bridge Example</h3></div></div></div><p>The <code class="literal">bridge</code> example demonstrates a core bridge deployed on one
                server, which consumes messages from a local queue and forwards them to an address
                on a second server.</p><p>Core bridges are used to create message flows between any two HornetQ servers
                which are remotely separated. Core bridges are resilient and will cope with
                temporary connection failure allowing them to be an ideal choice for forwarding over
                unreliable connections, e.g. a WAN.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.browsers"/>11.1.5. Browser</h3></div></div></div><p>The <code class="literal">browser</code> example shows you how to use a JMS <code class="literal">QueueBrowser</code> with HornetQ.</p><p>Queues are a standard part of JMS, please consult the JMS 1.1 specification for
                full details.</p><p> A <code class="literal">QueueBrowser</code> is used to look at messages on the queue
                without removing them. It can scan the entire content of a queue or only messages
                matching a message selector.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1863"/>11.1.6. Client Kickoff</h3></div></div></div><p>The <code class="literal">client-kickoff</code> example shows how to terminate client
                connections given an IP address using the JMX management API.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1871"/>11.1.7. Client side failover listener</h3></div></div></div><p>The <code class="literal">client-side-failoverlistener</code> example shows how to register a listener to monitor
            failover events</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1879"/>11.1.8. Client-Side Load-Balancing</h3></div></div></div><p>The <code class="literal">client-side-load-balancing</code> example demonstrates how
                sessions created from a single JMS <code class="literal">Connection</code> can
                be created to different nodes of the cluster. In other words it demonstrates how
                HornetQ does client-side load-balancing of sessions across the cluster.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.clustered.durable"/>11.1.9. Clustered Durable Subscription</h3></div></div></div><p>This example demonstrates a clustered JMS durable subscription</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.clustered.grouping"/>11.1.10. Clustered Grouping</h3></div></div></div><p>This is similar to the message grouping example except that it demonstrates it
                working over a cluster. Messages sent to different nodes with the same group id will
                be sent to the same node and the same consumer.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.clustered.queue"/>11.1.11. Clustered Queue</h3></div></div></div><p>The <code class="literal">clustered-queue</code> example demonstrates a JMS queue deployed
                on two different nodes. The two nodes are configured to form a cluster. We then
                create a consumer for the queue on each node, and we create a producer on only one
                of the nodes. We then send some messages via the producer, and we verify that both
                consumers receive the sent messages in a round-robin fashion.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.clustered.jgroups"/>11.1.12. Clustering with JGroups</h3></div></div></div><p>The <code class="literal">clustered-jgroups</code> example demonstrates how to form a two
                node cluster using JGroups as its underlying topology discovery technique, rather than
                the default UDP broadcasting. We then create a consumer for the queue on each node, 
                and we create a producer on only one of the nodes. We then send some messages via the
                producer, and we verify that both consumers receive the sent messages in a round-robin fashion.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.clustered.standalone"/>11.1.13. Clustered Standalone</h3></div></div></div><p>The <code class="literal">clustered-standalone</code> example demonstrates how to configure
                and starts 3 cluster nodes on the same machine to form a cluster. A subscriber for a
                JMS topic is created on each node, and we create a producer on only one of the
                nodes. We then send some messages via the producer, and we verify that the 3
                subscribers receive all the sent messages.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.clustered.static.discovery"/>11.1.14. Clustered Static Discovery</h3></div></div></div><p>This example demonstrates how to configure a cluster using a list of connectors rather
               than UDP for discovery</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.clustered.static.oneway"/>11.1.15. Clustered Static Cluster One Way</h3></div></div></div><p>This example demonstrates how to set up a cluster where cluster connections are one way,
            i.e. server A -&gt; Server B -&gt; Server C</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1934"/>11.1.16. Clustered Topic</h3></div></div></div><p>The <code class="literal">clustered-topic</code> example demonstrates a JMS topic deployed
                on two different nodes. The two nodes are configured to form a cluster. We then
                create a subscriber on the topic on each node, and we create a producer on only one
                of the nodes. We then send some messages via the producer, and we verify that both
                subscribers receive all the sent messages.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.consumer-rate-limit"/>11.1.17. Message Consumer Rate Limiting</h3></div></div></div><p>With HornetQ you can specify a maximum consume rate at which a JMS MessageConsumer
                will consume messages. This can be specified when creating or deploying the
                connection factory.</p><p>If this value is specified then HornetQ will ensure that messages are never
                consumed at a rate higher than the specified rate. This is a form of consumer
                throttling.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.dead-letter"/>11.1.18. Dead Letter</h3></div></div></div><p>The <code class="literal">dead-letter</code> example shows you how to define and deal with
                dead letter messages. Messages can be delivered unsuccessfully (e.g. if the
                transacted session used to consume them is rolled back). </p><p>Such a message goes back to the JMS destination ready to be redelivered. However,
                this means it is possible for a message to be delivered again and again without any
                success and remain in the destination, clogging the system.</p><p>To prevent this, messaging systems define dead letter messages: after a specified
                unsuccessful delivery attempts, the message is removed from the destination and put
                instead in a dead letter destination where they can be consumed for further
                investigation.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.delayed-redelivery"/>11.1.19. Delayed Redelivery</h3></div></div></div><p>The <code class="literal">delayed-redelivery</code> example demonstrates how HornetQ can be
                configured to provide a delayed redelivery in the case a message needs to be
                redelivered.</p><p>Delaying redelivery can often be useful in the case that clients regularly fail or
                roll-back. Without a delayed redelivery, the system can get into a "thrashing"
                state, with delivery being attempted, the client rolling back, and delivery being
                re-attempted in quick succession, using up valuable CPU and network
                resources.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="divert-example"/>11.1.20. Divert</h3></div></div></div><p>HornetQ diverts allow messages to be transparently "diverted" or copied from one
                address to another with just some simple configuration defined on the server
                side.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1976"/>11.1.21. Durable Subscription</h3></div></div></div><p>The <code class="literal">durable-subscription</code> example shows you how to use a durable
                subscription with HornetQ. Durable subscriptions are a standard part of JMS, please
                consult the JMS 1.1 specification for full details.</p><p>Unlike non-durable subscriptions, the key function of durable subscriptions is
                that the messages contained in them persist longer than the lifetime of the
                subscriber - i.e. they will accumulate messages sent to the topic even if there is
                no active subscriber on them. They will also survive server restarts or crashes.
                Note that for the messages to be persisted, the messages sent to them must be marked
                as durable messages. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.embedded.jms"/>11.1.22. Embedded</h3></div></div></div><p>The <code class="literal">embedded</code> example shows how to embed JMS
                within your own code using POJO instantiation and no config files.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.embedded.jms.simple"/>11.1.23. Embedded Simple</h3></div></div></div><p>The <code class="literal">embedded</code> example shows how to embed JMS within your own code using regular HornetQ XML files.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.expiry"/>11.1.24. Message Expiration</h3></div></div></div><p>The <code class="literal">expiry</code> example shows you how to define and deal with
                message expiration. Messages can be retained in the messaging system for a limited
                period of time before being removed. JMS specification states that clients should
                not receive messages that have been expired (but it does not guarantee this will not
                happen).</p><p>HornetQ can assign an expiry address to a given queue so that when messages
                are expired, they are removed from the queue and sent to the expiry address.
                These "expired" messages can later be consumed from the expiry address for
                further inspection.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.hornetq-ra-rar"/>11.1.25. HornetQ Resource Adapter example</h3></div></div></div><p>This examples shows how to build the hornetq resource adapters a rar for deployment in other Application
            Server's</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2017"/>11.1.26. HTTP Transport</h3></div></div></div><p>The <code class="literal">http-transport</code> example shows you how to configure HornetQ
                to use the HTTP protocol as its transport layer.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2025"/>11.1.27. Instantiate JMS Objects Directly</h3></div></div></div><p>Usually, JMS Objects such as <code class="literal">ConnectionFactory</code>, <code class="literal">Queue</code> and <code class="literal">Topic</code> instances are looked up from JNDI
                before being used by the client code. This objects are called "administered objects"
                in JMS terminology.</p><p>However, in some cases a JNDI server may not be available or desired. To come to
                the rescue HornetQ also supports the direct instantiation of these administered
                objects on the client side so you don't have to use JNDI for JMS.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.interceptor"/>11.1.28. Interceptor</h3></div></div></div><p>HornetQ allows an application to use an interceptor to hook into the messaging
                system. Interceptors allow you to handle various message events in HornetQ.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.jaas"/>11.1.29. JAAS</h3></div></div></div><p>The <code class="literal">jaas</code> example shows you how to configure HornetQ to use JAAS
                for security. HornetQ can leverage JAAS to delegate user authentication and
                authorization to existing security infrastructure.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.jms.auto-closeable"/>11.1.30. JMS Auto Closable</h3></div></div></div><p>The <code class="literal">jms-auto-closeable</code> example shows how JMS resources, such
            as connections, sessions and consumers, in JMS 2 can be automatically closed on error.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.jms.completion-listener"/>11.1.31. JMS Completion Listener</h3></div></div></div><p>The <code class="literal">jms-completion-listener</code> example shows how to send a message
            asynchronously to HornetQ and use a CompletionListener to be notified of the Broker
            receiving it.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.jms.jms-bridge"/>11.1.32. JMS Bridge</h3></div></div></div><p>The <code class="literal">jms-brige</code> example shows how to setup a bridge
            between two standalone HornetQ servers.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.jms.jms-context"/>11.1.33. JMS Context</h3></div></div></div><p>The <code class="literal">jms-context</code> example shows how to send and receive a message
            to a JMS Queue using HornetQ by using a JMS Context.</p><p>A JMSContext is part of JMS 2.0 and combines the JMS Connection and Session Objects
            into a simple Interface.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.jms.jms-shared-consumer"/>11.1.34. JMS Shared Consumer</h3></div></div></div><p>The <code class="literal">jms-shared-consumer</code> example shows you how can use shared
            consumers to share a subscription on a topic. In JMS 1.1 this was not allowed and so caused
            a scalability issue. In JMS 2 this restriction has been lifted so you can share the load
            across different threads and connections.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.jmx"/>11.1.35. JMX Management</h3></div></div></div><p>The <code class="literal">jmx</code> example shows how to manage HornetQ using JMX.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.large-message"/>11.1.36. Large Message</h3></div></div></div><p>The <code class="literal">large-message</code> example shows you how to send and receive
                very large messages with HornetQ. HornetQ supports the sending and receiving of huge
                messages, much larger than can fit in available RAM on the client or server.
                Effectively the only limit to message size is the amount of disk space you have on
                the server.</p><p>Large messages are persisted on the server so they can survive a server restart.
                In other words HornetQ doesn't just do a simple socket stream from the sender to the
                consumer.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.last-value-queue"/>11.1.37. Last-Value Queue</h3></div></div></div><p>The <code class="literal">last-value-queue</code> example shows you how to define and deal
                with last-value queues. Last-value queues are special queues which discard any
                messages when a newer message with the same value for a well-defined last-value
                property is put in the queue. In other words, a last-value queue only retains the
                last value.</p><p>A typical example for last-value queue is for stock prices, where you are only
                interested by the latest price for a particular stock.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.management"/>11.1.38. Management</h3></div></div></div><p>The <code class="literal">management</code> example shows how to manage HornetQ using JMS
                Messages to invoke management operations on the server.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.management-notifications"/>11.1.39. Management Notification</h3></div></div></div><p>The <code class="literal">management-notification</code> example shows how to receive
                management notifications from HornetQ using JMS messages. HornetQ servers emit
                management notifications when events of interest occur (consumers are created or
                closed, addresses are created or deleted, security authentication fails,
                etc.).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.message-counters"/>11.1.40. Message Counter</h3></div></div></div><p>The <code class="literal">message-counters</code> example shows you how to use message
                counters to obtain message information for a JMS queue.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.message-group"/>11.1.41. Message Group</h3></div></div></div><p>The <code class="literal">message-group</code> example shows you how to configure and use
                message groups with HornetQ. Message groups allow you to pin messages so they are
                only consumed by a single consumer. Message groups are sets of messages that has the
                following characteristics:</p><p>
                </p><div class="itemizedlist"><ul><li><p>Messages in a message group share the same group id, i.e. they have
                            same JMSXGroupID string property values</p></li><li><p>The consumer that receives the first message of a group will receive
                            all the messages that belongs to the group</p></li></ul></div><p>
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.message-group2"/>11.1.42. Message Group</h3></div></div></div><p>The <code class="literal">message-group2</code> example shows you how to configure and use
                message groups with HornetQ via a connection factory.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.message-priority"/>11.1.43. Message Priority</h3></div></div></div><p>Message Priority can be used to influence the delivery order for messages.</p><p>It can be retrieved by the message's standard header field 'JMSPriority' as
                defined in JMS specification version 1.1. </p><p>The value is of type integer, ranging from 0 (the lowest) to 9 (the highest). When
                messages are being delivered, their priorities will effect their order of delivery.
                Messages of higher priorities will likely be delivered before those of lower
                priorities. </p><p>Messages of equal priorities are delivered in the natural order of their arrival
                at their destinations. Please consult the JMS 1.1 specification for full
                details.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.multiple.failover"/>11.1.44. Multiple Failover</h3></div></div></div><p>This example demonstrates how to set up a live server with multiple backups</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.multiple.failover.failback"/>11.1.45. Multiple Failover Failback</h3></div></div></div><p>This example demonstrates how to set up a live server with multiple backups but
               forcing failover back to the original live server</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.no-consumer-buffering"/>11.1.46. No Consumer Buffering</h3></div></div></div><p>By default, HornetQ consumers buffer messages from the server in a client side
                buffer before you actually receive them on the client side. This improves
                performance since otherwise every time you called receive() or had processed the
                last message in a <code class="literal">MessageListener onMessage()</code> method, the HornetQ
                client would have to go the server to request the next message, which would then get
                sent to the client side, if one was available.</p><p>This would involve a network round trip for every message and reduce performance.
                Therefore, by default, HornetQ pre-fetches messages into a buffer on each
                consumer.</p><p>In some case buffering is not desirable, and HornetQ allows it to be switched off.
                This example demonstrates that.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.non-transaction-failover"/>11.1.47. Non-Transaction Failover With Server Data Replication</h3></div></div></div><p>The <code class="literal">non-transaction-failover</code> example demonstrates two servers coupled
                as a live-backup pair for high availability (HA), and a client using a <span class="emphasis"><em>non-transacted
                </em></span> JMS session failing over from live to backup when the live server is
                crashed.</p><p>HornetQ implements failover of client connections between
                live and backup servers. This is implemented by the replication of state between
                live and backup nodes. When replication is configured and a live node crashes, the
                client connections can carry and continue to send and consume messages. When non-transacted
                 sessions are used, once and only once message delivery is not guaranteed and it is possible
                 that some messages will be lost or delivered twice.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.paging"/>11.1.48. Paging</h3></div></div></div><p>The <code class="literal">paging</code> example shows how HornetQ can support huge queues
                even when the server is running in limited RAM. It does this by transparently
                    <span class="emphasis"><em>paging</em></span> messages to disk, and <span class="emphasis"><em>depaging</em></span>
                them when they are required.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.pre-acknowledge"/>11.1.49. Pre-Acknowledge</h3></div></div></div><p>Standard JMS supports three acknowledgement modes:<code class="literal">
                    AUTO_ACKNOWLEDGE</code>, <code class="literal">CLIENT_ACKNOWLEDGE</code>, and <code class="literal">DUPS_OK_ACKNOWLEDGE</code>. For a full description on these modes please
                consult the JMS specification, or any JMS tutorial.</p><p>All of these standard modes involve sending acknowledgements from the client to
                the server. However in some cases, you really don't mind losing messages in event of
                failure, so it would make sense to acknowledge the message on the server before
                delivering it to the client. This example demonstrates how HornetQ allows this with
                an extra acknowledgement mode.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="producer-rate-limiting-example"/>11.1.50. Message Producer Rate Limiting</h3></div></div></div><p>The <code class="literal">producer-rte-limit</code> example demonstrates how, with HornetQ,
                you can specify a maximum send rate at which a JMS message producer will send
                messages.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.proton-qpid"/>11.1.51. Proton Qpid</h3></div></div></div><p>HornetQ can be configured to accept requests from any AMQP client that supports the
            1.0 version of the protocol. This <code class="literal">proton-j</code> example shows a simply 
            qpid java 1.0 client example.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.proton-ruby"/>11.1.52. Proton Ruby</h3></div></div></div><p>HornetQ can be configured to accept requests from any AMQP client that supports the
            1.0 version of the protocol. This example shows a simply proton ruby client
            that sends and receives messages</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.queue"/>11.1.53. Queue</h3></div></div></div><p>A simple example demonstrating a JMS queue.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.message-redistribution"/>11.1.54. Message Redistribution</h3></div></div></div><p>The <code class="literal">queue-message-redistribution</code> example demonstrates message
                redistribution between queues with the same name deployed in different nodes of a
                cluster.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.queue-requestor"/>11.1.55. Queue Requestor</h3></div></div></div><p>A simple example demonstrating a JMS queue requestor.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.queue-message-selector"/>11.1.56. Queue with Message Selector</h3></div></div></div><p>The <code class="literal">queue-selector</code> example shows you how to selectively consume
                messages using message selectors with queue consumers.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.reattach-node"/>11.1.57. Reattach Node example</h3></div></div></div><p>The <code class="literal">Reattach Node</code> example shows how a client can try to reconnect to
               the same server instead of failing the connection immediately and
               notifying any user ExceptionListener objects. HornetQ can be configured to automatically
               retry the connection, and reattach to the server when it becomes available again across
               the network.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.replicated-failback"/>11.1.58. Replicated Failback example</h3></div></div></div><p>An example showing how failback works when using replication, In this example a live server will replicate
               all its Journal to a backup server as it updates it. When the live server crashes the backup takes over
            from the live server and the client reconnects and carries on from where it left off.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.replicated-failback-static"/>11.1.59. Replicated Failback static example</h3></div></div></div><p>An example showing how failback works when using replication, but this time with static connectors</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.replicated-multiple-failover"/>11.1.60. Replicated multiple failover example</h3></div></div></div><p>An example showing how to configure multiple backups when using replication</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.replicated-failover-transaction"/>11.1.61. Replicated Failover transaction example</h3></div></div></div><p>An example showing how failover works with a transaction when using replication</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.request-reply"/>11.1.62. Request-Reply example</h3></div></div></div><p>A simple example showing the JMS request-response pattern.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.rest"/>11.1.63. Rest example</h3></div></div></div><p>An example showing how to use the HornetQ Rest API</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.scheduled-message"/>11.1.64. Scheduled Message</h3></div></div></div><p>The <code class="literal">scheduled-message</code> example shows you how to send a scheduled
                message to a JMS Queue with HornetQ. Scheduled messages won't get delivered until a
                specified time in the future.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.security"/>11.1.65. Security</h3></div></div></div><p>The <code class="literal">security</code> example shows you how configure and use role based
                queue security with HornetQ.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="asynchronous-send-acknowledgements-example"/>11.1.66. Send Acknowledgements</h3></div></div></div><p>The <code class="literal">send-acknowledgements</code> example shows you how to use
                HornetQ's advanced <span class="emphasis"><em>asynchronous send acknowledgements</em></span> feature
                to obtain acknowledgement from the server that sends have been received and
                processed in a separate stream to the sent messages. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.jms.spring.integration"/>11.1.67. Spring Integration</h3></div></div></div><p>This example shows how to use embedded JMS using HornetQ's Spring integration.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.ssl-transport"/>11.1.68. SSL Transport</h3></div></div></div><p>The <code class="literal">ssl-enabled</code> shows you how to configure SSL with HornetQ to
                send and receive message.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.static-message-selector"/>11.1.69. Static Message Selector</h3></div></div></div><p>The <code class="literal">static-selector</code> example shows you how to configure a
                HornetQ core queue with static message selectors (filters).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.static-message-selector-jms"/>11.1.70. Static Message Selector Using JMS</h3></div></div></div><p>The <code class="literal">static-selector-jms</code> example shows you how to configure a
                HornetQ queue with static message selectors (filters) using JMS.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.stomp"/>11.1.71. Stomp</h3></div></div></div><p>The <code class="literal">stomp</code> example shows you how to configure a
                HornetQ server to send and receive Stomp messages.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.stomp1.1"/>11.1.72. Stomp1.1</h3></div></div></div><p>The <code class="literal">stomp</code> example shows you how to configure a
                HornetQ server to send and receive Stomp messages via a Stomp 1.1 connection.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.stomp1.2"/>11.1.73. Stomp1.2</h3></div></div></div><p>The <code class="literal">stomp</code> example shows you how to configure a
                HornetQ server to send and receive Stomp messages via a Stomp 1.2 connection.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.stomp-web-socket"/>11.1.74. Stomp Over Web Sockets</h3></div></div></div><p>The <code class="literal">stomp-websockets</code> example shows you how to configure a
                HornetQ server to send and receive Stomp messages directly from Web browsers (provided
                they support Web Sockets).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.symmetric-cluster"/>11.1.75. Symmetric Cluster</h3></div></div></div><p>The <code class="literal">symmetric-cluster</code> example demonstrates a symmetric cluster
                set-up with HornetQ.</p><p>HornetQ has extremely flexible clustering which allows you to set-up servers in
                many different topologies. The most common topology that you'll perhaps be familiar
                with if you are used to application server clustering is a symmetric cluster.</p><p>With a symmetric cluster, the cluster is homogeneous, i.e. each node is configured
                the same as every other node, and every node is connected to every other node in the
                cluster.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.temporary-queue"/>11.1.76. Temporary Queue</h3></div></div></div><p>A simple example demonstrating how to use a JMS temporary queue.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.topic"/>11.1.77. Topic</h3></div></div></div><p>A simple example demonstrating a JMS topic.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="topic-hierarchy-example"/>11.1.78. Topic Hierarchy</h3></div></div></div><p>HornetQ supports topic hierarchies. With a topic hierarchy you can register a
                subscriber with a wild-card and that subscriber will receive any messages sent to an
                address that matches the wild card.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.topic-selector-1"/>11.1.79. Topic Selector 1</h3></div></div></div><p>The <code class="literal">topic-selector-example1</code> example shows you how to send
                message to a JMS Topic, and subscribe them using selectors with HornetQ.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.topic-selector-2"/>11.1.80. Topic Selector 2</h3></div></div></div><p>The <code class="literal">topic-selector-example2</code> example shows you how to
                selectively consume messages using message selectors with topic consumers.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.transaction-failover"/>11.1.81. Transaction Failover</h3></div></div></div><p>The <code class="literal">transaction-failover</code> example demonstrates two servers coupled
                as a live-backup pair for high availability (HA), and a client using a transacted JMS
                session failing over from live to backup when the live server is
                crashed.</p><p>HornetQ implements failover of client connections between
                live and backup servers. This is implemented by the sharing of a journal between the
               servers. When a live node crashes, the
                client connections can carry and continue to send and consume messages. When transacted
                sessions are used, once and only once message delivery is guaranteed.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.no-transaction-failover"/>11.1.82. Failover Without Transactions</h3></div></div></div><p>The <code class="literal">stop-server-failover</code> example demonstrates failover of the 
            JMS connection from one node to another when the live server crashes using a JMS 
            non-transacted session.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.transactional-session"/>11.1.83. Transactional Session</h3></div></div></div><p>The <code class="literal">transactional</code> example shows you how to use a transactional
                Session with HornetQ.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2492"/>11.1.84. XA Heuristic</h3></div></div></div><p>The <code class="literal">xa-heuristic</code> example shows you how to make an XA heuristic
                decision through HornetQ Management Interface. A heuristic decision is a unilateral
                decision to commit or rollback an XA transaction branch after it has been
                prepared.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2500"/>11.1.85. XA Receive</h3></div></div></div><p>The <code class="literal">xa-receive</code> example shows you how message receiving behaves
                in an XA transaction in HornetQ.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2508"/>11.1.86. XA Send</h3></div></div></div><p>The <code class="literal">xa-send</code> example shows you how message sending behaves in an
                XA transaction in HornetQ.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2516"/>11.1.87. XA with Transaction Manager</h3></div></div></div><p>The <code class="literal">xa-with-jta</code> example shows you how to use JTA interfaces to
                control transactions with HornetQ.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2524"/>11.2. Core API Examples</h2></div></div></div><p>To run a core example, simply <code class="literal">cd</code> into the appropriate example
            directory and type <code class="literal">ant</code></p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.embedded"/>11.2.1. Embedded</h3></div></div></div><p>The <code class="literal">embedded</code> example shows how to embed the HornetQ server
                within your own code.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2542"/>11.3. Java EE Examples</h2></div></div></div><p>Most of the Java EE examples can be run the following way. simply cd into the
            appropriate example directory and type <code class="literal">mvn test</code>. This will use Arquillian to run the Application
            Server and deploy the application. Note that you must have jboss AS 7 installed and the JBOSS_HOME environment
            variable set. Please refer to the examples documentation for further instructions.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2550"/>11.3.1. EJB/JMS Transaction</h3></div></div></div><p>An example that shows using an EJB and JMS together within a transaction.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2555"/>11.3.2. Resource Adapter Configuration</h3></div></div></div><p>This example demonstrates how to configure several properties on the HornetQ JCA
                resource adaptor.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2560"/>11.3.3. Resource Adapter Remote Server Configuration</h3></div></div></div><p>This example demonstrates how to configure the HornetQ resource adapter to talk to a remote HornetQ server</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="examples.javaee.jms-bridge"/>11.3.4. JMS Bridge</h3></div></div></div><p>An example demonstrating the use of the HornetQ JMS bridge.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2570"/>11.3.5. MDB (Message Driven Bean)</h3></div></div></div><p>A simple set of examples of message driven beans, including failover examples.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2575"/>11.3.6. Servlet Transport</h3></div></div></div><p>An example of how to use the HornetQ servlet transport.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2580"/>11.3.7. Servlet SSL Transport</h3></div></div></div><p>An example of how to use the HornetQ servlet transport over SSL.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="xa-recovery-example"/>11.3.8. XA Recovery</h3></div></div></div><p>An example of how XA recovery works within the JBoss Application server using
                HornetQ.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="wildcard-routing"/>Chapter 12. Routing Messages With Wild Cards</h2></div></div></div><p>HornetQ allows the routing of messages via wildcard addresses.</p><p>If a queue is created with an address of say <code class="literal">queue.news.#</code> then it
        will receive any messages sent to addresses that match this, for instance <code class="literal">queue.news.europe</code> or <code class="literal">queue.news.usa</code> or <code class="literal">queue.news.usa.sport</code>. If you create a consumer on this queue, this allows a consumer to consume messages which are
        sent to a <span class="emphasis"><em>hierarchy</em></span> of addresses.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>In JMS terminology this allows "topic hierarchies" to be created.</p></div><p>To enable this functionality set the property <code class="literal">wild-card-routing-enabled</code>
        in the <code class="literal">hornetq-configuration.xml</code> file to <code class="literal">true</code>. This is
            <code class="literal">true</code> by default.</p><p>For more information on the wild card syntax take a look at <a class="xref" href="#wildcard-syntax" title="Chapter 13. Understanding the HornetQ Wildcard Syntax">Chapter 13, <i>Understanding the HornetQ Wildcard Syntax</i></a> chapter, also see <a class="xref" href="#topic-hierarchy-example" title="11.1.78. Topic Hierarchy">Section 11.1.78, “Topic Hierarchy”</a>.</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="wildcard-syntax"/>Chapter 13. Understanding the HornetQ Wildcard Syntax</h2></div></div></div><p>HornetQ uses a specific syntax for representing wildcards in security settings,
        address settings and when creating consumers.</p><p>The syntax is similar to that used by <a class="ulink" href="http://www.amqp.org">AMQP</a>.</p><p>A HornetQ wildcard expression contains words delimited by the character '<code class="literal">.</code>' (full stop).</p><p>The special characters '<code class="literal">#</code>' and '<code class="literal">*</code>' also have special
        meaning and can take the place of a word.</p><p>The character '<code class="literal">#</code>' means 'match any sequence of zero or more
        words'.</p><p>The character '<code class="literal">*</code>' means 'match a single word'.</p><p>So the wildcard 'news.europe.#' would match 'news.europe', 'news.europe.sport',
        'news.europe.politics', and 'news.europe.politics.regional' but would not match 'news.usa',
        'news.usa.sport' nor 'entertainment'.</p><p>The wildcard 'news.*' would match 'news.europe', but not 'news.europe.sport'.</p><p>The wildcard 'news.*.sport' would match 'news.europe.sport' and also 'news.usa.sport', but
        not 'news.europe.politics'.</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="filter-expressions"/>Chapter 14. Filter Expressions</h2></div></div></div><p>HornetQ provides a powerful filter language based on a subset of the SQL 92
        expression syntax.</p><p>It is the same as the syntax used for JMS selectors, but the predefined identifiers are
        different. For documentation on JMS selector syntax please the JMS javadoc for <a class="ulink" href="http://docs.oracle.com/javaee/6/api/javax/jms/Message.html">javax.jms.Message</a>.</p><p>Filter expressions are used in several places in HornetQ</p><div class="itemizedlist"><ul><li><p>Predefined Queues. When pre-defining a queue, either in <code class="literal">hornetq-configuration.xml</code> or <code class="literal">hornetq-jms.xml</code> a filter
                expression can be defined for a queue. Only messages that match the filter
                expression will enter the queue.</p></li><li><p>Core bridges can be defined with an optional filter expression, only matching
                messages will be bridged (see <a class="xref" href="#core-bridges" title="Chapter 36. Core Bridges">Chapter 36, <i>Core Bridges</i></a>).</p></li><li><p>Diverts can be defined with an optional filter expression, only matching messages
                will be diverted (see <a class="xref" href="#diverts" title="Chapter 35. Diverting and Splitting Message Flows">Chapter 35, <i>Diverting and Splitting Message Flows</i></a>).</p></li><li><p>Filter are also used programmatically when creating consumers, queues and in
                several places as described in <a class="xref" href="#management" title="Chapter 30. Management">Chapter 30, <i>Management</i></a>.</p></li></ul></div><p>There are some differences between JMS selector expressions and HornetQ core
        filter expressions. Whereas JMS selector expressions operate on a JMS message, HornetQ
        core filter expressions operate on a core message.</p><p>The following identifiers can be used in a core filter expressions to refer to attributes
        of the core message in an expression:</p><div class="itemizedlist"><ul><li><p><code class="literal">HQPriority</code>. To refer to the priority of a message. Message
                priorities are integers with valid values from <code class="literal">0 - 9</code>. <code class="literal">0</code> is the lowest priority and <code class="literal">9</code> is the highest.
                E.g. <code class="literal">HQPriority = 3 AND animal = 'aardvark'</code></p></li><li><p><code class="literal">HQExpiration</code>. To refer to the expiration time of a message.
                The value is a long integer.</p></li><li><p><code class="literal">HQDurable</code>. To refer to whether a message is durable or not.
                The value is a string with valid values: <code class="literal">DURABLE</code> or <code class="literal">NON_DURABLE</code>.</p></li><li><p><code class="literal">HQTimestamp</code>. The timestamp of when the message was created.
                The value is a long integer.</p></li><li><p><code class="literal">HQSize</code>. The size of a message in bytes. The value is an
                integer.</p></li></ul></div><p>Any other identifiers used in core filter expressions will be assumed to be properties of
        the message.</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="persistence"/>Chapter 15. Persistence</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#configuring.bindings.journal">15.1. Configuring the bindings journal</a></span></dt><dt><span class="section"><a href="#configuring.bindings.jms">15.2. Configuring the jms journal</a></span></dt><dt><span class="section"><a href="#configuring.message.journal">15.3. Configuring the message journal</a></span></dt><dt><span class="section"><a href="#disk-write-cache">15.4. An important note on disabling disk write cache.</a></span></dt><dt><span class="section"><a href="#installing-aio">15.5. Installing AIO</a></span></dt><dt><span class="section"><a href="#persistence.enabled">15.6. Configuring HornetQ for Zero Persistence</a></span></dt><dt><span class="section"><a href="#persistence.importexport">15.7. Import/Export the Journal Data</a></span></dt></dl></div><p>In this chapter we will describe how persistence works with HornetQ and how to configure
        it.</p><p>HornetQ ships with a high performance journal. Since HornetQ handles its own persistence,
        rather than relying on a database or other 3rd party persistence engine it is very highly
        optimised for the specific messaging use cases.</p><p>A HornetQ journal is an <span class="emphasis"><em>append only</em></span> journal. It consists of a set of
        files on disk. Each file is pre-created to a fixed size and initially filled with padding.
        As operations are performed on the server, e.g. add message, update message, delete message,
        records are appended to the journal. When one journal file is full we move to the next
        one.</p><p>Because records are only appended, i.e. added to the end of the journal we minimise disk
        head movement, i.e. we minimise random access operations which is typically the slowest
        operation on a disk.</p><p>Making the file size configurable means that an optimal size can be chosen, i.e. making
        each file fit on a disk cylinder. Modern disk topologies are complex and we are not in
        control over which cylinder(s) the file is mapped onto so this is not an exact science. But
        by minimising the number of disk cylinders the file is using, we can minimise the amount of
        disk head movement, since an entire disk cylinder is accessible simply by the disk rotating
        - the head does not have to move.</p><p>As delete records are added to the journal, HornetQ has a sophisticated file garbage
        collection algorithm which can determine if a particular journal file is needed any more -
        i.e. has all its data been deleted in the same or other files. If so, the file can be
        reclaimed and re-used. </p><p>HornetQ also has a compaction algorithm which removes dead space from the journal and
        compresses up the data so it takes up less files on disk.</p><p>The journal also fully supports transactional operation if required, supporting both local
        and XA transactions.</p><p>The majority of the journal is written in Java, however we abstract out the interaction
        with the actual file system to allow different pluggable implementations. HornetQ ships with
        two implementations:</p><div class="itemizedlist"><ul><li><p>Java <a class="ulink" href="http://en.wikipedia.org/wiki/New_I/O">NIO</a>.</p><p>The first implementation uses standard Java NIO to interface with the file system.
                This provides extremely good performance and runs on any platform where there's a
                Java 6+ runtime.</p></li><li><p><a id="aio-journal"/>Linux Asynchronous IO</p><p>The second implementation uses a thin native code wrapper to talk to the Linux
                asynchronous IO library (AIO). With AIO, HornetQ will be called back when the data
                has made it to disk, allowing us to avoid explicit syncs altogether and simply send
                back confirmation of completion when AIO informs us that the data has been
                persisted.</p><p>Using AIO will typically provide even better performance than using Java
                NIO.</p><p>The AIO journal is only available when running Linux kernel 2.6 or later and after
                having installed libaio (if it's not already installed). For instructions on how to
                install libaio please see <a class="xref" href="#installing-aio" title="15.5. Installing AIO">Section 15.5, “Installing AIO”</a>.</p><p>Also, please note that AIO will only work with the following file systems: ext2,
                ext3, ext4, jfs, xfs. With other file systems, e.g. NFS it may appear to work, but
                it will fall back to a slower synchronous behaviour. Don't put the journal on a NFS
                share!</p><p>For more information on libaio please see <a class="xref" href="#libaio" title="Chapter 40. Libaio Native Libraries">Chapter 40, <i>Libaio Native Libraries</i></a>.</p><p>libaio is part of the kernel project.</p></li></ul></div><p>The standard HornetQ core server uses two instances of the journal:</p><div class="itemizedlist"><a id="persistence.journallist"/><ul><li><p>Bindings journal.</p><p>This journal is used to store bindings related data. That includes the set of
                queues that are deployed on the server and their attributes. It also stores data
                such as id sequence counters. </p><p>The bindings journal is always a NIO journal as it is typically low throughput
                compared to the message journal.</p><p>The files on this journal are prefixed as <code class="literal">hornetq-bindings</code>.
                Each file has a <code class="literal">bindings</code> extension. File size is <code class="literal">1048576</code>, and it is located at the bindings folder.</p></li><li><p>JMS journal.</p><p>This journal instance stores all JMS related data, This is basically any JMS
                Queues, Topics and Connection Factories and any JNDI bindings for these
                resources.</p><p>Any JMS Resources created via the management API will be persisted to this
                journal. Any resources configured via configuration files will not. The JMS Journal
                will only be created if JMS is being used.</p><p>The files on this journal are prefixed as <code class="literal">hornetq-jms</code>. Each
                file has a <code class="literal">jms</code> extension. File size is <code class="literal">1048576</code>, and it is located at the bindings folder.</p></li><li><p>Message journal.</p><p>This journal instance stores all message related data, including the message
                themselves and also duplicate-id caches.</p><p>By default HornetQ will try and use an AIO journal. If AIO is not available, e.g.
                the platform is not Linux with the correct kernel version or AIO has not been
                installed then it will automatically fall back to using Java NIO which is available
                on any Java platform.</p><p>The files on this journal are prefixed as <code class="literal">hornetq-data</code>. Each
                file has a <code class="literal">hq</code> extension. File size is by the default <code class="literal">10485760</code> (configurable), and it is located at the journal
                folder.</p></li></ul></div><p>For large messages, HornetQ persists them outside the message journal. This is discussed
        in <a class="xref" href="#large-messages" title="Chapter 23. Large Messages">Chapter 23, <i>Large Messages</i></a>.</p><p>HornetQ can also be configured to page messages to disk in low memory situations. This is
        discussed in <a class="xref" href="#paging" title="Chapter 24. Paging">Chapter 24, <i>Paging</i></a>.</p><p>If no persistence is required at all, HornetQ can also be configured not to persist any
        data at all to storage as discussed in <a class="xref" href="#persistence.enabled" title="15.6. Configuring HornetQ for Zero Persistence">Section 15.6, “Configuring HornetQ for Zero Persistence”</a>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="configuring.bindings.journal"/>15.1. Configuring the bindings journal</h2></div></div></div><p>The bindings journal is configured using the following attributes in <code class="literal">hornetq-configuration.xml</code></p><div class="itemizedlist"><ul><li><p><code class="literal">bindings-directory</code></p><p>This is the directory in which the bindings journal lives. The default value
                    is <code class="literal">data/bindings</code>.</p></li><li><p><code class="literal">create-bindings-dir</code></p><p>If this is set to <code class="literal">true</code> then the bindings directory will be
                    automatically created at the location specified in <code class="literal">bindings-directory</code> if it does not already exist. The default
                    value is <code class="literal">true</code></p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="configuring.bindings.jms"/>15.2. Configuring the jms journal</h2></div></div></div><p>The jms config shares its configuration with the bindings journal.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="configuring.message.journal"/>15.3. Configuring the message journal</h2></div></div></div><p>The message journal is configured using the following attributes in <code class="literal">hornetq-configuration.xml</code></p><div class="itemizedlist"><ul><li><p><a id="configuring.message.journal.journal-directory"/><code class="literal">journal-directory</code></p><p>This is the directory in which the message journal lives. The default value is
                        <code class="literal">data/journal</code>.</p><p>For the best performance, we recommend the journal is located on its own
                    physical volume in order to minimise disk head movement. If the journal is on a
                    volume which is shared with other processes which might be writing other files
                    (e.g. bindings journal, database, or transaction coordinator) then the disk head
                    may well be moving rapidly between these files as it writes them, thus
                    drastically reducing performance.</p><p>When the message journal is stored on a SAN we recommend each journal instance
                    that is stored on the SAN is given its own LUN (logical unit).</p></li><li><p><a id="configuring.message.journal.create-journal-dir"/><code class="literal">create-journal-dir</code></p><p>If this is set to <code class="literal">true</code> then the journal directory will be
                    automatically created at the location specified in <code class="literal">journal-directory</code> if it does not already exist. The default value
                    is <code class="literal">true</code></p></li><li><p><a id="configuring.message.journal.journal-type"/><code class="literal">journal-type</code></p><p>Valid values are <code class="literal">NIO</code> or <code class="literal">ASYNCIO</code>.</p><p>Choosing <code class="literal">NIO</code> chooses the Java NIO journal. Choosing
                        <code class="literal">AIO</code> chooses the Linux asynchronous IO journal. If you
                    choose <code class="literal">AIO</code> but are not running Linux or you do not have
                    libaio installed then HornetQ will detect this and automatically fall back to
                    using <code class="literal">NIO</code>.</p></li><li><p><a id="configuring.message.journal.journal-sync-transactional"/><code class="literal">journal-sync-transactional</code></p><p>If this is set to true then HornetQ will make sure all transaction data is
                    flushed to disk on transaction boundaries (commit, prepare and rollback). The
                    default value is <code class="literal">true</code>.</p></li><li><p><a id="configuring.message.journal.journal-sync-non-transactional"/><code class="literal">journal-sync-non-transactional</code></p><p>If this is set to true then HornetQ will make sure non transactional message
                    data (sends and acknowledgements) are flushed to disk each time. The default
                    value for this is <code class="literal">true</code>.</p></li><li><p><a id="configuring.message.journal.journal-file-size"/><code class="literal">journal-file-size</code></p><p>The size of each journal file in bytes. The default value for this is <code class="literal">10485760</code> bytes (10MiB).</p></li><li><p><a id="configuring.message.journal.journal-min-files"/><code class="literal">journal-min-files</code></p><p>The minimum number of files the journal will maintain. When HornetQ starts and
                    there is no initial message data, HornetQ will pre-create <code class="literal">journal-min-files</code> number of files.</p><p>Creating journal files and filling them with padding is a fairly expensive
                    operation and we want to minimise doing this at run-time as files get filled. By
                    pre-creating files, as one is filled the journal can immediately resume with the
                    next one without pausing to create it.</p><p>Depending on how much data you expect your queues to contain at steady state
                    you should tune this number of files to match that total amount of data.</p></li><li><p><a id="configuring.message.journal.journal-max-io"/><code class="literal">journal-max-io</code></p><p>Write requests are queued up before being submitted to the system for
                    execution. This parameter controls the maximum number of write requests that can
                    be in the IO queue at any one time. If the queue becomes full then writes will
                    block until space is freed up. </p><p>When using NIO, this value should always be equal to <code class="literal">1</code></p><p>When using AIO, the default should be <code class="literal">500</code>.</p><p>The system maintains different defaults for this parameter depending on whether
                    it's NIO or AIO (default for NIO is 1, default for AIO is 500)</p><p>There is a limit and the total max AIO can't be higher than what is configured
                    at the OS level (/proc/sys/fs/aio-max-nr) usually at 65536.</p></li><li><p><a id="configuring.message.journal.journal-buffer-timeout"/><code class="literal">journal-buffer-timeout</code></p><p>Instead of flushing on every write that requires a flush, we maintain an
                    internal buffer, and flush the entire buffer either when it is full, or when a
                    timeout expires, whichever is sooner. This is used for both NIO and AIO and
                    allows the system to scale better with many concurrent writes that require
                    flushing.</p><p>This parameter controls the timeout at which the buffer will be flushed if it
                    hasn't filled already. AIO can typically cope with a higher flush rate than NIO,
                    so the system maintains different defaults for both NIO and AIO (default for NIO
                    is 3333333 nanoseconds - 300 times per second, default for AIO is 500000
                    nanoseconds - ie. 2000 times per second).</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>By increasing the timeout, you may be able to increase system throughput
                        at the expense of latency, the default parameters are chosen to give a
                        reasonable balance between throughput and latency.</p></div></li><li><p><a id="configuring.message.journal.journal-buffer-size"/><code class="literal">journal-buffer-size</code></p><p>The size of the timed buffer on AIO. The default value is <code class="literal">490KiB</code>.</p></li><li><p><a id="configuring.message.journal.journal-compact-min-files"/><code class="literal">journal-compact-min-files</code></p><p>The minimal number of files before we can consider compacting the journal. The
                    compacting algorithm won't start until you have at least <code class="literal">journal-compact-min-files</code></p><p>The default for this parameter is <code class="literal">10</code></p></li><li><p><a id="configuring.message.journal.journal-compact-percentage"/><code class="literal">journal-compact-percentage</code></p><p>The threshold to start compacting. When less than this percentage is
                    considered live data, we start compacting. Note also that compacting won't kick
                    in until you have at least <code class="literal">journal-compact-min-files</code> data
                    files on the journal</p><p>The default for this parameter is <code class="literal">30</code></p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="disk-write-cache"/>15.4. An important note on disabling disk write cache.</h2></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>Most disks contain hardware write caches. A write cache can increase the apparent
                performance of the disk because writes just go into the cache and are then lazily
                written to the disk later. </p><p>This happens irrespective of whether you have executed a fsync() from the
                operating system or correctly synced data from inside a Java program!</p><p>By default many systems ship with disk write cache enabled. This means that even
                after syncing from the operating system there is no guarantee the data has actually
                made it to disk, so if a failure occurs, critical data can be lost.</p><p>Some more expensive disks have non volatile or battery backed write caches which
                won't necessarily lose data on event of failure, but you need to test them!</p><p>If your disk does not have an expensive non volatile or battery backed cache and
                it's not part of some kind of redundant array (e.g. RAID), and you value your data
                integrity you need to make sure disk write cache is disabled.</p><p>Be aware that disabling disk write cache can give you a nasty shock performance
                wise. If you've been used to using disks with write cache enabled in their default
                setting, unaware that your data integrity could be compromised, then disabling it
                will give you an idea of how fast your disk can perform when acting really
                reliably.</p><p>On Linux you can inspect and/or change your disk's write cache settings using the
                tools <code class="literal">hdparm</code> (for IDE disks) or <code class="literal">sdparm</code> or
                    <code class="literal">sginfo</code> (for SDSI/SATA disks)</p><p>On Windows you can check / change the setting by right clicking on the disk and
                clicking properties.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="installing-aio"/>15.5. Installing AIO</h2></div></div></div><p>The Java NIO journal gives great performance, but If you are running HornetQ using
            Linux Kernel 2.6 or later, we highly recommend you use the <code class="literal">AIO</code>
            journal for the very best persistence performance.</p><p>It's not possible to use the AIO journal under other operating systems or earlier
            versions of the Linux kernel.</p><p>If you are running Linux kernel 2.6 or later and don't already have <code class="literal">libaio</code> installed, you can easily install it using the following
            steps:</p><p>Using yum, (e.g. on Fedora or Red Hat Enterprise Linux):
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">yum install libaio</pre><p>Using aptitude, (e.g. on Ubuntu or Debian system):
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">apt-get install libaio</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="persistence.enabled"/>15.6. Configuring HornetQ for Zero Persistence</h2></div></div></div><p>In some situations, zero persistence is sometimes required for a messaging system.
            Configuring HornetQ to perform zero persistence is straightforward. Simply set the
            parameter <code class="literal">persistence-enabled</code> in <code class="literal">hornetq-configuration.xml</code> to <code class="literal">false</code>. </p><p>Please note that if you set this parameter to false, then <span class="emphasis"><em>zero</em></span>
            persistence will occur. That means no bindings data, message data, large message data,
            duplicate id caches or paging data will be persisted.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="persistence.importexport"/>15.7. Import/Export the Journal Data</h2></div></div></div><p>You may want to inspect the existent records on each one of the journals used by
            HornetQ, and you can use the export/import tool for that purpose. The export/import are
            classes located at the hornetq-core.jar, you can export the journal as a text file by
            using this command:</p><p><code class="literal">java -cp hornetq-core.jar org.hornetq.core.journal.impl.ExportJournal
                &lt;JournalDirectory&gt; &lt;JournalPrefix&gt; &lt;FileExtension&gt; &lt;FileSize&gt;
                &lt;FileOutput&gt;</code></p><p>To import the file as binary data on the journal (Notice you also require
            netty.jar):</p><p><code class="literal">java -cp hornetq-core.jar:netty.jar org.hornetq.core.journal.impl.ImportJournal
                &lt;JournalDirectory&gt; &lt;JournalPrefix&gt; &lt;FileExtension&gt; &lt;FileSize&gt;
                &lt;FileInput&gt;</code></p><div class="itemizedlist"><ul><li><p>JournalDirectory: Use the configured folder for your selected folder. Example:
                    ./hornetq/data/journal</p></li><li><p>JournalPrefix: Use the prefix for your selected journal, as discussed
                    <a class="link" href="#persistence.journallist" title="???TITLE???">here</a></p></li><li><p>FileExtension: Use the extension for your selected journal, as discussed
                    <a class="link" href="#persistence.journallist" title="???TITLE???">here</a></p></li><li><p>FileSize: Use the size for your selected journal, as discussed <a class="link" href="#persistence.journallist" title="???TITLE???">here</a></p></li><li><p>FileOutput: text file that will contain the exported data</p></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="configuring-transports"/>Chapter 16. Configuring the Transport</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#configuring-transports.acceptors">16.1. Understanding Acceptors</a></span></dt><dt><span class="section"><a href="#configuring-transports.connectors">16.2. Understanding Connectors</a></span></dt><dt><span class="section"><a href="#configuring-transports.client.side">16.3. Configuring the transport directly from the client side.</a></span></dt><dt><span class="section"><a href="#d0e3433">16.4. Configuring the Netty transport</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3445">16.4.1. Single Port Support</a></span></dt><dt><span class="section"><a href="#d0e3463">16.4.2. Configuring Netty TCP</a></span></dt><dt><span class="section"><a href="#d0e3620">16.4.3. Configuring Netty SSL</a></span></dt><dt><span class="section"><a href="#d0e3758">16.4.4. Configuring Netty HTTP</a></span></dt><dt><span class="section"><a href="#d0e3798">16.4.5. Configuring Netty Servlet</a></span></dt></dl></dd></dl></div><p>HornetQ has a fully pluggable and highly flexible transport layer and defines its own
        Service Provider Interface (SPI) to make plugging in a new transport provider relatively
        straightforward.</p><p>In this chapter we'll describe the concepts required for understanding HornetQ transports
        and where and how they're configured.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="configuring-transports.acceptors"/>16.1. Understanding Acceptors</h2></div></div></div><p>One of the most important concepts in HornetQ transports is the
                <span class="emphasis"><em>acceptor</em></span>. Let's dive straight in and take a look at an acceptor
            defined in xml in the configuration file <code class="literal">hornetq-configuration.xml</code>.</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;acceptors&gt;
   &lt;acceptor name="netty"&gt;
      &lt;factory-class&gt;
         org.hornetq.core.remoting.impl.netty.NettyAcceptorFactory
      &lt;/factory-class&gt;
      &lt;param key="port" value="5446"/&gt;
   &lt;/acceptor&gt;
&lt;/acceptors&gt;</pre><p>Acceptors are always defined inside an <code class="literal">acceptors</code> element. There can
            be one or more acceptors defined in the <code class="literal">acceptors</code> element. There's no
            upper limit to the number of acceptors per server.</p><p>Each acceptor defines a way in which connections can be made to the HornetQ
            server.</p><p>In the above example we're defining an acceptor that uses <a class="ulink" href="http://jboss.org/netty">Netty</a> to listen for connections at port
                <code class="literal">5446</code>. </p><p>The <code class="literal">acceptor</code> element contains a sub-element <code class="literal">factory-class</code>, this element defines the factory used to create acceptor
            instances. In this case we're using Netty to listen for connections so we use the Netty
            implementation of an <code class="literal">AcceptorFactory</code> to do this. Basically, the
                <code class="literal">factory-class</code> element determines which pluggable transport we're
            going to use to do the actual listening.</p><p>The <code class="literal">acceptor</code> element can also be configured with zero or more
                <code class="literal">param</code> sub-elements. Each <code class="literal">param</code> element defines
            a key-value pair. These key-value pairs are used to configure the specific transport,
            the set of valid key-value pairs depends on the specific transport be used and are
            passed straight through to the underlying transport.</p><p>Examples of key-value pairs for a particular transport would be, say, to configure the
            IP address to bind to, or the port to listen at.</p><p>Note that unlike versions before 2.4 an Acceptor can now support multiple protocols. By default this will
            be all available protocols but can be limited by either the now deprecated <code class="literal">protocol</code> param or
        by setting a comma seperated list to the newly added <code class="literal">protocols</code> parameter.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="configuring-transports.connectors"/>16.2. Understanding Connectors</h2></div></div></div><p>Whereas acceptors are used on the server to define how we accept connections,
            connectors are used by a client to define how it connects to a server.</p><p>Let's look at a connector defined in our <code class="literal">hornetq-configuration.xml</code>
            file:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;connectors&gt;
   &lt;connector name="netty"&gt;
      &lt;factory-class&gt;
         org.hornetq.core.remoting.impl.netty.NettyConnectorFactory
      &lt;/factory-class&gt;
      &lt;param key="port" value="5446"/&gt;
   &lt;/connector&gt;
&lt;/connectors&gt;</pre><p>Connectors can be defined inside a <code class="literal">connectors</code> element. There can be
            one or more connectors defined in the <code class="literal">connectors</code> element. There's no
            upper limit to the number of connectors per server.</p><p>You make ask yourself, if connectors are used by the <span class="emphasis"><em>client</em></span> to
            make connections then why are they defined on the <span class="emphasis"><em>server</em></span>? There are
            a couple of reasons for this:</p><div class="itemizedlist"><ul><li><p>Sometimes the server acts as a client itself when it connects to another
                    server, for example when one server is bridged to another, or when a server
                    takes part in a cluster. In this cases the server needs to know how to connect
                    to other servers. That's defined by <span class="emphasis"><em>connectors</em></span>.</p></li><li><p>If you're using JMS and the server side JMS service to instantiate JMS
                    ConnectionFactory instances and bind them in JNDI, then when creating the
                        <code class="literal">HornetQConnectionFactory</code> it needs to know what server
                    that connection factory will create connections to.</p><p>That's defined by the <code class="literal">connector-ref</code> element in the <code class="literal">hornetq-jms.xml</code> file on the server side. Let's take a look at a
                    snipped from a <code class="literal">hornetq-jms.xml</code> file that shows a JMS
                    connection factory that references our netty connector defined in our <code class="literal">hornetq-configuration.xml</code> file:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;connection-factory name="ConnectionFactory"&gt;
   &lt;connectors&gt;
      &lt;connector-ref connector-name="netty"/&gt;
   &lt;/connectors&gt;
   &lt;entries&gt;
      &lt;entry name="ConnectionFactory"/&gt;
      &lt;entry name="XAConnectionFactory"/&gt;
   &lt;/entries&gt;
&lt;/connection-factory&gt;</pre></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="configuring-transports.client.side"/>16.3. Configuring the transport directly from the client side.</h2></div></div></div><p>How do we configure a core <code class="literal">ClientSessionFactory</code> with the
            information that it needs to connect with a server?</p><p>Connectors are also used indirectly when directly configuring a core <code class="literal">ClientSessionFactory</code> to directly talk to a server. Although in this case
            there's no need to define such a connector in the server side configuration, instead we
            just create the parameters and tell the <code class="literal">ClientSessionFactory</code> which
            connector factory to use.</p><p>Here's an example of creating a <code class="literal">ClientSessionFactory</code> which will
            connect directly to the acceptor we defined earlier in this chapter, it uses the
            standard Netty TCP transport and will try and connect on port 5446 to localhost
            (default):</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
Map&lt;String, Object&gt; connectionParams = new HashMap&lt;String, Object&gt;();

connectionParams.put(org.hornetq.core.remoting.impl.netty.TransportConstants.PORT_PROP_NAME,
                    5446);

TransportConfiguration transportConfiguration =
    new TransportConfiguration(
    "org.hornetq.core.remoting.impl.netty.NettyConnectorFactory",
    connectionParams);

ServerLocator locator = HornetQClient.createServerLocatorWithoutHA(transportConfiguration);

ClientSessionFactory sessionFactory = locator.createClientSessionFactory();

ClientSession session = sessionFactory.createSession(...);

etc</pre><p>Similarly, if you're using JMS, you can configure the JMS connection factory directly
            on the client side without having to define a connector on the server side or define a
            connection factory in <code class="literal">hornetq-jms.xml</code>:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
Map&lt;String, Object&gt; connectionParams = new HashMap&lt;String, Object&gt;();

connectionParams.put(org.hornetq.core.remoting.impl.netty.TransportConstants.PORT_PROP_NAME, 5446);

TransportConfiguration transportConfiguration =
    new TransportConfiguration(
    "org.hornetq.core.remoting.impl.netty.NettyConnectorFactory",
    connectionParams);

ConnectionFactory connectionFactory = HornetQJMSClient.createConnectionFactoryWithoutHA(JMSFactoryType.CF, transportConfiguration);

Connection jmsConnection = connectionFactory.createConnection();

etc</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3433"/>16.4. Configuring the Netty transport</h2></div></div></div><p>Out of the box, HornetQ currently uses <a class="ulink" href="http://www.jboss.org/netty/">Netty</a>, a high performance low level network library.</p><p>Our Netty transport can be configured in several different ways; to use old (blocking)
            Java IO, or NIO (non-blocking), also to use straightforward TCP sockets, SSL, or to
            tunnel over HTTP or HTTPS..</p><p>We believe this caters for the vast majority of transport requirements.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3445"/>16.4.1. Single Port Support</h3></div></div></div><p>As of version 2.4 HornetQ now supports using a single port for all protocols, HornetQ will automatically
            detect which protocol is being used CORE, AMQP or STOMP and use the appropriate HornetQ handler. It will also detect
            whether protocols such as HTTP or Web Sockets are being used and also use the appropriate decoders</p><p>It is possible to limit which protocols are supported by using the <code class="literal">protocols</code> parameter
            on the Acceptor like so:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
    &lt;param key="protocols" value="CORE,AMQP"/&gt;
            </pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>The <code class="literal">protocol</code> parameter is now deprecated</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3463"/>16.4.2. Configuring Netty TCP</h3></div></div></div><p>Netty TCP is a simple unencrypted TCP sockets based transport. Netty TCP can be
                configured to use old blocking Java IO or non blocking Java NIO. We recommend you
                use the Java NIO on the server side for better scalability with many concurrent
                connections. However using Java old IO can sometimes give you better latency than
                NIO when you're not so worried about supporting many thousands of concurrent
                connections. </p><p>If you're running connections across an untrusted network please bear in mind this
                transport is unencrypted. You may want to look at the SSL or HTTPS
                configurations.</p><p>With the Netty TCP transport all connections are initiated from the client side.
                I.e. the server does not initiate any connections to the client. This works well
                with firewall policies that typically only allow connections to be initiated in one
                direction.</p><p>All the valid Netty transport keys are defined in the class <code class="literal">org.hornetq.core.remoting.impl.netty.TransportConstants</code>. Most
                parameters can be used either with acceptors or connectors, some only work with
                acceptors. The following parameters can be used to configure Netty for simple
                TCP:</p><div class="itemizedlist"><ul><li><p><code class="literal">use-nio</code>. If this is <code class="literal">true</code> then Java
                        non blocking NIO will be used. If set to <code class="literal">false</code> then old
                        blocking Java IO will be used.</p><p>If you require the server to handle many concurrent connections, we highly
                        recommend that you use non blocking Java NIO. Java NIO does not maintain a
                        thread per connection so can scale to many more concurrent connections than
                        with old blocking IO. If you don't require the server to handle many
                        concurrent connections, you might get slightly better performance by using
                        old (blocking) IO. The default value for this property is <code class="literal">false</code> on the server side and <code class="literal">false</code> on the
                        client side.</p></li><li><p><code class="literal">host</code>. This specifies the host name or IP address to
                        connect to (when configuring a connector) or to listen on (when configuring
                        an acceptor). The default value for this property is <code class="literal">localhost</code>. When configuring acceptors, multiple hosts or IP
                        addresses can be specified by separating them with commas. It is also
                        possible to specify <code class="code">0.0.0.0</code> to accept connection from all the
                        host's network interfaces. It's not valid to specify multiple addresses when
                        specifying the host for a connector; a connector makes a connection to one
                        specific address.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Don't forget to specify a host name or IP address! If you want your
                            server able to accept connections from other nodes you must specify a
                            hostname or IP address at which the acceptor will bind and listen for
                            incoming connections. The default is localhost which of course is not
                            accessible from remote nodes!</p></div></li><li><p><code class="literal">port</code>. This specified the port to connect to (when
                        configuring a connector) or to listen on (when configuring an acceptor). The
                        default value for this property is <code class="literal">5445</code>.</p></li><li><p><code class="literal">tcp-no-delay</code>. If this is <code class="literal">true</code> then
                            <a class="ulink" href="http://en.wikipedia.org/wiki/Nagle%27s_algorithm">Nagle's
                            algorithm</a> will be disabled. This is a
                            <a class="ulink" href="http://docs.oracle.com/javase/7/docs/technotes/guides/net/socketOpt.html">Java (client) socket option</a>. The default value for this property is <code class="literal">true</code>.</p></li><li><p><code class="literal">tcp-send-buffer-size</code>. This parameter determines the
                        size of the TCP send buffer in bytes. The default value for this property is
                            <code class="literal">32768</code> bytes (32KiB).</p><p>TCP buffer sizes should be tuned according to the bandwidth and latency of
                        your network. Here's a good link that explains the theory behind <a class="ulink" href="http://www-didc.lbl.gov/TCP-tuning/">this</a>.</p><p>In summary TCP send/receive buffer sizes should be calculated as:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
buffer_size = bandwidth * RTT.</pre><p>Where bandwidth is in <span class="emphasis"><em>bytes per second</em></span> and network
                        round trip time (RTT) is in seconds. RTT can be easily measured using the
                            <code class="literal">ping</code> utility.</p><p>For fast networks you may want to increase the buffer sizes from the
                        defaults.</p></li><li><p><code class="literal">tcp-receive-buffer-size</code>. This parameter determines the
                        size of the TCP receive buffer in bytes. The default value for this property
                        is <code class="literal">32768</code> bytes (32KiB).</p></li><li><p><code class="literal">batch-delay</code>. Before writing packets to the transport,
                        HornetQ can be configured to batch up writes for a maximum of <code class="literal">batch-delay</code> milliseconds. This can increase overall
                        throughput for very small messages. It does so at the expense of an increase
                        in average latency for message transfer. The default value for this property
                        is <code class="literal">0</code> ms.</p></li><li><p><code class="literal">direct-deliver</code>. When a message arrives on the server
                        and is delivered to waiting consumers, by default, the delivery is done on
                        the same thread as that on which the message arrived. This gives good latency
                        in environments with relatively small messages and a small number of consumers,
                        but at the cost of overall throughput and scalability - especially on multi-core
                        machines. If you want the lowest latency and a possible reduction in throughput
                        then you can use the default value for <code class="literal">direct-deliver</code> (i.e.
                        true). If you are willing to take some small extra hit on latency but want the
                        highest throughput set <code class="literal">direct-deliver</code> to <code class="literal">false
                        </code>.</p></li><li><p><code class="literal">nio-remoting-threads</code>. When configured to use NIO,
                        HornetQ will, by default, use a number of threads equal to three times the
                        number of cores (or hyper-threads) as reported by <code class="literal">Runtime.getRuntime().availableProcessors()</code> for processing
                        incoming packets. If you want to override this value, you can set the number
                        of threads by specifying this parameter. The default value for this
                        parameter is <code class="literal">-1</code> which means use the value from <code class="literal">Runtime.getRuntime().availableProcessors()</code> * 3.</p></li><li><p><code class="literal">local-address</code>. When configured a Netty Connector it is possible to specify
                        which local address the client will use when connecting to the remote address. This is typically used
                        in the Application Server or when running Embedded to control which address is used for outbound
                        connections. If the local-address is not set then the connector will use any local address available</p></li><li><p><code class="literal">local-port</code>. When configured a Netty Connector it is possible to specify
                        which local port the client will use when connecting to the remote address. This is typically used
                        in the Application Server or when running Embedded to control which port is used for outbound
                        connections. If the local-port default is used, which is 0, then the connector will let the
                       system pick up an ephemeral port. valid ports are 0 to 65535</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3620"/>16.4.3. Configuring Netty SSL</h3></div></div></div><p>Netty SSL is similar to the Netty TCP transport but it provides additional
                security by encrypting TCP connections using the Secure Sockets Layer SSL</p><p>Please see the examples for a full working example of using Netty SSL.</p><p>Netty SSL uses all the same properties as Netty TCP but adds the following
                additional properties:</p><div class="itemizedlist"><ul><li><p><code class="literal">ssl-enabled</code></p><p>Must be <code class="literal">true</code> to enable SSL. Default is <code class="literal">false</code>.</p></li><li><p><code class="literal">key-store-path</code></p><p>When used on an <code class="literal">acceptor</code> this is the path to the SSL key
                        store on the server which holds the server's certificates (whether self-signed
                        or signed by an authority).</p><p>When used on a <code class="literal">connector</code> this is the path to the client-side
                        SSL key store which holds the client certificates. This is only relevant
                        for a <code class="literal">connector</code> if you are using 2-way SSL (i.e. mutual
                        authentication). Although this value is configured on the server, it is
                        downloaded and used by the client. If the client needs to use a different path
                        from that set on the server then it can override the server-side setting by either
                        using the customary "javax.net.ssl.keyStore" system property or the HornetQ-specific
                        "org.hornetq.ssl.keyStore" system property. The HornetQ-specific system property
                        is useful if another component on client is already making use of the standard, Java
                        system property.</p></li><li><p><code class="literal">key-store-password</code></p><p>When used on an <code class="literal">acceptor</code> this is the password for the
                        server-side keystore.</p><p>When used on a <code class="literal">connector</code> this is the password for the
                        client-side keystore.  This is only relevant for a <code class="literal">connector</code>
                        if you are using 2-way SSL (i.e. mutual authentication). Although this value can
                        be configured on the server, it is downloaded and used by the client.  If the client
                        needs to use a different password from that set on the server then it can override
                        the server-side setting by either using the customary "javax.net.ssl.keyStorePassword"
                        system property or the HornetQ-specific "org.hornetq.ssl.keyStorePassword" system
                        property. The HornetQ-specific system property is useful if another component on client
                        is already making use of the standard, Java system property.</p></li><li><p><code class="literal">trust-store-path</code></p><p>When used on an <code class="literal">acceptor</code> this is the path to the server-side
                        SSL key store that holds the keys of all the clients that the server trusts.  This
                        is only relevant for an <code class="literal">acceptor</code> if you are using 2-way SSL
                        (i.e. mutual authentication).</p><p>When used on a <code class="literal">connector</code> this is the path to the client-side
                        SSL key store which holds the public keys of all the servers that the client
                        trusts. Although this value can be configured on the server, it is downloaded and
                        used by the client.  If the client needs to use a different path
                        from that set on the server then it can override the server-side setting by either
                        using the customary "javax.net.ssl.trustStore" system property or the HornetQ-specific
                        "org.hornetq.ssl.trustStore" system property. The HornetQ-specific system property
                        is useful if another component on client is already making use of the standard, Java
                        system property.</p></li><li><p><code class="literal">trust-store-password</code></p><p>When used on an <code class="literal">acceptor</code> this is the password for the
                        server-side trust store.  This is only relevant for an <code class="literal">acceptor</code>
                        if you are using 2-way SSL (i.e. mutual authentication).</p><p>When used on a <code class="literal">connector</code> this is the password for the
                        client-side truststore. Although this value can be configured on the server, it is
                        downloaded and used by the client.   If the client
                        needs to use a different password from that set on the server then it can override
                        the server-side setting by either using the customary "javax.net.ssl.trustStorePassword"
                        system property or the HornetQ-specific "org.hornetq.ssl.trustStorePassword" system
                        property. The HornetQ-specific system property is useful if another component on client
                        is already making use of the standard, Java system property.</p></li><li><p><code class="literal">enabled-cipher-suites</code></p><p>Whether used on an <code class="literal">acceptor</code> or <code class="literal">connector</code> this is a
                        comma separated list of cipher suites used for SSL communication. The default value is
                        <code class="literal">null</code> which means the JVM's default will be used.</p></li><li><p><code class="literal">enabled-protocols</code></p><p>Whether used on an <code class="literal">acceptor</code> or <code class="literal">connector</code> this is a
                        comma separated list of protocols used for SSL communication. The default value is
                        <code class="literal">null</code> which means the JVM's default will be used.</p></li><li><p><code class="literal">need-client-auth</code></p><p>This property is only for an <code class="literal">acceptor</code>. It tells a client connecting to this
                        acceptor that 2-way SSL is required. Valid values are <code class="literal">true</code> or
                        <code class="literal">false</code>. Default is <code class="literal">false</code>.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3758"/>16.4.4. Configuring Netty HTTP</h3></div></div></div><p>Netty HTTP tunnels packets over the HTTP protocol. It can be useful in scenarios
                where firewalls only allow HTTP traffic to pass.</p><p>Please see the examples for a full working example of using Netty HTTP.</p><p>Netty HTTP uses the same properties as Netty TCP but adds the following additional
                properties:</p><div class="itemizedlist"><ul><li><p><code class="literal">http-enabled</code>. This is now no longer needed as of version 2.4. With single
                        port support HornetQ will now automatically detect if http is being used and configure itself.</p></li><li><p><code class="literal">http-client-idle-time</code>. How long a client can be idle
                        before sending an empty http request to keep the connection alive</p></li><li><p><code class="literal">http-client-idle-scan-period</code>. How often, in
                        milliseconds, to scan for idle clients</p></li><li><p><code class="literal">http-response-time</code>. How long the server can wait before
                        sending an empty http response to keep the connection alive</p></li><li><p><code class="literal">http-server-scan-period</code>. How often, in milliseconds, to
                        scan for clients needing responses</p></li><li><p><code class="literal">http-requires-session-id</code>. If true the client will wait
                        after the first call to receive a session id. Used the http connector is
                        connecting to servlet acceptor (not recommended) </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3798"/>16.4.5. Configuring Netty Servlet</h3></div></div></div><p>As of 2.4 HornetQ Servlet support will be provided via Undertow in Wildfly</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="connection-ttl"/>Chapter 17. Detecting Dead Connections</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#dead.connections">17.1. Cleaning up Dead Connection Resources on the Server</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3888">17.1.1. Closing core sessions or JMS connections that you have failed to close</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3904">17.2. Detecting failure from the client side.</a></span></dt><dt><span class="section"><a href="#connection-ttl.async-connection-execution">17.3. Configuring Asynchronous Connection Execution</a></span></dt></dl></div><p>In this section we will discuss connection time-to-live (TTL) and explain how HornetQ
        deals with crashed clients and clients which have exited without cleanly closing their
        resources.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="dead.connections"/>17.1. Cleaning up Dead Connection Resources on the Server</h2></div></div></div><p>Before a HornetQ client application exits it is considered good practice that it
            should close its resources in a controlled manner, using a <code class="literal">finally</code>
            block.</p><p>Here's an example of a well behaved core client application closing its session and
            session factory in a finally block:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
ServerLocator locator = null;
ClientSessionFactory sf = null;
ClientSession session = null;

try
{
   locator = HornetQClient.createServerLocatorWithoutHA(..);

   sf = locator.createClientSessionFactory();;

   session = sf.createSession(...);
   
   ... do some stuff with the session...
}
finally
{
   if (session != null)
   {
      session.close();
   }
   
   if (sf != null)
   {
      sf.close();
   }

   if(locator != null)
   {
      locator.close();
   }
}</pre><p>And here's an example of a well behaved JMS client application:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
Connection jmsConnection = null;

try
{
   ConnectionFactory jmsConnectionFactory = HornetQJMSClient.createConnectionFactoryWithoutHA(...);

   jmsConnection = jmsConnectionFactory.createConnection();

   ... do some stuff with the connection...
}
finally
{
   if (connection != null)
   {
      connection.close();
   }
}</pre><p>Unfortunately users don't always write well behaved applications, and sometimes
            clients just crash so they don't have a chance to clean up their resources!</p><p>If this occurs then it can leave server side resources, like sessions, hanging on the
            server. If these were not removed they would cause a resource leak on the server and
            over time this result in the server running out of memory or other resources.</p><p>We have to balance the requirement for cleaning up dead client resources with the fact
            that sometimes the network between the client and the server can fail and then come
            back, allowing the client to reconnect. HornetQ supports client reconnection, so we
            don't want to clean up "dead" server side resources too soon or this will prevent any
            client from reconnecting, as it won't be able to find its old sessions on the
            server.</p><p>HornetQ makes all of this configurable. For each <code class="literal">ClientSessionFactory</code> we define a <span class="emphasis"><em>connection TTL</em></span>.
            Basically, the TTL determines how long the server will keep a connection alive in the
            absence of any data arriving from the client. The client will automatically send "ping"
            packets periodically to prevent the server from closing it down. If the server doesn't
            receive any packets on a connection for the connection TTL time, then it will
            automatically close all the sessions on the server that relate to that
            connection.</p><p>If you're using JMS, the connection TTL is defined by the <code class="literal">ConnectionTTL</code> attribute on a <code class="literal">HornetQConnectionFactory</code>
            instance, or if you're deploying JMS connection factory instances direct into JNDI on
            the server side, you can specify it in the xml config, using the parameter <code class="literal">connection-ttl</code>.</p><p>The default value for connection ttl is <code class="literal">60000</code>ms, i.e. 1 minute. A
            value of <code class="literal">-1</code> for <code class="literal">ConnectionTTL</code> means the server
            will never time out the connection on the server side.</p><p><a id="connection-ttl.override"/>If you do not wish clients to be able to specify their own connection TTL, you can
            override all values used by a global value set on the server side. This can be done by
            specifying the <code class="literal">connection-ttl-override</code> attribute in the server side
            configuration. The default value for <code class="literal">connection-ttl-override</code> is
                <code class="literal">-1</code> which means "do not override" (i.e. let clients use their own
            values).</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3888"/>17.1.1. Closing core sessions or JMS connections that you have failed to close</h3></div></div></div><p>As previously discussed, it's important that all core client sessions and JMS
                connections are always closed explicitly in a <code class="literal">finally</code> block when
                you are finished using them. </p><p>If you fail to do so, HornetQ will detect this at garbage collection time, and log
                a warning similar to the following in the logs (If you are using JMS the warning
                will involve a JMS connection not a client session):</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
[Finalizer] 20:14:43,244 WARNING [org.hornetq.core.client.impl.DelegatingSession]  I'm closing a ClientSession you left open. Please make sure you close all ClientSessions explicitly before let
ting them go out of scope!
[Finalizer] 20:14:43,244 WARNING [org.hornetq.core.client.impl.DelegatingSession]  The session you didn't close was created here:
java.lang.Exception
   at org.hornetq.core.client.impl.DelegatingSession.&lt;init&gt;(DelegatingSession.java:83)
   at org.acme.yourproject.YourClass (YourClass.java:666)</pre><p>HornetQ will then close the connection / client session for you.</p><p>Note that the log will also tell you the exact line of your user code where you
                created the JMS connection / client session that you later did not close. This will
                enable you to pinpoint the error in your code and correct it appropriately.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3904"/>17.2. Detecting failure from the client side.</h2></div></div></div><p>In the previous section we discussed how the client sends pings to the server and how
            "dead" connection resources are cleaned up by the server. There's also another reason
            for pinging, and that's for the <span class="emphasis"><em>client</em></span> to be able to detect that
            the server or network has failed.</p><p>As long as the client is receiving data from the server it will consider the
            connection to be still alive. </p><p>If the client does not receive any packets for <code class="literal">client-failure-check-period</code> milliseconds then it will consider the
            connection failed and will either initiate failover, or call any <code class="literal">FailureListener</code> instances (or <code class="literal">ExceptionListener</code>
            instances if you are using JMS) depending on how it has been configured.</p><p>If you're using JMS it's defined by the <code class="literal">ClientFailureCheckPeriod</code>
            attribute on a <code class="literal">HornetQConnectionFactory</code> instance, or if you're
            deploying JMS connection factory instances direct into JNDI on the server side, you can
            specify it in the <code class="literal">hornetq-jms.xml </code> configuration file, using the
            parameter <code class="literal">client-failure-check-period</code>.</p><p>The default value for client failure check period is <code class="literal">30000</code>ms, i.e.
            30 seconds. A value of <code class="literal">-1</code> means the client will never fail the
            connection on the client side if no data is received from the server. Typically this is
            much lower than connection TTL to allow clients to reconnect in case of transitory
            failure.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="connection-ttl.async-connection-execution"/>17.3. Configuring Asynchronous Connection Execution</h2></div></div></div><p>By default, packets received on the server side are executed on the remoting
            thread.</p><p>It is possible instead to use a thread from a thread pool to handle some packets so
            that the remoting thread is not tied up for too long. However, please note that
            processing operations asynchronously on another thread adds a little more latency.
            Please note that most short running operations are always handled on the remoting thread for performance reasons.
           
            To enable asynchronous connection execution, set the parameter <code class="literal">async-connection-execution-enabled</code> in <code class="literal">hornetq-configuration.xml</code> to <code class="literal">true</code> (default value is
                <code class="literal">true</code>).</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="transaction-config"/>Chapter 18. Resource Manager Configuration</h2></div></div></div><p>HornetQ has its own Resource Manager for handling the lifespan of JTA transactions. When a
        transaction is started the resource manager is notified and keeps a record of the
        transaction and its current state. It is possible in some cases for a transaction to be
        started but then forgotten about. Maybe the client died and never came back. If this happens
        then the transaction will just sit there indefinitely.</p><p>To cope with this HornetQ can, if configured, scan for old transactions and rollback any
        it finds. The default for this is 3000000 milliseconds (5 minutes), i.e. any transactions older
        than 5 minutes are removed. This timeout can be changed by editing the <code class="literal">transaction-timeout</code> property in <code class="literal">hornetq-configuration.xml</code> (value must be in milliseconds).
        The property <code class="literal">transaction-timeout-scan-period</code> configures how often, in
        milliseconds, to scan for old transactions.</p><p>Please note that HornetQ will not unilaterally rollback any XA transactions in a prepared state - this must be heuristically rolled
    back via the management API if you are sure they will never be resolved by the transaction manager.</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="flow-control"/>Chapter 19. Flow Control</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e4023">19.1. Consumer Flow Control</a></span></dt><dd><dl><dt><span class="section"><a href="#flow-control.consumer.window">19.1.1. Window-Based Flow Control</a></span></dt><dt><span class="section"><a href="#d0e4143">19.1.2. Rate limited flow control</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e4196">19.2. Producer flow control</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4201">19.2.1. Window based flow control</a></span></dt><dt><span class="section"><a href="#d0e4285">19.2.2. Rate limited flow control</a></span></dt></dl></dd></dl></div><p>Flow control is used to limit the flow of data between a client and server, or a server and
      another server in order to prevent the client or server being overwhelmed with data.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4023"/>19.1. Consumer Flow Control</h2></div></div></div><p>This controls the flow of data between the server and the client as the client consumes
         messages. For performance reasons clients normally buffer messages before delivering to the
         consumer via the <code class="literal">receive()</code> method or asynchronously via a message
         listener. If the consumer cannot process messages as fast as they are being delivered and
         stored in the internal buffer, then you could end up with a situation where messages would
         keep building up possibly causing out of memory on the client if they cannot be processed
         in time.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="flow-control.consumer.window"/>19.1.1. Window-Based Flow Control</h3></div></div></div><p>By default, HornetQ consumers buffer messages from the server in a client side buffer
            before the client consumes them. This improves performance: otherwise every time the
            client consumes a message, HornetQ would have to go the server to request the next
            message. In turn, this message would then get sent to the client side, if one was
            available.</p><p>A network round trip would be involved for <span class="emphasis"><em>every</em></span> message and
            considerably reduce performance.</p><p>To prevent this, HornetQ pre-fetches messages into a buffer on each consumer. The
            total maximum size of messages (in bytes) that will be buffered on each consumer is
            determined by the <code class="literal">consumer-window-size</code> parameter.</p><p>By default, the <code class="literal">consumer-window-size</code> is set to 1 MiB (1024 * 1024
            bytes).</p><p>The value can be:</p><div class="itemizedlist"><ul><li><p><code class="literal">-1</code> for an <span class="emphasis"><em>unbounded</em></span> buffer</p></li><li><p><code class="literal">0</code> to not buffer any messages. See <a class="xref" href="#examples.no-consumer-buffering" title="11.1.46. No Consumer Buffering">Section 11.1.46, “No Consumer Buffering”</a> for working example of a consumer
                  with no buffering.</p></li><li><p><code class="literal">&gt;0</code> for a buffer with the given maximum size in
                  bytes.</p></li></ul></div><p>Setting the consumer window size can considerably improve performance depending on
            the messaging use case. As an example, let's consider the two extremes: </p><div class="variablelist"><dl><dt><span class="term">Fast consumers</span></dt><dd><p>Fast consumers can process messages as fast as they consume them (or even
                     faster)</p><p>To allow fast consumers, set the <code class="literal">consumer-window-size</code> to
                     -1. This will allow <span class="emphasis"><em>unbounded</em></span> message buffering on the
                     client side.</p><p>Use this setting with caution: it can overflow the client memory if the
                     consumer is not able to process messages as fast as it receives them.</p></dd><dt><span class="term">Slow consumers</span></dt><dd><p>Slow consumers takes significant time to process each message and it is
                     desirable to prevent buffering messages on the client side so that they can be
                     delivered to another consumer instead.</p><p>Consider a situation where a queue has 2 consumers; 1 of which is very slow.
                     Messages are delivered in a round robin fashion to both consumers, the fast
                     consumer processes all of its messages very quickly until its buffer is empty.
                     At this point there are still messages awaiting to be processed in the buffer
                     of the slow consumer thus preventing them being processed by the fast consumer.
                     The fast consumer is therefore sitting idle when it could be processing the
                     other messages. </p><p>To allow slow consumers, set the <code class="literal">consumer-window-size</code> to
                     0 (for no buffer at all). This will prevent the slow consumer from buffering
                     any messages on the client side. Messages will remain on the server side ready
                     to be consumed by other consumers.</p><p>Setting this to 0 can give deterministic distribution between multiple
                     consumers on a queue.</p></dd></dl></div><p>Most of the consumers cannot be clearly identified as fast or slow consumers but are
            in-between. In that case, setting the value of <code class="literal">consumer-window-size</code>
            to optimize performance depends on the messaging use case and requires benchmarks to
            find the optimal value, but a value of 1MiB is fine in most cases.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="flow-control.core.api"/>19.1.1.1. Using Core API</h4></div></div></div><p>If HornetQ Core API is used, the consumer window size is specified by <code class="literal">ServerLocator.setConsumerWindowSize()</code> method and some of the
                  <code class="literal">ClientSession.createConsumer()</code> methods.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4124"/>19.1.1.2. Using JMS</h4></div></div></div><p>if JNDI is used to look up the connection factory, the consumer window size is
               configured in <code class="literal">hornetq-jms.xml</code>:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;connection-factory name="ConnectionFactory"&gt;
   &lt;connectors&gt;
      &lt;connector-ref connector-name="netty-connector"/&gt;
   &lt;/connectors&gt;
   &lt;entries&gt;
      &lt;entry name="ConnectionFactory"/&gt;
   &lt;/entries&gt;
      
   &lt;!-- Set the consumer window size to 0 to have *no* buffer on the client side --&gt;
   &lt;consumer-window-size&gt;0&lt;/consumer-window-size&gt;
&lt;/connection-factory&gt;</pre><p>If the connection factory is directly instantiated, the consumer window size is
               specified by <code class="literal">HornetQConnectionFactory.setConsumerWindowSize()</code>
               method.</p><p>Please see <a class="xref" href="#examples.no-consumer-buffering" title="11.1.46. No Consumer Buffering">Section 11.1.46, “No Consumer Buffering”</a> for an example which
               shows how to configure HornetQ to prevent consumer buffering when dealing with slow
               consumers.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e4143"/>19.1.2. Rate limited flow control</h3></div></div></div><p>It is also possible to control the <span class="emphasis"><em>rate</em></span> at which a consumer can
            consume messages. This is a form of throttling and can be used to make sure that a
            consumer never consumes messages at a rate faster than the rate specified. </p><p>The rate must be a positive integer to enable this functionality and is the maximum
            desired message consumption rate specified in units of messages per second. Setting this
            to <code class="literal">-1</code> disables rate limited flow control. The default value is
               <code class="literal">-1</code>.</p><p>Please see <a class="xref" href="#examples.consumer-rate-limit" title="11.1.17. Message Consumer Rate Limiting">Section 11.1.17, “Message Consumer Rate Limiting”</a> for a working example of
            limiting consumer rate.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="flow-control.rate.core.api"/>19.1.2.1. Using Core API</h4></div></div></div><p>If the HornetQ core API is being used the rate can be set via the <code class="literal">ServerLocator.setConsumerMaxRate(int consumerMaxRate)</code> method or
               alternatively via some of the <code class="literal">ClientSession.createConsumer()</code>
               methods. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4174"/>19.1.2.2. Using JMS</h4></div></div></div><p>If JNDI is used to look up the connection factory, the max rate can be configured
               in <code class="literal">hornetq-jms.xml</code>:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;connection-factory name="ConnectionFactory"&gt;
   &lt;connectors&gt;
      &lt;connector-ref connector-name="netty-connector"/&gt;
   &lt;/connectors&gt;
   &lt;entries&gt;
      &lt;entry name="ConnectionFactory"/&gt;
   &lt;/entries&gt;
   &lt;!-- We limit consumers created on this connection factory to consume messages at a maximum rate
   of 10 messages per sec --&gt;
   &lt;consumer-max-rate&gt;10&lt;/consumer-max-rate&gt;
&lt;/connection-factory&gt;</pre><p>If the connection factory is directly instantiated, the max rate size can be set
               via the <code class="literal">HornetQConnectionFactory.setConsumerMaxRate(int
                  consumerMaxRate)</code> method.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Rate limited flow control can be used in conjunction with window based flow
                  control. Rate limited flow control only effects how many messages a client can
                  consume in a second and not how many messages are in its buffer. So if you had a
                  slow rate limit and a high window based limit the clients internal buffer would
                  soon fill up with messages.</p></div><p>Please see <a class="xref" href="#examples.consumer-rate-limit" title="11.1.17. Message Consumer Rate Limiting">Section 11.1.17, “Message Consumer Rate Limiting”</a> for an example which
               shows how to configure HornetQ to prevent consumer buffering when dealing with slow
               consumers.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4196"/>19.2. Producer flow control</h2></div></div></div><p>HornetQ also can limit the amount of data sent from a client to a server to prevent the
         server being overwhelmed.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e4201"/>19.2.1. Window based flow control</h3></div></div></div><p>In a similar way to consumer window based flow control, HornetQ producers, by
            default, can only send messages to an address as long as they have sufficient credits to
            do so. The amount of credits required to send a message is given by the size of the
            message.</p><p>As producers run low on credits they request more from the server, when the server
            sends them more credits they can send more messages.</p><p>The amount of credits a producer requests in one go is known as the <span class="italic">window size</span>.</p><p>The window size therefore determines the amount of bytes that can be in-flight at any
            one time before more need to be requested - this prevents the remoting connection from
            getting overloaded.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4215"/>19.2.1.1. Using Core API</h4></div></div></div><p>If the HornetQ core API is being used, window size can be set via the <code class="literal">ServerLocator.setProducerWindowSize(int producerWindowSize)</code>
               method.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4223"/>19.2.1.2. Using JMS</h4></div></div></div><p>If JNDI is used to look up the connection factory, the producer window size can be
               configured in <code class="literal">hornetq-jms.xml</code>:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;connection-factory name="ConnectionFactory"&gt;
   &lt;connectors&gt;
      &lt;connector-ref connector-name="netty-connector"/&gt;
   &lt;/connectors&gt;
   &lt;entries&gt;
      &lt;entry name="ConnectionFactory"/&gt;
   &lt;/entries&gt;
   &lt;producer-window-size&gt;10&lt;/producer-window-size&gt;
&lt;/connection-factory&gt;</pre><p>If the connection factory is directly instantiated, the producer window size can
               be set via the <code class="literal">HornetQConnectionFactory.setProducerWindowSize(int
                  producerWindowSize)</code> method.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4238"/>19.2.1.3. Blocking producer window based flow control</h4></div></div></div><p>Normally the server will always give the same number of credits as have been
               requested. However, it is also possible to set a maximum size on any address, and the
               server will never send more credits than could cause the address's upper memory limit
               to be exceeded.</p><p>For example, if I have a JMS queue called "myqueue", I could set the maximum
               memory size to 10MiB, and the the server will control the number of credits sent to
               any producers which are sending any messages to myqueue such that the total messages
               in the queue never exceeds 10MiB.</p><p>When the address gets full, producers will block on the client side until more
               space frees up on the address, i.e. until messages are consumed from the queue thus
               freeing up space for more messages to be sent.</p><p>We call this blocking producer flow control, and it's an efficient way to prevent
               the server running out of memory due to producers sending more messages than can be
               handled at any time.</p><p>It is an alternative approach to paging, which does not block producers but
               instead pages messages to storage.</p><p>To configure an address with a maximum size and tell the server that you want to
               block producers for this address if it becomes full, you need to define an
               AddressSettings (<a class="xref" href="#queue-attributes.address-settings" title="25.3. Configuring Queues Via Address Settings">Section 25.3, “Configuring Queues Via Address Settings”</a>) block for the
               address and specify <code class="literal">max-size-bytes</code> and <code class="literal">address-full-policy</code></p><p>The address block applies to all queues registered to that address. I.e. the total
               memory for all queues bound to that address will not exceed <code class="literal">max-size-bytes</code>. In the case of JMS topics this means the <span class="italic">total</span> memory of all subscriptions in the topic won't
               exceed max-size-bytes.</p><p>Here's an example:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;address-settings&gt;
   &lt;address-setting match="jms.queue.exampleQueue"&gt;
      &lt;max-size-bytes&gt;100000&lt;/max-size-bytes&gt;
      &lt;address-full-policy&gt;BLOCK&lt;/address-full-policy&gt;
   &lt;/address-setting&gt;
&lt;/address-settings&gt;</pre><p>The above example would set the max size of the JMS queue "exampleQueue" to be
               100000 bytes and would block any producers sending to that address to prevent that
               max size being exceeded.</p><p>Note the policy must be set to <code class="literal">BLOCK</code> to enable blocking producer
            flow control.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Note that in the default configuration all addresses are set to block producers after 10 MiB of message data
            is in the address. This means you cannot send more than 10MiB of message data to an address without it being consumed before the producers
            will be blocked. If you do not want this behaviour increase the <code class="literal">max-size-bytes</code> parameter or change the 
            address full message policy.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e4285"/>19.2.2. Rate limited flow control</h3></div></div></div><p>HornetQ also allows the rate a producer can emit message to be limited, in units of
            messages per second. By specifying such a rate, HornetQ will ensure that producer never
            produces messages at a rate higher than that specified.</p><p>The rate must be a positive integer to enable this functionality and is the maximum
            desired message consumption rate specified in units of messages per second. Setting this
            to <code class="literal">-1</code> disables rate limited flow control. The default value is
               <code class="literal">-1</code>.</p><p>Please see the <a class="xref" href="#producer-rate-limiting-example" title="11.1.50. Message Producer Rate Limiting">Section 11.1.50, “Message Producer Rate Limiting”</a> for a working example
            of limiting producer rate.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="flow-control.producer.rate.core.api"/>19.2.2.1. Using Core API</h4></div></div></div><p>If the HornetQ core API is being used the rate can be set via the <code class="literal">ServerLocator.setProducerMaxRate(int consumerMaxRate)</code> method or
               alternatively via some of the <code class="literal">ClientSession.createProducer()</code>
               methods. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4313"/>19.2.2.2. Using JMS</h4></div></div></div><p>If JNDI is used to look up the connection factory, the max rate can be configured
               in <code class="literal">hornetq-jms.xml</code>:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;connection-factory name="ConnectionFactory"&gt;
   &lt;connectors&gt;
      &lt;connector-ref connector-name="netty-connector"/&gt;
   &lt;/connectors&gt;
   &lt;entries&gt;
      &lt;entry name="ConnectionFactory"/&gt;
   &lt;/entries&gt;
   &lt;!-- We limit producers created on this connection factory to produce messages at a maximum rate
   of 10 messages per sec --&gt;
   &lt;producer-max-rate&gt;10&lt;/producer-max-rate&gt;
&lt;/connection-factory&gt;</pre><p>If the connection factory is directly instantiated, the max rate size can be set
               via the <code class="literal">HornetQConnectionFactory.setProducerMaxRate(int
                  consumerMaxRate)</code> method.</p></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="send-guarantees"/>Chapter 20. Guarantees of sends and commits</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e4348">20.1. Guarantees of Transaction Completion</a></span></dt><dt><span class="section"><a href="#non-transactional-sends">20.2. Guarantees of Non Transactional Message Sends</a></span></dt><dt><span class="section"><a href="#send-guarantees.nontrans.acks">20.3. Guarantees of Non Transactional Acknowledgements</a></span></dt><dt><span class="section"><a href="#asynchronous-send-acknowledgements">20.4. Asynchronous Send Acknowledgements</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4491">20.4.1. Asynchronous Send Acknowledgements</a></span></dt></dl></dd></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4348"/>20.1. Guarantees of Transaction Completion</h2></div></div></div><p>When committing or rolling back a transaction with HornetQ, the request to commit or
            rollback is sent to the server, and the call will block on the client side until a
            response has been received from the server that the commit or rollback was
            executed.</p><p>When the commit or rollback is received on the server, it will be committed to the
            journal, and depending on the value of the parameter <code class="literal">journal-sync-transactional</code> the server will ensure that the commit or
            rollback is durably persisted to storage before sending the response back to the client.
            If this parameter has the value <code class="literal">false</code> then commit or rollback may not
            actually get persisted to storage until some time after the response has been sent to
            the client. In event of server failure this may mean the commit or rollback never gets
            persisted to storage. The default value of this parameter is <code class="literal">true</code> so
            the client can be sure all transaction commits or rollbacks have been persisted to
            storage by the time the call to commit or rollback returns.</p><p>Setting this parameter to <code class="literal">false</code> can improve performance at the
            expense of some loss of transaction durability.</p><p>This parameter is set in <code class="literal">hornetq-configuration.xml</code></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="non-transactional-sends"/>20.2. Guarantees of Non Transactional Message Sends</h2></div></div></div><p>If you are sending messages to a server using a non transacted session, HornetQ can be
            configured to block the call to send until the message has definitely reached the
            server, and a response has been sent back to the client. This can be configured
            individually for durable and non-durable messages, and is determined by the
            following two parameters:</p><div class="itemizedlist"><ul><li><p><code class="literal">BlockOnDurableSend</code>. If this is set to <code class="literal">true</code> then all calls to send for durable messages on non
                    transacted sessions will block until the message has reached the server, and a
                    response has been sent back. The default value is <code class="literal">true</code>.
                </p></li><li><p><code class="literal">BlockOnNonDurableSend</code>. If this is set to <code class="literal">true</code> then all calls to send for non-durable messages on non
                    transacted sessions will block until the message has reached the server, and a
                    response has been sent back. The default value is <code class="literal">false</code>.</p></li></ul></div><p>Setting block on sends to <code class="literal">true</code> can reduce performance since each
            send requires a network round trip before the next send can be performed. This means the
            performance of sending messages will be limited by the network round trip time (RTT) of
            your network, rather than the bandwidth of your network. For better performance we
            recommend either batching many messages sends together in a transaction since with a
            transactional session, only the commit / rollback blocks not every send, or, using
            HornetQ's advanced <span class="emphasis"><em>asynchronous send acknowledgements feature</em></span>
            described in <a class="xref" href="#asynchronous-send-acknowledgements" title="20.4. Asynchronous Send Acknowledgements">Section 20.4, “Asynchronous Send Acknowledgements”</a>.</p><p>If you are using JMS and you're using the JMS service on the server to load your JMS
            connection factory instances into JNDI then these parameters can be configured in
                <code class="literal">hornetq-jms.xml</code> using the elements <code class="literal">block-on-durable-send</code> and <code class="literal">block-on-non-durable-send</code>. If you're using JMS but not using JNDI then
            you can set these values directly on the <code class="literal">HornetQConnectionFactory</code>
            instance using the appropriate setter methods.</p><p>If you're using core you can set these values directly on the <code class="literal">ClientSessionFactory</code> instance using the appropriate setter
            methods.</p><p>When the server receives a message sent from a non transactional session, and that
            message is durable and the message is routed to at least one durable queue, then the
            server will persist the message in permanent storage. If the journal parameter <code class="literal">journal-sync-non-transactional</code> is set to <code class="literal">true</code> the
            server will not send a response back to the client until the message has been persisted
            and the server has a guarantee that the data has been persisted to disk. The default
            value for this parameter is <code class="literal">true</code>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="send-guarantees.nontrans.acks"/>20.3. Guarantees of Non Transactional Acknowledgements</h2></div></div></div><p>If you are acknowledging the delivery of a message at the client side using a non
            transacted session, HornetQ can be configured to block the call to acknowledge until the
            acknowledge has definitely reached the server, and a response has been sent back to the
            client. This is configured with the parameter <code class="literal">BlockOnAcknowledge</code>. If
            this is set to <code class="literal">true</code> then all calls to acknowledge on non transacted
            sessions will block until the acknowledge has reached the server, and a response has
            been sent back. You might want to set this to <code class="literal">true</code> if you want to
            implement a strict <span class="emphasis"><em>at most once</em></span> delivery policy. The default value
            is <code class="literal">false</code></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="asynchronous-send-acknowledgements"/>20.4. Asynchronous Send Acknowledgements</h2></div></div></div><p>If you are using a non transacted session but want a guarantee that every message sent
            to the server has reached it, then, as discussed in <a class="xref" href="#non-transactional-sends" title="20.2. Guarantees of Non Transactional Message Sends">Section 20.2, “Guarantees of Non Transactional Message Sends”</a>, you can configure HornetQ to block the call to
            send until the server has received the message, persisted it and sent back a response.
            This works well but has a severe performance penalty - each call to send needs to block
            for at least the time of a network round trip (RTT) - the performance of sending is thus
            limited by the latency of the network, <span class="emphasis"><em>not</em></span> limited by the network
            bandwidth.</p><p>Let's do a little bit of maths to see how severe that is. We'll consider a standard
            1Gib ethernet network with a network round trip between the server and the client of
            0.25 ms.</p><p>With a RTT of 0.25 ms, the client can send <span class="emphasis"><em>at most</em></span> 1000/ 0.25 =
            4000 messages per second if it blocks on each message send.</p><p>If each message is &lt; 1500 bytes and a standard 1500 bytes MTU size is used on the
            network, then a 1GiB network has a <span class="emphasis"><em>theoretical</em></span> upper limit of (1024
            * 1024 * 1024 / 8) / 1500 = 89478 messages per second if messages are sent without
            blocking! These figures aren't an exact science but you can clearly see that being
            limited by network RTT can have serious effect on performance.</p><p>To remedy this, HornetQ provides an advanced new feature called <span class="emphasis"><em>asynchronous
                send acknowledgements</em></span>. With this feature, HornetQ can be configured to
            send messages without blocking in one direction and asynchronously getting
            acknowledgement from the server that the messages were received in a separate stream. By
            de-coupling the send from the acknowledgement of the send, the system is not limited by
            the network RTT, but is limited by the network bandwidth. Consequently better throughput
            can be achieved than is possible using a blocking approach, while at the same time
            having absolute guarantees that messages have successfully reached the server.</p><p>The window size for send acknowledgements is determined by the confirmation-window-size parameter on
        the connection factory or client session factory. Please see <a class="xref" href="#client-reconnection" title="Chapter 34. Client Reconnection and Session Reattachment">Chapter 34, <i>Client Reconnection and Session Reattachment</i></a> for more info on this.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e4491"/>20.4.1. Asynchronous Send Acknowledgements</h3></div></div></div><p>To use the feature using the core API, you implement the interface <code class="literal">org.hornetq.api.core.client.SendAcknowledgementHandler</code> and set a handler
                instance on your <code class="literal">ClientSession</code>.</p><p>Then, you just send messages as normal using your <code class="literal">ClientSession</code>, and as messages reach the server, the server will send
                back an acknowledgement of the send asynchronously, and some time later you are
                informed at the client side by HornetQ calling your handler's <code class="literal">sendAcknowledged(ClientMessage message)</code> method, passing in a
                    reference to the message that was sent.</p><p>To enable asynchronous send acknowledgements you must make sure <code class="literal">confirmation-window-size</code> is set to a positive integer value, e.g. 10MiB</p><p>Please see <a class="xref" href="#asynchronous-send-acknowledgements-example" title="11.1.66. Send Acknowledgements">Section 11.1.66, “Send Acknowledgements”</a> for a full
                working example.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="undelivered-messages"/>Chapter 21. Message Redelivery and Undelivered Messages</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e4556">21.1. Delayed Redelivery</a></span></dt><dd><dl><dt><span class="section"><a href="#undelivered-messages.delay">21.1.1. Configuring Delayed Redelivery</a></span></dt><dt><span class="section"><a href="#d0e4588">21.1.2. Example</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e4595">21.2. Dead Letter Addresses</a></span></dt><dd><dl><dt><span class="section"><a href="#undelivered-messages.configuring">21.2.1. Configuring Dead Letter Addresses</a></span></dt><dt><span class="section"><a href="#d0e4639">21.2.2. Dead Letter Properties</a></span></dt><dt><span class="section"><a href="#d0e4654">21.2.3. Example</a></span></dt></dl></dd><dt><span class="section"><a href="#configuring.delivery.count.persistence">21.3. Delivery Count Persistence</a></span></dt></dl></div><p>Messages can be delivered unsuccessfully (e.g. if the transacted session used to consume
      them is rolled back). Such a message goes back to its queue ready to be redelivered. However,
      this means it is possible for a message to be delivered again and again without any success
      and remain in the queue, clogging the system.</p><p>There are 2 ways to deal with these undelivered messages:</p><div class="itemizedlist"><ul><li><p>Delayed redelivery.</p><p>It is possible to delay messages redelivery to let the client some time to recover
            from transient failures and not overload its network or CPU resources</p></li><li><p>Dead Letter Address.</p><p>It is also possible to configure a dead letter address so that after a specified
            number of unsuccessful deliveries, messages are removed from the queue and will not be
            delivered again</p></li></ul></div><p>Both options can be combined for maximum flexibility.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4556"/>21.1. Delayed Redelivery</h2></div></div></div><p>Delaying redelivery can often be useful in the case that clients regularly fail or
         rollback. Without a delayed redelivery, the system can get into a "thrashing" state, with
         delivery being attempted, the client rolling back, and delivery being re-attempted ad
         infinitum in quick succession, consuming valuable CPU and network resources.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="undelivered-messages.delay"/>21.1.1. Configuring Delayed Redelivery</h3></div></div></div><p>Delayed redelivery is defined in the address-setting configuration:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;!-- delay redelivery of messages for 5s --&gt;
&lt;address-setting match="jms.queue.exampleQueue"&gt;
   &lt;!-- default is 1.0 --&gt; 
   &lt;redelivery-delay-multiplier&gt;1.5&lt;/redelivery-delay-multiplier&gt;
   &lt;!-- default is 0 (no delay) --&gt; 
   &lt;redelivery-delay&gt;5000&lt;/redelivery-delay&gt;
   &lt;!-- default is redelivery-delay * 10 --&gt;
   &lt;max-redelivery-delay&gt;50000&lt;/max-redelivery-delay&gt;
 
&lt;/address-setting&gt;</pre><p>If a <code class="literal">redelivery-delay</code> is specified, HornetQ will wait this delay
            before redelivering the messages.</p><p>By default, there is no redelivery delay (<code class="literal">redelivery-delay</code>is set
            to 0).</p><p>Other subsequent messages will be delivery regularly, only the cancelled message
               will be sent asynchronously back to the queue after the delay.</p><p>You can specify a multiplier that will take effect on top of the redelivery-delay
               with a max-redelivery-delay to be taken into account.</p><p>The max-redelivery-delay is defaulted to redelivery-delay * 10</p><p>Address wildcards can be used to configure redelivery delay for a set of addresses
            (see <a class="xref" href="#wildcard-syntax" title="Chapter 13. Understanding the HornetQ Wildcard Syntax">Chapter 13, <i>Understanding the HornetQ Wildcard Syntax</i></a>), so you don't have to specify redelivery delay
            individually for each address.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e4588"/>21.1.2. Example</h3></div></div></div><p>See <a class="xref" href="#examples.delayed-redelivery" title="11.1.19. Delayed Redelivery">Section 11.1.19, “Delayed Redelivery”</a> for an example which shows how
            delayed redelivery is configured and used with JMS.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4595"/>21.2. Dead Letter Addresses</h2></div></div></div><p>To prevent a client infinitely receiving the same undelivered message (regardless of
         what is causing the unsuccessful deliveries), messaging systems define <span class="italic">dead letter addresses</span>: after a specified unsuccessful delivery
         attempts, the message is removed from the queue and send instead to a dead letter address. </p><p>Any such messages can then be diverted to queue(s) where they can later be perused by
         the system administrator for action to be taken.</p><p>HornetQ's addresses can be assigned a dead letter address. Once the messages have been
         unsuccessfully delivered for a given number of attempts, they are removed from the queue
         and sent to the dead letter address. These <span class="emphasis"><em>dead letter</em></span> messages can
         later be consumed for further inspection.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="undelivered-messages.configuring"/>21.2.1. Configuring Dead Letter Addresses</h3></div></div></div><p>Dead letter address is defined in the address-setting configuration:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;!-- undelivered messages in exampleQueue will be sent to the dead letter address
   deadLetterQueue after 3 unsuccessful delivery attempts --&gt;
&lt;address-setting match="jms.queue.exampleQueue"&gt;
   &lt;dead-letter-address&gt;jms.queue.deadLetterQueue&lt;/dead-letter-address&gt;
   &lt;max-delivery-attempts&gt;3&lt;/max-delivery-attempts&gt;
&lt;/address-setting&gt;</pre><p>If a <code class="literal">dead-letter-address</code> is not specified, messages will removed
            after <code class="literal">max-delivery-attempts</code> unsuccessful attempts.</p><p>By default, messages are redelivered 10 times at the maximum. Set <code class="literal">max-delivery-attempts</code> to -1 for infinite redeliveries.</p><p>For example, a dead letter can be set globally for a set of matching addresses and
            you can set <code class="literal">max-delivery-attempts</code> to -1 for a specific address
            setting to allow infinite redeliveries only for this address.</p><p>Address wildcards can be used to configure dead letter settings for a set of
            addresses (see <a class="xref" href="#wildcard-syntax" title="Chapter 13. Understanding the HornetQ Wildcard Syntax">Chapter 13, <i>Understanding the HornetQ Wildcard Syntax</i></a>).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e4639"/>21.2.2. Dead Letter Properties</h3></div></div></div><p>Dead letter messages which are consumed from a dead letter address have the following
            property:</p><div class="itemizedlist"><ul><li><p><code class="literal">_HQ_ORIG_ADDRESS</code></p><p>a String property containing the <span class="emphasis"><em>original address</em></span> of
                  the dead letter message </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e4654"/>21.2.3. Example</h3></div></div></div><p>See <a class="xref" href="#examples.dead-letter" title="11.1.18. Dead Letter">Section 11.1.18, “Dead Letter”</a> for an example which shows how dead letter
            is configured and used with JMS.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="configuring.delivery.count.persistence"/>21.3. Delivery Count Persistence</h2></div></div></div><p>In normal use, HornetQ does not update delivery count <span class="emphasis"><em>persistently</em></span>
         until a message is rolled back (i.e. the delivery count is not updated
            <span class="emphasis"><em>before</em></span> the message is delivered to the consumer). In most messaging
         use cases, the messages are consumed, acknowledged and forgotten as soon as they are
         consumed. In these cases, updating the delivery count persistently before delivering the
         message would add an extra persistent step <span class="emphasis"><em>for each message delivered</em></span>,
         implying a significant performance penalty.</p><p>However, if the delivery count is not updated persistently before the message delivery
         happens, in the event of a server crash, messages might have been delivered but that will
         not have been reflected in the delivery count. During the recovery phase, the server will
         not have knowledge of that and will deliver the message with <code class="literal">redelivered</code>
         set to <code class="literal">false</code> while it should be <code class="literal">true</code>. </p><p>As this behavior breaks strict JMS semantics, HornetQ allows to persist delivery count
         before message delivery but disabled it by default for performance implications.</p><p>To enable it, set <code class="literal">persist-delivery-count-before-delivery</code> to <code class="literal">true</code> in <code class="literal">hornetq-configuration.xml</code>:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;persist-delivery-count-before-delivery&gt;true&lt;/persist-delivery-count-before-delivery&gt;</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="message-expiry"/>Chapter 22. Message Expiry</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e4733">22.1. Message Expiry</a></span></dt><dt><span class="section"><a href="#message-expiry.configuring">22.2. Configuring Expiry Addresses</a></span></dt><dt><span class="section"><a href="#configuring.expiry.reaper">22.3. Configuring The Expiry Reaper Thread</a></span></dt><dt><span class="section"><a href="#d0e4801">22.4. Example</a></span></dt></dl></div><p>Messages can be set with an optional <span class="emphasis"><em>time to live</em></span> when sending
      them.</p><p>HornetQ will not deliver a message to a consumer after it's time to live has been exceeded.
      If the message hasn't been delivered by the time that time to live is reached the server can
      discard it.</p><p>HornetQ's addresses can be assigned a expiry address so that, when messages are expired,
      they are removed from the queue and sent to the expiry address. Many different queues can be
      bound to an expiry address. These <span class="emphasis"><em>expired</em></span> messages can later be consumed
      for further inspection.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4733"/>22.1. Message Expiry</h2></div></div></div><p>Using HornetQ Core API, you can set an expiration time directly on the message:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
// message will expire in 5000ms from now
message.setExpiration(System.currentTimeMillis() + 5000);</pre><p>JMS MessageProducer allows to set a TimeToLive for the messages it sent:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
// messages sent by this producer will be retained for 5s (5000ms) before expiration           
producer.setTimeToLive(5000);</pre><p>Expired messages which are consumed from an expiry address have the following
         properties:</p><div class="itemizedlist"><ul><li><p><code class="literal">_HQ_ORIG_ADDRESS</code></p><p>a String property containing the <span class="emphasis"><em>original address</em></span> of the
               expired message </p></li><li><p><code class="literal">_HQ_ACTUAL_EXPIRY</code></p><p>a Long property containing the <span class="emphasis"><em>actual expiration time</em></span> of the
               expired message</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="message-expiry.configuring"/>22.2. Configuring Expiry Addresses</h2></div></div></div><p>Expiry address are defined in the address-setting configuration:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;!-- expired messages in exampleQueue will be sent to the expiry address expiryQueue --&gt;
&lt;address-setting match="jms.queue.exampleQueue"&gt;
   &lt;expiry-address&gt;jms.queue.expiryQueue&lt;/expiry-address&gt;
&lt;/address-setting&gt;</pre><p>If messages are expired and no expiry address is specified, messages are simply removed
         from the queue and dropped. Address wildcards can be used to configure expiry address for a
         set of addresses (see <a class="xref" href="#wildcard-syntax" title="Chapter 13. Understanding the HornetQ Wildcard Syntax">Chapter 13, <i>Understanding the HornetQ Wildcard Syntax</i></a>).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="configuring.expiry.reaper"/>22.3. Configuring The Expiry Reaper Thread</h2></div></div></div><p>A reaper thread will periodically inspect the queues to check if messages have
         expired.</p><p>The reaper thread can be configured with the following properties in <code class="literal">hornetq-configuration.xml</code></p><div class="itemizedlist"><ul><li><p><code class="literal">message-expiry-scan-period</code></p><p>How often the queues will be scanned to detect expired messages (in milliseconds,
               default is 30000ms, set to <code class="literal">-1</code> to disable the reaper thread)</p></li><li><p><code class="literal">message-expiry-thread-priority</code></p><p>The reaper thread priority (it must be between 0 and 9, 9 being the highest
               priority, default is 3)</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4801"/>22.4. Example</h2></div></div></div><p>See <a class="xref" href="#examples.expiry" title="11.1.24. Message Expiration">Section 11.1.24, “Message Expiration”</a> for an example which shows how message expiry is
         configured and used with JMS.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="large-messages"/>Chapter 23. Large Messages</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#large.message.configuring">23.1. Configuring the server</a></span></dt><dt><span class="section"><a href="#d0e4867">23.2. Configuring Parameters</a></span></dt><dd><dl><dt><span class="section"><a href="#large-messages.core.config">23.2.1. Using Core API</a></span></dt><dt><span class="section"><a href="#d0e4889">23.2.2. Using JMS</a></span></dt><dt><span class="section"><a href="#d0e4903">23.2.3. Compressed Large Messages</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e4936">23.3. Streaming large messages</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4968">23.3.1. Streaming over Core API</a></span></dt><dt><span class="section"><a href="#large-messages.streaming.over.jms">23.3.2. Streaming over JMS</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5069">23.4. Streaming Alternative</a></span></dt><dt><span class="section"><a href="#large-messages.example">23.5. Large message example</a></span></dt></dl></div><p>HornetQ supports sending and receiving of huge messages, even when the client and server
        are running with limited memory. The only realistic limit to the size of a message that can
        be sent or consumed is the amount of disk space you have available. We have tested sending
        and consuming messages up to 8 GiB in size with a client and server running in just 50MiB of
        RAM!</p><p>To send a large message, the user can set an <code class="literal">InputStream</code> on a message
        body, and when that message is sent, HornetQ will read the <code class="literal">InputStream</code>. A
            <code class="literal">FileInputStream</code> could be used for example to send a huge message from
        a huge file on disk.</p><p>As the <code class="literal">InputStream</code> is read the data is sent to the server as a stream
        of fragments. The server persists these fragments to disk as it receives them and when the
        time comes to deliver them to a consumer they are read back of the disk, also in fragments
        and sent down the wire. When the consumer receives a large message it initially receives
        just the message with an empty body, it can then set an <code class="literal">OutputStream</code> on
        the message to stream the huge message body to a file on disk or elsewhere. At no time is
        the entire message body stored fully in memory, either on the client or the server.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="large.message.configuring"/>23.1. Configuring the server</h2></div></div></div><p>Large messages are stored on a disk directory on the server side, as configured on the
            main configuration file.</p><p>The configuration property <code class="literal">large-messages-directory</code> specifies where
            large messages are stored.</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;configuration xmlns="urn:hornetq"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="urn:hornetq /schema/hornetq-configuration.xsd"&gt;
...
&lt;large-messages-directory&gt;/data/large-messages&lt;/large-messages-directory&gt;
...
&lt;/configuration</pre><p>By default the large message directory is <code class="literal">data/largemessages</code></p><p>For the best performance we recommend large messages directory is stored on a
            different physical volume to the message journal or paging directory.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4867"/>23.2. Configuring Parameters</h2></div></div></div><p>Any message larger than a certain size is considered a large message. Large messages
            will be split up and sent in fragments. This is determined by the parameter <code class="literal">min-large-message-size</code></p><p>The default value is 100KiB.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="large-messages.core.config"/>23.2.1. Using Core API</h3></div></div></div><p>If the HornetQ Core API is used, the minimal large message size is specified by
                    <code class="literal">ServerLocator.setMinLargeMessageSize</code>.</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
ServerLocator locator = HornetQClient.createServerLocatorWithoutHA(new TransportConfiguration(NettyConnectorFactory.class.getName()))

locator.setMinLargeMessageSize(25 * 1024);

ClientSessionFactory factory = HornetQClient.createClientSessionFactory();</pre><p><a class="xref" href="#configuring-transports.client.side" title="16.3. Configuring the transport directly from the client side.">Section 16.3, “Configuring the transport directly from the client side.”</a> will provide more information
                on how to instantiate the session factory.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e4889"/>23.2.2. Using JMS</h3></div></div></div><p>If JNDI is used to look up the connection factory, the minimum large message size
                is specified in <code class="literal">hornetq-jms.xml</code></p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">...
&lt;connection-factory name="ConnectionFactory"&gt;
   &lt;connectors&gt;
      &lt;connector-ref connector-name="netty"/&gt;
   &lt;/connectors&gt;
   &lt;entries&gt;
      &lt;entry name="ConnectionFactory"/&gt;
      &lt;entry name="XAConnectionFactory"/&gt;
   &lt;/entries&gt;

   &lt;min-large-message-size&gt;250000&lt;/min-large-message-size&gt;
&lt;/connection-factory&gt;
...</pre><p>If the connection factory is being instantiated directly, the minimum large
                message size is specified by <code class="literal">HornetQConnectionFactory.setMinLargeMessageSize</code>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e4903"/>23.2.3. Compressed Large Messages</h3></div></div></div><p>
				You can choose to send large messages in compressed form using <code class="literal">
				compress-large-messages</code> attributes.
            </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e4911"/>23.2.3.1. <code class="literal">compress-large-messages</code></h4></div></div></div><p>If you specify the boolean property <code class="literal">compress-large-messages</code> on
                the <code class="literal">server locator</code> or <code class="literal">ConnectionFactory</code> as true, The
                system will use the ZIP algorithm to compress the message body as the message is
                transferred to the server's side. Notice that there's no special treatment at the
                server's side, all the compressing and uncompressing is done at the client.</p><p>If the compressed size of a large message is below <code class="literal">
                min-large-message-size</code>, it is sent to server as regular messages. This means
			    that the message won't be written into the server's large-message
			    data directory, thus reducing the disk I/O.</p></div><div class="section" lang="en"><div class="titlepage"/><p>If you use JMS, you can achieve large messages compression by configuring your 
                connection factories. For example,</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">...
&lt;connection-factory name="ConnectionFactory"&gt;
   &lt;connectors&gt;
      &lt;connector-ref connector-name="netty"/&gt;
   &lt;/connectors&gt;
...
   &lt;compress-large-messages&gt;true&lt;/compress-large-messages&gt;
&lt;/connection-factory&gt;
...</pre></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4936"/>23.3. Streaming large messages</h2></div></div></div><p>HornetQ supports setting the body of messages using input and output streams (<code class="literal">java.lang.io</code>)</p><p>These streams are then used directly for sending (input streams) and receiving (output
            streams) messages.</p><p>When receiving messages there are 2 ways to deal with the output stream; you may
            choose to block while the output stream is recovered using the method <code class="literal">ClientMessage.saveOutputStream</code> or alternatively using the method <code class="literal">ClientMessage.setOutputstream</code> which will asynchronously write the message
            to the stream. If you choose the latter the consumer must be kept alive until the
            message has been fully received.</p><p>You can use any kind of stream you like. The most common use case is to send files
            stored in your disk, but you could also send things like JDBC Blobs, <code class="literal">SocketInputStream</code>, things you recovered from <code class="literal">HTTPRequests</code> etc. Anything as long as it implements <code class="literal">java.io.InputStream</code> for sending messages or <code class="literal">java.io.OutputStream</code> for receiving them.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e4968"/>23.3.1. Streaming over Core API</h3></div></div></div><p>The following table shows a list of methods available at <code class="literal">ClientMessage</code> which are also available through JMS by the use of
                object properties.</p><div class="table"><a id="large-messages.ClientMessageAPI"/><p class="title"><b>Table 23.1. org.hornetq.api.core.client.ClientMessage API</b></p><div class="table-contents"><table summary="org.hornetq.api.core.client.ClientMessage API" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>Name</th><th>Description</th><th>JMS Equivalent Property</th></tr></thead><tbody><tr><td>setBodyInputStream(InputStream)</td><td>Set the InputStream used to read a message body when sending
                                it.</td><td>JMS_HQ_InputStream</td></tr><tr><td>setOutputStream(OutputStream)</td><td>Set the OutputStream that will receive the body of a message.
                                This method does not block.</td><td>JMS_HQ_OutputStream</td></tr><tr><td>saveOutputStream(OutputStream)</td><td>Save the body of the message to the <code class="literal">OutputStream</code>. It will block until the entire content
                                is transferred to the <code class="literal">OutputStream</code>.</td><td>JMS_HQ_SaveStream</td></tr></tbody></table></div></div><br class="table-break"/><p>To set the output stream when receiving a core message: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
...
ClientMessage msg = consumer.receive(...);


// This will block here until the stream was transferred
msg.saveOutputStream(someOutputStream); 

ClientMessage msg2 = consumer.receive(...);

// This will not wait the transfer to finish
msg.setOutputStream(someOtherOutputStream); 
...</pre><p> Set the input stream when sending a core message: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
...
ClientMessage msg = session.createMessage();
msg.setInputStream(dataInputStream);
...</pre><p>Notice also that for messages with more than 2GiB the getBodySize() will return
                invalid values since this is an integer (which is also exposed to the JMS API). On
                those cases you can use the message property _HQ_LARGE_SIZE.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="large-messages.streaming.over.jms"/>23.3.2. Streaming over JMS</h3></div></div></div><p>When using JMS, HornetQ maps the streaming methods on the core API (see <a class="xref" href="#large-messages.ClientMessageAPI" title="Table 23.1. org.hornetq.api.core.client.ClientMessage API">Table 23.1, “org.hornetq.api.core.client.ClientMessage API”</a>) by setting object properties . You
                can use the method <code class="literal">Message.setObjectProperty</code> to set the input and
                output streams.</p><p>The <code class="literal">InputStream</code> can be defined through the JMS Object Property
                JMS_HQ_InputStream on messages being sent:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
BytesMessage message = session.createBytesMessage();

FileInputStream fileInputStream = new FileInputStream(fileInput);

BufferedInputStream bufferedInput = new BufferedInputStream(fileInputStream);

message.setObjectProperty("JMS_HQ_InputStream", bufferedInput);

someProducer.send(message);</pre><p>The <code class="literal">OutputStream</code> can be set through the JMS Object Property
                JMS_HQ_SaveStream on messages being received in a blocking way.</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
BytesMessage messageReceived = (BytesMessage)messageConsumer.receive(120000);
                
File outputFile = new File("huge_message_received.dat");
                
FileOutputStream fileOutputStream = new FileOutputStream(outputFile);
                
BufferedOutputStream bufferedOutput = new BufferedOutputStream(fileOutputStream);
                
// This will block until the entire content is saved on disk
messageReceived.setObjectProperty("JMS_HQ_SaveStream", bufferedOutput);</pre><p>Setting the <code class="literal">OutputStream</code> could also be done in a non blocking
                way using the property JMS_HQ_OutputStream.</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
// This won't wait the stream to finish. You need to keep the consumer active.
messageReceived.setObjectProperty("JMS_HQ_OutputStream", bufferedOutput);</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>When using JMS, Streaming large messages are only supported on <code class="literal">StreamMessage</code> and <code class="literal">BytesMessage</code>.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5069"/>23.4. Streaming Alternative</h2></div></div></div><p>If you choose not to use the <code class="literal">InputStream</code> or <code class="literal">OutputStream</code> capability of HornetQ You could still access the data
            directly in an alternative fashion.</p><p>On the Core API just get the bytes of the body as you normally would.</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
ClientMessage msg = consumer.receive();
         
byte[] bytes = new byte[1024];
for (int i = 0 ;  i &lt; msg.getBodySize(); i += bytes.length)
{
   msg.getBody().readBytes(bytes);
   // Whatever you want to do with the bytes
}</pre><p>If using JMS API, <code class="literal">BytesMessage</code> and <code class="literal">StreamMessage</code>
            also supports it transparently.</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
BytesMessage rm = (BytesMessage)cons.receive(10000);

byte data[] = new byte[1024];

for (int i = 0; i &lt; rm.getBodyLength(); i += 1024)
{
   int numberOfBytes = rm.readBytes(data);
   // Do whatever you want with the data
}        </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="large-messages.example"/>23.5. Large message example</h2></div></div></div><p>Please see <a class="xref" href="#examples.large-message" title="11.1.36. Large Message">Section 11.1.36, “Large Message”</a> for an example which shows how
            large message is configured and used with JMS.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="paging"/>Chapter 24. Paging</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e5132">24.1. Page Files</a></span></dt><dt><span class="section"><a href="#paging.main.config">24.2. Configuration</a></span></dt><dt><span class="section"><a href="#paging.mode">24.3. Paging Mode</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5191">24.3.1. Configuration</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5257">24.4. Dropping messages</a></span></dt><dt><span class="section"><a href="#d0e5270">24.5. Dropping messages and throwing an exception to producers</a></span></dt><dt><span class="section"><a href="#d0e5283">24.6. Blocking producers</a></span></dt><dt><span class="section"><a href="#d0e5300">24.7. Caution with Addresses with Multiple Queues</a></span></dt><dt><span class="section"><a href="#d0e5324">24.8. Example</a></span></dt></dl></div><p>HornetQ transparently supports huge queues containing millions of messages while the
        server is running with limited memory.</p><p>In such a situation it's not possible to store all of the queues in memory at any one
        time, so HornetQ transparently <span class="emphasis"><em>pages</em></span> messages into and out of memory as
        they are needed, thus allowing massive queues with a low memory footprint.</p><p>HornetQ will start paging messages to disk, when the size of all messages in memory for an
        address exceeds a configured maximum size.</p><p>By default, HornetQ does not page messages - this must be explicitly configured to
        activate it.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5132"/>24.1. Page Files</h2></div></div></div><p>Messages are stored per address on the file system. Each address has an individual
            folder where messages are stored in multiple files (page files). Each file will contain
            messages up to a max configured size (<code class="literal">page-size-bytes</code>). The system
            will navigate on the files as needed, and it will remove the page file as soon as all
            the messages are acknowledged up to that point.</p><p>Browsers will read through the page-cursor system.</p><p>Consumers with selectors will also navigate through the page-files and it will ignore
            messages that don't match the criteria.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="paging.main.config"/>24.2. Configuration</h2></div></div></div><p>You can configure the location of the paging folder</p><p>Global paging parameters are specified on the main configuration file (<code class="literal">hornetq-configuration.xml</code>).</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;configuration xmlns="urn:hornetq"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="urn:hornetq /schema/hornetq-configuration.xsd"&gt;
...
&lt;paging-directory&gt;/somewhere/paging-directory&lt;/paging-directory&gt;
...</pre><p>
            </p><div class="table"><a id="d0e5158"/><p class="title"><b>Table 24.1. Paging Configuration Parameters</b></p><div class="table-contents"><table summary="Paging Configuration Parameters" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>Property Name</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code class="literal">paging-directory</code></td><td>Where page files are stored. HornetQ will create one folder for
                                each address being paged under this configured location.</td><td>data/paging</td></tr></tbody></table></div></div><p><br class="table-break"/>
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="paging.mode"/>24.3. Paging Mode</h2></div></div></div><p>As soon as messages delivered to an address exceed the configured size, that address
            alone goes into page mode.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Paging is done individually per address. If you configure a max-size-bytes for an
                address, that means each matching address will have a maximum size that you
                specified. It DOES NOT mean that the total overall size of all matching addresses is
                limited to max-size-bytes.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5191"/>24.3.1. Configuration</h3></div></div></div><p>Configuration is done at the address settings, done at the main configuration file
                    (<code class="literal">hornetq-configuration.xml</code>).</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;address-settings&gt;
   &lt;address-setting match="jms.someaddress"&gt;
      &lt;max-size-bytes&gt;104857600&lt;/max-size-bytes&gt;
      &lt;page-size-bytes&gt;10485760&lt;/page-size-bytes&gt;
      &lt;address-full-policy&gt;PAGE&lt;/address-full-policy&gt;
   &lt;/address-setting&gt;
&lt;/address-settings&gt;</pre><p>This is the list of available parameters on the address settings.</p><p>
                </p><div class="table"><a id="d0e5205"/><p class="title"><b>Table 24.2. Paging Address Settings</b></p><div class="table-contents"><table summary="Paging Address Settings" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>Property Name</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code class="literal">max-size-bytes</code></td><td>What's the max memory the address could have before entering
                                    on page mode.</td><td>-1 (disabled)</td></tr><tr><td><code class="literal">page-size-bytes</code></td><td>The size of each page file used on the paging system</td><td>10MiB (10 * 1024 * 1024 bytes)</td></tr><tr><td><code class="literal">address-full-policy</code></td><td>This must be set to PAGE for paging to enable. If the value
                                    is PAGE then further messages will be paged to disk. If the
                                    value is DROP then further messages will be silently dropped. If
                                    the value is FAIL then the messages will be dropped and the client
                                    message producers will receive an exception. If the value is
                                    BLOCK then client message producers will block when they try and
                                    send further messages.</td><td>PAGE</td></tr><tr><td><code class="literal">page-max-cache-size</code></td><td>The system will keep up to &lt;<code class="literal">page-max-cache-size</code> page files in memory to
                                    optimize IO during paging navigation.</td><td>5</td></tr></tbody></table></div></div><p><br class="table-break"/>
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5257"/>24.4. Dropping messages</h2></div></div></div><p>Instead of paging messages when the max size is reached, an address can also be
            configured to just drop messages when the address is full.</p><p>To do this just set the <code class="literal">address-full-policy</code> to <code class="literal">DROP</code> in the address settings</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5270"/>24.5. Dropping messages and throwing an exception to producers</h2></div></div></div><p>Instead of paging messages when the max size is reached, an address can also be
            configured to drop messages and also throw an exception on the client-side
            when the address is full.</p><p>To do this just set the <code class="literal">address-full-policy</code> to <code class="literal">FAIL</code> in the address settings</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5283"/>24.6. Blocking producers</h2></div></div></div><p>Instead of paging messages when the max size is reached, an address can also be
            configured to block producers from sending further messages when the address is full,
            thus preventing the memory being exhausted on the server.</p><p>When memory is freed up on the server, producers will automatically unblock and be
            able to continue sending.</p><p>To do this just set the <code class="literal">address-full-policy</code> to <code class="literal">BLOCK</code> in the address settings</p><p>In the default configuration, all addresses are configured to block producers after 10
            MiB of data are in the address.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5300"/>24.7. Caution with Addresses with Multiple Queues</h2></div></div></div><p>When a message is routed to an address that has multiple queues bound to it, e.g. a
            JMS subscription in a Topic, there is only 1 copy of the message in memory. Each queue
            only deals with a reference to this. Because of this the memory is only freed up once
            all queues referencing the message have delivered it.</p><p>If you have a single lazy subscription, the entire address will suffer IO performance
            hit as all the queues will have messages being sent through an extra storage on the
            paging system.</p><p>For example:</p><div class="itemizedlist"><ul><li><p>An address has 10 queues </p></li><li><p>One of the queues does not deliver its messages (maybe because of a slow
                    consumer).</p></li><li><p>Messages continually arrive at the address and paging is started.</p></li><li><p>The other 9 queues are empty even though messages have been sent.</p></li></ul></div><p>In this example all the other 9 queues will be consuming messages from the page
            system. This may cause performance issues if this is an undesirable state.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5324"/>24.8. Example</h2></div></div></div><p>See <a class="xref" href="#examples.paging" title="11.1.48. Paging">Section 11.1.48, “Paging”</a> for an example which shows how to use paging
            with HornetQ.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="queue-attributes"/>Chapter 25. Queue Attributes</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#predefined.queues">25.1. Predefined Queues</a></span></dt><dt><span class="section"><a href="#d0e5406">25.2. Using the API</a></span></dt><dt><span class="section"><a href="#queue-attributes.address-settings">25.3. Configuring Queues Via Address Settings</a></span></dt></dl></div><p>Queue attributes can be set in one of two ways. Either by configuring them using the
        configuration file or by using the core API. This chapter will explain how to configure each
        attribute and what effect the attribute has.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="predefined.queues"/>25.1. Predefined Queues</h2></div></div></div><p>Queues can be predefined via configuration at a core level or at a JMS level. Firstly
            let's look at a JMS level.</p><p>The following shows a queue predefined in the <code class="literal">hornetq-jms.xml</code>
            configuration file.</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;queue name="selectorQueue"&gt;
   &lt;entry name="/queue/selectorQueue"/&gt;
   &lt;selector string="color='red'"/&gt;
   &lt;durable&gt;true&lt;/durable&gt;
&lt;/queue&gt;</pre><p>This name attribute of queue defines the name of the queue. When we do this at a jms
            level we follow a naming convention so the actual name of the core queue will be
                <code class="literal">jms.queue.selectorQueue</code>.</p><p>The entry element configures the name that will be used to bind the queue to JNDI.
            This is a mandatory element and the queue can contain multiple of these to bind the same
            queue to different names.</p><p>The selector element defines what JMS message selector the predefined queue will have.
            Only messages that match the selector will be added to the queue. This is an optional
            element with a default of null when omitted.</p><p>The durable element specifies whether the queue will be persisted. This again is
            optional and defaults to true if omitted.</p><p>Secondly a queue can be predefined at a core level in the <code class="literal">hornetq-configuration.xml</code> file. The following is an example.</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;queues&gt;
   &lt;queue name="jms.queue.selectorQueue"&gt;
      &lt;address&gt;jms.queue.selectorQueue&lt;/address&gt;
      &lt;filter string="color='red'"/&gt;
      &lt;durable&gt;true&lt;/durable&gt;
    &lt;/queue&gt;
&lt;/queues&gt;</pre><p>This is very similar to the JMS configuration, with 3 real differences which
            are.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>The name attribute of queue is the actual name used for the queue with no
                    naming convention as in JMS.</p></li><li><p>The address element defines what address is used for routing messages.</p></li><li><p>There is no entry element.</p></li><li><p>The filter uses the <span class="emphasis"><em>Core filter syntax</em></span> (described in
                        <a class="xref" href="#filter-expressions" title="Chapter 14. Filter Expressions">Chapter 14, <i>Filter Expressions</i></a>), <span class="emphasis"><em>not</em></span> the JMS
                    selector syntax.</p></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5406"/>25.2. Using the API</h2></div></div></div><p>Queues can also be created using the core API or the management API.</p><p>For the core API, queues can be created via the <code class="literal">org.hornetq.api.core.client.ClientSession</code> interface. There are multiple
                <code class="literal">createQueue</code> methods that support setting all of the previously
            mentioned attributes. There is one extra attribute that can be set via this API which is
                <code class="literal">temporary</code>. setting this to true means that the queue will be
            deleted once the session is disconnected.</p><p>Take a look at <a class="xref" href="#management" title="Chapter 30. Management">Chapter 30, <i>Management</i></a> for a description of the management API
            for creating queues.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="queue-attributes.address-settings"/>25.3. Configuring Queues Via Address Settings</h2></div></div></div><p>There are some attributes that are defined against an address wildcard rather than a
            specific queue. Here an example of an <code class="literal">address-setting</code> entry that
            would be found in the <code class="literal">hornetq-configuration.xml</code> file.</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;address-settings&gt;
   &lt;address-setting match="jms.queue.exampleQueue"&gt;
      &lt;dead-letter-address&gt;jms.queue.deadLetterQueue&lt;/dead-letter-address&gt;
      &lt;max-delivery-attempts&gt;3&lt;/max-delivery-attempts&gt;
      &lt;redelivery-delay&gt;5000&lt;/redelivery-delay&gt;
      &lt;expiry-address&gt;jms.queue.expiryQueue&lt;/expiry-address&gt;
      &lt;last-value-queue&gt;true&lt;/last-value-queue&gt;
      &lt;max-size-bytes&gt;100000&lt;/max-size-bytes&gt;
      &lt;page-size-bytes&gt;20000&lt;/page-size-bytes&gt;
      &lt;redistribution-delay&gt;0&lt;/redistribution-delay&gt;
      &lt;send-to-dla-on-no-route&gt;true&lt;/send-to-dla-on-no-route&gt;
      &lt;address-full-policy&gt;PAGE&lt;/address-full-policy&gt;
   &lt;/address-setting&gt;
&lt;/address-settings&gt;</pre><p>The idea with address settings, is you can provide a block of settings which will be
            applied against any addresses that match the string in the <code class="literal">match</code> attribute. In the
            above example the settings would only be applied to any addresses which exactly match
            the address <code class="literal">jms.queue.exampleQueue</code>, but you can also use wildcards to apply sets of
            configuration against many addresses. The wildcard syntax used is described <a class="link" href="#wildcard-syntax" title="Chapter 13. Understanding the HornetQ Wildcard Syntax">here</a>.</p><p>For example, if you used the <code class="literal">match</code> string <code class="literal">jms.queue.#</code> the settings would be applied
        to all addresses which start with <code class="literal">jms.queue.</code> which would be all JMS queues.</p><p>The meaning of the specific settings are explained fully throughout the user manual, however here is a brief
            description with a link to the appropriate chapter if available. </p><p><code class="literal">max-delivery-attempts</code> defines how many time a cancelled message can
            be redelivered before sending to the <code class="literal">dead-letter-address</code>. A full
            explanation can be found <a class="link" href="#undelivered-messages.configuring" title="21.2.1. Configuring Dead Letter Addresses">here</a>.</p><p><code class="literal">redelivery-delay</code> defines how long to wait before attempting
            redelivery of a cancelled message. see <a class="link" href="#undelivered-messages.delay" title="21.1.1. Configuring Delayed Redelivery">here</a>.</p><p><code class="literal">expiry-address</code> defines where to send a message that has expired.
            see <a class="link" href="#message-expiry.configuring" title="22.2. Configuring Expiry Addresses">here</a>.</p><p><code class="literal">expiry-delay</code> defines the expiration time that will be used for messages which are using
            the default expiration time (i.e. 0). For example, if <code class="literal">expiry-delay</code> is set to "10" and a
            message which is using the default expiration time (i.e. 0) arrives then its expiration time of "0" will be
            changed to "10." However, if a message which is using an expiration time of "20" arrives then its expiration
            time will remain unchanged. Setting <code class="literal">expiry-delay</code> to "-1" will disable this feature. The
            default is "-1".</p><p><code class="literal">last-value-queue</code> defines whether a queue only uses last values or
            not. see <a class="link" href="#last-value-queues" title="Chapter 27. Last-Value Queues">here</a>.</p><p><code class="literal">max-size-bytes</code> and <code class="literal">page-size-bytes</code> are used to
            set paging on an address. This is explained <a class="link" href="#paging" title="Chapter 24. Paging">here</a>.</p><p><code class="literal">redistribution-delay</code> defines how long to wait when the last
            consumer is closed on a queue before redistributing any messages. see <a class="link" href="#clusters" title="Chapter 38. Clusters">here</a>.</p><p><code class="literal">send-to-dla-on-no-route</code>. If a message is sent to an address, but the server does not route it to any queues,
        for example, there might be no queues bound to that address, or none of the queues have filters that match, then normally that message
        would be discarded. However if this parameter is set to true for that address, if the message is not routed to any queues it will instead
        be sent to the dead letter address (DLA) for that address, if it exists.</p><p><code class="literal">address-full-policy</code>. This attribute can have one of the following values: PAGE, DROP, FAIL or BLOCK and determines what happens when
            an address where <code class="literal">max-size-bytes</code> is specified becomes full. The default value is PAGE. If the value is PAGE then further messages will be paged to disk.
            If the value is DROP then further messages will be silently dropped.
            If the value is FAIL then further messages will be dropped and an exception will be thrown on the client-side.
            If the value is BLOCK then client message producers will block when they try and send further messages.
        
        See the following chapters for more info <a class="xref" href="#flow-control" title="Chapter 19. Flow Control">Chapter 19, <i>Flow Control</i></a>, <a class="xref" href="#paging" title="Chapter 24. Paging">Chapter 24, <i>Paging</i></a>.
        </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="scheduled-messages"/>Chapter 26. Scheduled Messages</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e5560">26.1. Scheduled Delivery Property</a></span></dt><dt><span class="section"><a href="#d0e5580">26.2. Example</a></span></dt></dl></div><p>Scheduled messages differ from normal messages in that they won't be delivered until a
      specified time in the future, at the earliest.</p><p>To do this, a special property is set on the message before sending it.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5560"/>26.1. Scheduled Delivery Property</h2></div></div></div><p>The property name used to identify a scheduled message is <code class="literal">"_HQ_SCHED_DELIVERY"</code> (or the constant <code class="literal">Message.HDR_SCHEDULED_DELIVERY_TIME</code>).</p><p>The specified value must be a positive <code class="literal">long</code> corresponding to the time the
         message must be delivered (in milliseconds). An example of sending a scheduled message
         using the JMS API is as follows.</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
TextMessage message = session.createTextMessage("This is a scheduled message message which will be delivered in 5 sec.");
message.setLongProperty("_HQ_SCHED_DELIVERY", System.currentTimeMillis() + 5000);
producer.send(message);

...

// message will not be received immediately but 5 seconds later
TextMessage messageReceived = (TextMessage) consumer.receive();</pre><p>Scheduled messages can also be sent using the core API, by setting the same property on
         the core message before sending.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5580"/>26.2. Example</h2></div></div></div><p>See <a class="xref" href="#examples.scheduled-message" title="11.1.64. Scheduled Message">Section 11.1.64, “Scheduled Message”</a> for an example which shows how
         scheduled messages can be used with JMS.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="last-value-queues"/>Chapter 27. Last-Value Queues</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e5611">27.1. Configuring Last-Value Queues</a></span></dt><dt><span class="section"><a href="#d0e5625">27.2. Using Last-Value Property</a></span></dt><dt><span class="section"><a href="#d0e5640">27.3. Example</a></span></dt></dl></div><p>Last-Value queues are special queues which discard any messages when a newer message with
      the same value for a well-defined Last-Value property is put in the queue. In other words, a
      Last-Value queue only retains the last value.</p><p>A typical example for Last-Value queue is for stock prices, where you are only interested
      by the latest value for a particular stock.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5611"/>27.1. Configuring Last-Value Queues</h2></div></div></div><p>Last-value queues are defined in the address-setting configuration:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;address-setting match="jms.queue.lastValueQueue"&gt;
   &lt;last-value-queue&gt;true&lt;/last-value-queue&gt;
&lt;/address-setting&gt;</pre><p>By default, <code class="literal">last-value-queue</code> is false. Address wildcards can be used
         to configure Last-Value queues for a set of addresses (see <a class="xref" href="#wildcard-syntax" title="Chapter 13. Understanding the HornetQ Wildcard Syntax">Chapter 13, <i>Understanding the HornetQ Wildcard Syntax</i></a>).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5625"/>27.2. Using Last-Value Property</h2></div></div></div><p>The property name used to identify the last value is <code class="literal">"_HQ_LVQ_NAME"</code>
         (or the constant <code class="literal">Message.HDR_LAST_VALUE_NAME</code> from the Core API).</p><p>For example, if two messages with the same value for the Last-Value property are sent to
         a Last-Value queue, only the latest message will be kept in the queue:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
// send 1st message with Last-Value property set to STOCK_NAME
TextMessage message = session.createTextMessage("1st message with Last-Value property set");
message.setStringProperty("_HQ_LVQ_NAME", "STOCK_NAME");
producer.send(message);

// send 2nd message with Last-Value property set to STOCK_NAME             
message = session.createTextMessage("2nd message with Last-Value property set");
message.setStringProperty("_HQ_LVQ_NAME", "STOCK_NAME");
producer.send(message);
       
...
       
// only the 2nd message will be received: it is the latest with 
// the Last-Value property set
TextMessage messageReceived = (TextMessage)messageConsumer.receive(5000);
System.out.format("Received message: %s\n", messageReceived.getText());</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5640"/>27.3. Example</h2></div></div></div><p>See <a class="xref" href="#examples.last-value-queue" title="11.1.37. Last-Value Queue">Section 11.1.37, “Last-Value Queue”</a> for an example which shows how last
         value queues are configured and used with JMS.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="message-grouping"/>Chapter 28. Message Grouping</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e5688">28.1. Using Core API</a></span></dt><dt><span class="section"><a href="#message-grouping.jmsconfigure">28.2. Using JMS</a></span></dt><dt><span class="section"><a href="#d0e5738">28.3. Example</a></span></dt><dt><span class="section"><a href="#d0e5745">28.4. Example</a></span></dt><dt><span class="section"><a href="#d0e5752">28.5.  Clustered Grouping</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5782">28.5.1. Clustered Grouping Best Practices</a></span></dt><dt><span class="section"><a href="#d0e5797">28.5.2. Clustered Grouping Example</a></span></dt></dl></dd></dl></div><p>Message groups are sets of messages that have the following characteristics:</p><div class="itemizedlist"><ul><li><p>Messages in a message group share the same group id, i.e. they have same group
            identifier property (<code class="literal">JMSXGroupID</code> for JMS, <code class="literal">_HQ_GROUP_ID</code> for HornetQ Core API).</p></li><li><p>Messages in a message group are always consumed by the same consumer, even if there
            are many consumers on a queue. They pin all messages with the same group id to the same
            consumer. If that consumer closes another consumer is chosen and will receive all
            messages with the same group id.</p></li></ul></div><p>Message groups are useful when you want all messages for a certain value of the property to
      be processed serially by the same consumer.</p><p>An example might be orders for a certain stock. You may want orders for any particular
      stock to be processed serially by the same consumer. To do this you can create a pool of
      consumers (perhaps one for each stock, but less will work too), then set the stock name as the
      value of the _HQ_GROUP_ID property.</p><p>This will ensure that all messages for a particular stock will always be processed by the
      same consumer.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5688"/>28.1. Using Core API</h2></div></div></div><p>The property name used to identify the message group is <code class="literal">"_HQ_GROUP_ID"</code> (or the constant <code class="literal">MessageImpl.HDR_GROUP_ID</code>). Alternatively, you can set <code class="literal">autogroup</code> to true on the <code class="literal">SessionFactory</code> which will pick a
         random unique id. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="message-grouping.jmsconfigure"/>28.2. Using JMS</h2></div></div></div><p>The property name used to identify the message group is <code class="literal">JMSXGroupID</code>.</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
 // send 2 messages in the same group to ensure the same
 // consumer will receive both
 Message message = ...
 message.setStringProperty("JMSXGroupID", "Group-0");
 producer.send(message);

 message = ...
 message.setStringProperty("JMSXGroupID", "Group-0");
 producer.send(message);</pre><p>Alternatively, you can set <code class="literal">autogroup</code> to true on the <code class="literal">HornetQConnectonFactory</code> which will pick a random unique id. This can also be
         set in the <code class="literal">hornetq-jms.xml</code> file like this:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;connection-factory name="ConnectionFactory"&gt;
   &lt;connectors&gt;
      &lt;connector-ref connector-name="netty-connector"/&gt;
   &lt;/connectors&gt;
   &lt;entries&gt;
      &lt;entry name="ConnectionFactory"/&gt;
   &lt;/entries&gt;
   &lt;autogroup&gt;true&lt;/autogroup&gt;
&lt;/connection-factory&gt;</pre><p>Alternatively you can set the group id via the connection factory. All messages sent
         with producers created via this connection factory will set the <code class="literal">JMSXGroupID</code> to the specified value on all messages sent. To configure the
         group id set it on the connection factory in the <code class="literal">hornetq-jms.xml</code> config
         file as follows
         </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;connection-factory name="ConnectionFactory"&gt;
   &lt;connectors&gt;
      &lt;connector-ref connector-name="netty-connector"/&gt;
   &lt;/connectors&gt;
   &lt;entries&gt;
      &lt;entry name="ConnectionFactory"/&gt;
   &lt;/entries&gt;
   &lt;group-id&gt;Group-0&lt;/group-id&gt;
&lt;/connection-factory&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5738"/>28.3. Example</h2></div></div></div><p>See <a class="xref" href="#examples.message-group" title="11.1.41. Message Group">Section 11.1.41, “Message Group”</a> for an example which shows how message
         groups are configured and used with JMS.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5745"/>28.4. Example</h2></div></div></div><p>See <a class="xref" href="#examples.message-group2" title="11.1.42. Message Group">Section 11.1.42, “Message Group”</a> for an example which shows how message
         groups are configured via a connection factory.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5752"/>28.5.  Clustered Grouping</h2></div></div></div><p>Using message groups in a cluster is a bit more complex. This is because messages with a
         particular group id can arrive on any node so each node needs to know about which group
         id's are bound to which consumer on which node. The consumer handling messages for a
         particular group id may be on a different node of the cluster, so each node needs to know
         this information so it can route the message correctly to the node which has that consumer. </p><p>To solve this there is the notion of a grouping handler. Each node will have its own
         grouping handler and when a messages is sent with a group id assigned, the handlers will
         decide between them which route the message should take.</p><p><a id="message-grouping.type"/>There are 2 types of handlers; Local and Remote. Each cluster should choose 1 node to
         have a local grouping handler and all the other nodes should have remote handlers- it's the
         local handler that actually makes the decision as to what route should be used, all the
         other remote handlers converse with this. Here is a sample config for both types of
         handler, this should be configured in the <span class="italic">hornetq-configuration.xml</span>
         file.</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;grouping-handler name="my-grouping-handler"&gt;
   &lt;type&gt;LOCAL&lt;/type&gt;
   &lt;address&gt;jms&lt;/address&gt;
   &lt;timeout&gt;5000&lt;/timeout&gt;
&lt;/grouping-handler&gt;

&lt;grouping-handler name="my-grouping-handler"&gt;
   &lt;type&gt;REMOTE&lt;/type&gt;
   &lt;address&gt;jms&lt;/address&gt;
   &lt;timeout&gt;5000&lt;/timeout&gt;
&lt;/grouping-handler&gt;</pre><p><a id="message-grouping.address"/>The <span class="italic">address</span> attribute refers to a
      <a class="link" href="#clusters.address">cluster connection and the address it uses</a>,
      refer to the clustering section on how to configure clusters. The
            <span class="italic">timeout</span> attribute referees to how long to wait for a
         decision to be made, an exception will be thrown during the send if this timeout is
         reached, this ensures that strict ordering is kept.</p><p>The decision as to where a message should be routed to is initially proposed by the node
         that receives the message. The node will pick a suitable route as per the normal clustered
         routing conditions, i.e. round robin available queues, use a local queue first and choose a
         queue that has a consumer. If the proposal is accepted by the grouping handlers the node
         will route messages to this queue from that point on, if rejected an alternative route will
         be offered and the node will again route to that queue indefinitely. All other nodes will
         also route to the queue chosen at proposal time. Once the message arrives at the queue then
         normal single server message group semantics take over and the message is pinned to a
         consumer on that queue.</p><p>You may have noticed that there is a single point of failure with the single local
         handler. If this node crashes then no decisions will be able to be made. Any messages sent
         will be not be delivered and an exception thrown. To avoid this happening Local Handlers
         can be replicated on another backup node. Simple create your back up node and configure it
         with the same Local handler.</p><p/><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5782"/>28.5.1. Clustered Grouping Best Practices</h3></div></div></div><p>Some best practices should be followed when using clustered grouping:</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>Make sure your consumers are distributed evenly across the different nodes
                     if possible. This is only an issue if you are creating and closing consumers
                     regularly. Since messages are always routed to the same queue once pinned,
                     removing a consumer from this queue may leave it with no consumers meaning the
                     queue will just keep receiving the messages. Avoid closing consumers or make
                     sure that you always have plenty of consumers, i.e., if you have 3 nodes have 3
                     consumers.</p></li><li><p>Use durable queues if possible. If queues are removed once a group is bound
                     to it, then it is possible that other nodes may still try to route messages to
                     it. This can be avoided by making sure that the queue is deleted by the session
                     that is sending the messages. This means that when the next message is sent it
                     is sent to the node where the queue was deleted meaning a new proposal can
                     successfully take place. Alternatively you could just start using a different
                     group id.</p></li><li><p>Always make sure that the node that has the Local Grouping Handler is
                     replicated. These means that on failover grouping will still occur.</p></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e5797"/>28.5.2. Clustered Grouping Example</h3></div></div></div><p>See <a class="xref" href="#examples.clustered.grouping" title="11.1.10. Clustered Grouping">Section 11.1.10, “Clustered Grouping”</a> for an example of how to configure
            message groups with a HornetQ cluster</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="pre-acknowledge"/>Chapter 29. Extra Acknowledge Modes</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#pre-acknowledge.configure">29.1. Using PRE_ACKNOWLEDGE</a></span></dt><dt><span class="section"><a href="#individual-ack">29.2. Individual Acknowledge</a></span></dt><dt><span class="section"><a href="#d0e5917">29.3. Example</a></span></dt></dl></div><p>JMS specifies 3 acknowledgement modes:</p><div class="itemizedlist"><ul><li><p><code class="literal">AUTO_ACKNOWLEDGE</code></p></li><li><p><code class="literal">CLIENT_ACKNOWLEDGE</code></p></li><li><p><code class="literal">DUPS_OK_ACKNOWLEDGE</code></p></li></ul></div><p>HornetQ supports two additional modes: <code class="literal">PRE_ACKNOWLEDGE</code> and <code class="literal">INDIVIDUAL_ACKNOWLEDGE</code></p><p>In some cases you can afford
        to lose messages in event of failure, so it would make sense to acknowledge the message on the
        server <span class="emphasis"><em>before</em></span> delivering it to the client.</p><p>This extra mode is supported by HornetQ and will call it
        <span class="emphasis"><em>pre-acknowledge</em></span> mode.</p><p>The disadvantage of acknowledging on the server before delivery is that the message will be
        lost if the system crashes <span class="emphasis"><em>after</em></span> acknowledging the message on the server
        but <span class="emphasis"><em>before</em></span> it is delivered to the client. In that case, the message is
        lost and will not be recovered when the system restart.</p><p>Depending on your messaging case, <code class="literal">pre-acknowledgement</code> mode can avoid
        extra network traffic and CPU at the cost of coping with message loss.</p><p>An example of a use case for pre-acknowledgement is for stock price update messages. With
        these messages it might be reasonable to lose a message in event of crash, since the next
        price update message will arrive soon, overriding the previous price. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Please note, that if you use pre-acknowledge mode, then you will lose transactional
            semantics for messages being consumed, since clearly they are being acknowledged first on
            the server, not when you commit the transaction. This may be stating the obvious but we
            like to be clear on these things to avoid confusion!</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="pre-acknowledge.configure"/>29.1. Using PRE_ACKNOWLEDGE</h2></div></div></div><p>This can be configured in the <code class="literal">hornetq-jms.xml</code> file on the <code class="literal">connection factory</code> like this:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;connection-factory name="ConnectionFactory"&gt;
   &lt;connectors&gt;
      &lt;connector-ref connector-name="netty-connector"/&gt;
   &lt;/connectors&gt;
   &lt;entries&gt;
      &lt;entry name="ConnectionFactory"/&gt;
   &lt;/entries&gt;
   &lt;pre-acknowledge&gt;true&lt;/pre-acknowledge&gt;
&lt;/connection-factory&gt;</pre><p>Alternatively, to use pre-acknowledgement mode using the JMS API, create a JMS Session
            with the <code class="literal">HornetQSession.PRE_ACKNOWLEDGE</code> constant.</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
// messages will be acknowledge on the server *before* being delivered to the client
Session session = connection.createSession(false, HornetQJMSConstants.PRE_ACKNOWLEDGE);</pre><p>Or you can set pre-acknowledge directly on the <code class="literal">HornetQConnectionFactory</code> instance using the setter method.</p><p>To use pre-acknowledgement mode using the core API you can set it directly on the
            <code class="literal">ClientSessionFactory</code> instance using the setter method.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="individual-ack"/>29.2. Individual Acknowledge</h2></div></div></div><p>A valid use-case for individual acknowledgement would be when you need to have your own scheduling and you don't know when your message processing will be finished. You should prefer having one consumer per thread worker
            but this is not possible in some circumstances depending on how complex is your processing. For that you can use the individual Acknowledgement. </p><p>You basically setup Individual ACK by creating a session with the acknowledge mode with <code class="literal">HornetQJMSConstants.INDIVIDUAL_ACKNOWLEDGE</code>. Individual ACK inherits all the semantics from Client Acknowledge,
            with the exception the message is individually acked.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Please note, that to avoid confusion on MDB processing, Individual ACKNOWLEDGE is not supported through MDBs (or the inbound resource adapter). this is because you have to finish the process of your message inside the MDB.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5917"/>29.3. Example</h2></div></div></div><p>See <a class="xref" href="#examples.pre-acknowledge" title="11.1.49. Pre-Acknowledge">Section 11.1.49, “Pre-Acknowledge”</a> for an example which shows how to use
            pre-acknowledgement mode with JMS.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="management"/>Chapter 30. Management</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e5969">30.1. The Management API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6018">30.1.1. Core Management API</a></span></dt><dt><span class="section"><a href="#d0e6509">30.1.2. JMS Management API</a></span></dt></dl></dd><dt><span class="section"><a href="#management.jmx">30.2. Using Management Via JMX</a></span></dt><dd><dl><dt><span class="section"><a href="#management.jmx.configuration">30.2.1. Configuring JMX</a></span></dt><dt><span class="section"><a href="#d0e6927">30.2.2. Example</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6934">30.3. Using Management Via Core API</a></span></dt><dd><dl><dt><span class="section"><a href="#management.core.configuration">30.3.1. Configuring Core Management</a></span></dt></dl></dd><dt><span class="section"><a href="#management.jms">30.4. Using Management Via JMS</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7112">30.4.1. Configuring JMS Management</a></span></dt><dt><span class="section"><a href="#d0e7119">30.4.2. Example</a></span></dt></dl></dd><dt><span class="section"><a href="#management.notifications">30.5. Management Notifications</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7146">30.5.1. JMX Notifications</a></span></dt><dt><span class="section"><a href="#d0e7170">30.5.2. Core Messages Notifications</a></span></dt><dt><span class="section"><a href="#d0e7199">30.5.3. JMS Messages Notifications</a></span></dt><dt><span class="section"><a href="#d0e7223">30.5.4. Example</a></span></dt><dt><span class="section"><a href="#d0e7233">30.5.5. Notification Types and Headers</a></span></dt></dl></dd><dt><span class="section"><a href="#management.message-counters">30.6. Message Counters</a></span></dt><dd><dl><dt><span class="section"><a href="#configuring.message.counters">30.6.1. Configuring Message Counters</a></span></dt><dt><span class="section"><a href="#d0e7638">30.6.2. Example</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e7648">30.7. Administering HornetQ Resources Using The JBoss AS Admin Console</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7657">30.7.1. JMS Queues</a></span></dt><dt><span class="section"><a href="#d0e7681">30.7.2. JMS Topics</a></span></dt><dt><span class="section"><a href="#d0e7686">30.7.3. JMS Connection Factories</a></span></dt></dl></dd></dl></div><p>HornetQ has an extensive management API that allows a user to modify a server
      configuration, create new resources (e.g. JMS queues and topics), inspect these resources
      (e.g. how many messages are currently held in a queue) and interact with it (e.g. to remove
      messages from a queue). All the operations allows a client to <span class="emphasis"><em>manage</em></span>
      HornetQ. It also allows clients to subscribe to management notifications.</p><p>There are 3 ways to manage HornetQ:</p><div class="itemizedlist"><ul><li><p>Using JMX -- JMX is the standard way to manage Java applications</p></li><li><p>Using the core API -- management operations are sent to HornetQ server using
               <span class="emphasis"><em>core messages</em></span></p></li><li><p>Using the JMS API -- management operations are sent to HornetQ server using
               <span class="emphasis"><em>JMS messages</em></span></p></li></ul></div><p>Although there are 3 different ways to manage HornetQ each API supports the same
      functionality. If it is possible to manage a resource using JMX it is also possible to achieve
      the same result using Core messages or JMS messages.</p><p>This choice depends on your requirements, your application settings and your environment to
      decide which way suits you best.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5969"/>30.1. The Management API</h2></div></div></div><p>Regardless of the way you <span class="emphasis"><em>invoke</em></span> management operations, the
         management API is the same.</p><p>For each <span class="emphasis"><em>managed resource</em></span>, there exists a Java interface describing
         what can be invoked for this type of resource.</p><p>HornetQ exposes its managed resources in 2 packages:</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Core</em></span> resources are located in the <code class="literal">org.hornetq.api.core.management</code> package</p></li><li><p><span class="emphasis"><em>JMS</em></span> resources are located in the <code class="literal">org.hornetq.api.jms.management</code> package</p></li></ul></div><p>The way to invoke a <span class="emphasis"><em>management operations</em></span> depends whether JMX, core
         messages, or JMS messages are used.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>A few management operations requires a <code class="literal">filter</code> parameter to chose
            which messages are involved by the operation. Passing <code class="literal">null</code> or an
            empty string means that the management operation will be performed on <span class="emphasis"><em>all
               messages</em></span>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6018"/>30.1.1. Core Management API</h3></div></div></div><p>HornetQ defines a core management API to manage core resources. For full details of
            the API please consult the javadoc. In summary:</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="management.core.server"/>30.1.1.1. Core Server Management</h4></div></div></div><div class="itemizedlist"><ul><li><p>Listing, creating, deploying and destroying queues</p><p>A list of deployed core queues can be retrieved using the <code class="literal">getQueueNames()</code> method.</p><p>Core queues can be created or destroyed using the management operations
                        <code class="literal">createQueue()</code> or <code class="literal">deployQueue()</code> or
                        <code class="literal">destroyQueue()</code>)on the <code class="literal">HornetQServerControl</code> (with the ObjectName <code class="literal">org.hornetq:module=Core,type=Server</code> or the resource name <code class="literal">core.server</code>)</p><p><code class="literal">createQueue</code> will fail if the queue already exists while
                        <code class="literal">deployQueue</code> will do nothing.</p></li><li><p>Pausing and resuming Queues</p><p>The <code class="literal">QueueControl</code> can pause and resume the underlying
                     queue. When a queue is paused, it will receive messages but will not deliver
                     them. When it's resumed, it'll begin delivering the queued messages, if any.
                  </p></li><li><p>Listing and closing remote connections</p><p>Client's remote addresses can be retrieved using <code class="literal">listRemoteAddresses()</code>. It is also possible to close the
                     connections associated with a remote address using the <code class="literal">closeConnectionsForAddress()</code> method.</p><p>Alternatively, connection IDs can be listed using <code class="literal">listConnectionIDs()</code> and all the sessions for a given connection
                     ID can be listed using <code class="literal">listSessions()</code>.</p></li><li><p>Transaction heuristic operations</p><p>In case of a server crash, when the server restarts, it it possible that
                     some transaction requires manual intervention. The <code class="literal">listPreparedTransactions()</code> method lists the transactions which
                     are in the prepared states (the transactions are represented as opaque Base64
                     Strings.) To commit or rollback a given prepared transaction, the <code class="literal">commitPreparedTransaction()</code> or <code class="literal">rollbackPreparedTransaction()</code> method can be used to resolve
                     heuristic transactions. Heuristically completed transactions can be listed
                     using the <code class="literal">listHeuristicCommittedTransactions()</code> and <code class="literal">listHeuristicRolledBackTransactions</code> methods.</p></li><li><p>Enabling and resetting Message counters</p><p>Message counters can be enabled or disabled using the <code class="literal">enableMessageCounters()</code> or <code class="literal">disableMessageCounters()</code> method. To reset message counters, it is
                     possible to invoke <code class="literal">resetAllMessageCounters()</code> and <code class="literal">resetAllMessageCounterHistories()</code> methods.</p></li><li><p>Retrieving the server configuration and attributes</p><p>The <code class="literal">HornetQServerControl</code> exposes HornetQ server
                     configuration through all its attributes (e.g. <code class="literal">getVersion()</code>
                     method to retrieve the server's version, etc.)</p></li><li><p>Listing, creating and destroying Core bridges and diverts</p><p>A list of deployed core bridges (resp. diverts) can be retrieved using the <code class="literal">getBridgeNames()</code> (resp. <code class="literal">getDivertNames()</code>) method.</p><p>Core bridges (resp. diverts) can be created or destroyed using the management operations
                        <code class="literal">createBridge()</code> and <code class="literal">destroyBridge()</code> 
                        (resp. <code class="literal">createDivert()</code> and <code class="literal">destroyDivert()</code>) on the <code class="literal">HornetQServerControl</code> (with the ObjectName <code class="literal">org.hornetq:module=Core,type=Server</code> or the resource name <code class="literal">core.server</code>).</p></li><li><p>It is possible to stop the server and force failover to occur with any currently attached clients.</p><p>to do this use the <code class="literal">forceFailover()</code> on the <code class="literal">HornetQServerControl</code> (with the ObjectName <code class="literal">org.hornetq:module=Core,type=Server</code> or the resource name <code class="literal">core.server</code>) </p><p>
                       </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2>Since this method actually stops the server you will probably receive some sort of error
                       depending on which management service you use to call it.</div><p>
                   </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6193"/>30.1.1.2. Core Address Management</h4></div></div></div><p>Core addresses can be managed using the <code class="literal">AddressControl</code> class
               (with the ObjectName <code class="literal">org.hornetq:module=Core,type=Address,name="&lt;the
                  address name&gt;"</code> or the resource name <code class="literal">core.address.&lt;the
                  address name&gt;</code>). </p><div class="itemizedlist"><ul><li><p>Modifying roles and permissions for an address</p><p>You can add or remove roles associated to a queue using the <code class="literal">addRole()</code> or <code class="literal">removeRole()</code> methods. You can
                     list all the roles associated to the queue with the <code class="literal">getRoles()</code> method</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6222"/>30.1.1.3. Core Queue Management</h4></div></div></div><p>The bulk of the core management API deals with core queues. The <code class="literal">QueueControl</code> class defines the Core queue management operations (with
               the ObjectName <code class="literal">org.hornetq:module=Core,type=Queue,address="&lt;the bound
                  address&gt;",name="&lt;the queue name&gt;"</code> or the resource name <code class="literal">core.queue.&lt;the queue name&gt;</code>).</p><p>Most of the management operations on queues take either a single message ID (e.g.
               to remove a single message) or a filter (e.g. to expire all messages with a given
               property.)</p><div class="itemizedlist"><ul><li><p>Expiring, sending to a dead letter address and moving messages</p><p>Messages can be expired from a queue by using the <code class="literal">expireMessages()</code> method. If an expiry address is defined,
                     messages will be sent to it, otherwise they are discarded. The queue's
                     expiry address can be set with the <code class="literal">setExpiryAddress()</code>
                     method.</p><p>Messages can also be sent to a dead letter address with the <code class="literal">sendMessagesToDeadLetterAddress()</code> method. It returns the number
                     of messages which are sent to the dead letter address. If a dead letter address
                     is not defined, message are removed from the queue and discarded. The queue's
                     dead letter address can be set with the <code class="literal">setDeadLetterAddress()</code> method.</p><p>Messages can also be moved from a queue to another queue by using the
                        <code class="literal">moveMessages()</code> method.</p></li><li><p>Listing and removing messages</p><p>Messages can be listed from a queue by using the <code class="literal">listMessages()</code> method which returns an array of <code class="literal">Map</code>, one <code class="literal">Map</code> for each message.</p><p>Messages can also be removed from the queue by using the <code class="literal">removeMessages()</code> method which returns a <code class="literal">boolean</code> for the single message ID variant or the number of
                     removed messages for the filter variant. The <code class="literal">removeMessages()</code> method takes a <code class="literal">filter</code>
                     argument to remove only filtered messages. Setting the filter to an empty
                     string will in effect remove all messages.</p></li><li><p>Counting messages</p><p>The number of messages in a queue is returned by the <code class="literal">getMessageCount()</code> method. Alternatively, the <code class="literal">countMessages()</code> will return the number of messages in the queue
                     which <span class="emphasis"><em>match a given filter</em></span></p></li><li><p>Changing message priority</p><p>The message priority can be changed by using the <code class="literal">changeMessagesPriority()</code> method which returns a <code class="literal">boolean</code> for the single message ID variant or the number of
                     updated messages for the filter variant.</p></li><li><p>Message counters</p><p>Message counters can be listed for a queue with the <code class="literal">listMessageCounter()</code> and <code class="literal">listMessageCounterHistory()</code> methods (see <a class="xref" href="#management.message-counters" title="30.6. Message Counters">Section 30.6, “Message Counters”</a>). The message counters can also be
                     reset for a single queue using the <code class="literal">resetMessageCounter()</code>
                     method.</p></li><li><p>Retrieving the queue attributes</p><p>The <code class="literal">QueueControl</code> exposes Core queue settings through its
                     attributes (e.g. <code class="literal">getFilter()</code> to retrieve the queue's filter
                     if it was created with one, <code class="literal">isDurable()</code> to know whether the
                     queue is durable or not, etc.)</p></li><li><p>Pausing and resuming Queues</p><p>The <code class="literal">QueueControl</code> can pause and resume the underlying
                     queue. When a queue is paused, it will receive messages but will not deliver
                     them. When it's resume, it'll begin delivering the queued messages, if any.
                  </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6353"/>30.1.1.4. Other Core Resources Management</h4></div></div></div><p>HornetQ allows to start and stop its remote resources (acceptors, diverts,
               bridges, etc.) so that a server can be taken off line for a given period of time
               without stopping it completely (e.g. if other management operations must be performed
               such as resolving heuristic transactions). These resources are:</p><div class="itemizedlist"><ul><li><p>Acceptors</p><p>They can be started or stopped using the <code class="literal">start()</code> or.
                        <code class="literal">stop()</code> method on the <code class="literal">AcceptorControl</code>
                     class (with the ObjectName <code class="literal">org.hornetq:module=Core,type=Acceptor,name="&lt;the acceptor
                        name&gt;"</code> or the resource name <code class="literal">core.acceptor.&lt;the
                        address name&gt;</code>). The acceptors parameters can be retrieved using
                     the <code class="literal">AcceptorControl</code> attributes (see <a class="xref" href="#configuring-transports.acceptors" title="16.1. Understanding Acceptors">Section 16.1, “Understanding Acceptors”</a>)</p></li><li><p>Diverts</p><p>They can be started or stopped using the <code class="literal">start()</code> or
                        <code class="literal">stop()</code> method on the <code class="literal">DivertControl</code>
                     class (with the ObjectName <code class="literal">org.hornetq:module=Core,type=Divert,name=&lt;the divert name&gt;</code>
                     or the resource name <code class="literal">core.divert.&lt;the divert name&gt;</code>).
                     Diverts parameters can be retrieved using the <code class="literal">DivertControl</code>
                     attributes (see <a class="xref" href="#diverts" title="Chapter 35. Diverting and Splitting Message Flows">Chapter 35, <i>Diverting and Splitting Message Flows</i></a>)</p></li><li><p>Bridges</p><p>They can be started or stopped using the <code class="literal">start()</code> (resp.
                        <code class="literal">stop()</code>) method on the <code class="literal">BridgeControl</code>
                     class (with the ObjectName <code class="literal">org.hornetq:module=Core,type=Bridge,name="&lt;the bridge
                        name&gt;"</code> or the resource name <code class="literal">core.bridge.&lt;the bridge
                        name&gt;</code>). Bridges parameters can be retrieved using the <code class="literal">BridgeControl</code> attributes (see <a class="xref" href="#core-bridges" title="Chapter 36. Core Bridges">Chapter 36, <i>Core Bridges</i></a>)</p></li><li><p>Broadcast groups</p><p>They can be started or stopped using the <code class="literal">start()</code> or
                        <code class="literal">stop()</code> method on the <code class="literal">BroadcastGroupControl</code> class (with the ObjectName <code class="literal">org.hornetq:module=Core,type=BroadcastGroup,name="&lt;the broadcast group
                        name&gt;"</code> or the resource name <code class="literal">core.broadcastgroup.&lt;the broadcast group name&gt;</code>). Broadcast
                     groups parameters can be retrieved using the <code class="literal">BroadcastGroupControl</code> attributes (see <a class="xref" href="#clusters" title="Chapter 38. Clusters">Chapter 38, <i>Clusters</i></a>)</p></li><li><p>Discovery groups</p><p>They can be started or stopped using the <code class="literal">start()</code> or
                        <code class="literal">stop()</code> method on the <code class="literal">DiscoveryGroupControl</code> class (with the ObjectName <code class="literal">org.hornetq:module=Core,type=DiscoveryGroup,name="&lt;the discovery group
                        name&gt;"</code> or the resource name <code class="literal">core.discovery.&lt;the
                        discovery group name&gt;</code>). Discovery groups parameters can be
                     retrieved using the <code class="literal">DiscoveryGroupControl</code> attributes (see
                        <a class="xref" href="#clusters" title="Chapter 38. Clusters">Chapter 38, <i>Clusters</i></a>)</p></li><li><p>Cluster connections</p><p>They can be started or stopped using the <code class="literal">start()</code> or
                        <code class="literal">stop()</code> method on the <code class="literal">ClusterConnectionControl</code> class (with the ObjectName <code class="literal">org.hornetq:module=Core,type=ClusterConnection,name="&lt;the cluster
                        connection name&gt;"</code> or the resource name <code class="literal">core.clusterconnection.&lt;the cluster connection name&gt;</code>).
                     Cluster connections parameters can be retrieved using the <code class="literal">ClusterConnectionControl</code> attributes (see <a class="xref" href="#clusters" title="Chapter 38. Clusters">Chapter 38, <i>Clusters</i></a>)</p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6509"/>30.1.2. JMS Management API</h3></div></div></div><p>HornetQ defines a JMS Management API to manage JMS <span class="emphasis"><em>administrated
               objects</em></span> (i.e. JMS queues, topics and connection factories).</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6517"/>30.1.2.1. JMS Server Management</h4></div></div></div><p>JMS Resources (connection factories and destinations) can be created using the
                  <code class="literal">JMSServerControl</code> class (with the ObjectName <code class="literal">org.hornetq:module=JMS,type=Server</code> or the resource name <code class="literal">jms.server</code>).</p><div class="itemizedlist"><ul><li><p>Listing, creating, destroying connection factories</p><p>Names of the deployed connection factories can be retrieved by the <code class="literal">getConnectionFactoryNames()</code> method.</p><p>JMS connection factories can be created or destroyed using the <code class="literal">createConnectionFactory()</code> methods or <code class="literal">destroyConnectionFactory()</code> methods. These connection factories
                     are bound to JNDI so that JMS clients can look them up. If a graphical console
                     is used to create the connection factories, the transport parameters are
                     specified in the text field input as a comma-separated list of key=value (e.g.
                        <code class="literal">key1=10, key2="value", key3=false</code>). If there are multiple
                     transports defined, you need to enclose the key/value pairs between curly
                     braces. For example <code class="literal">{key=10}, {key=20}</code>. In that case, the
                     first <code class="literal">key</code> will be associated to the first transport
                     configuration and the second <code class="literal">key</code> will be associated to the
                     second transport configuration (see <a class="xref" href="#configuring-transports" title="Chapter 16. Configuring the Transport">Chapter 16, <i>Configuring the Transport</i></a>
                     for a list of the transport parameters)</p></li><li><p>Listing, creating, destroying queues</p><p>Names of the deployed JMS queues can be retrieved by the <code class="literal">getQueueNames()</code> method.</p><p>JMS queues can be created or destroyed using the <code class="literal">createQueue()</code> methods or <code class="literal">destroyQueue()</code>
                     methods. These queues are bound to JNDI so that JMS clients can look them
                     up</p></li><li><p>Listing, creating/destroying topics</p><p>Names of the deployed topics can be retrieved by the <code class="literal">getTopicNames()</code> method.</p><p>JMS topics can be created or destroyed using the <code class="literal">createTopic()</code> or <code class="literal">destroyTopic()</code> methods. These
                     topics are bound to JNDI so that JMS clients can look them up</p></li><li><p>Listing and closing remote connections</p><p>JMS Clients remote addresses can be retrieved using <code class="literal">listRemoteAddresses()</code>. It is also possible to close the
                     connections associated with a remote address using the <code class="literal">closeConnectionsForAddress()</code> method.</p><p>Alternatively, connection IDs can be listed using <code class="literal">listConnectionIDs()</code> and all the sessions for a given connection
                     ID can be listed using <code class="literal">listSessions()</code>.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6613"/>30.1.2.2. JMS ConnectionFactory Management</h4></div></div></div><p>JMS Connection Factories can be managed using the <code class="literal">ConnectionFactoryControl</code> class (with the ObjectName <code class="literal">org.hornetq:module=JMS,type=ConnectionFactory,name="&lt;the connection factory
                  name&gt;"</code> or the resource name <code class="literal">jms.connectionfactory.&lt;the
                  connection factory name&gt;</code>).</p><div class="itemizedlist"><ul><li><p>Retrieving connection factory attributes</p><p>The <code class="literal">ConnectionFactoryControl</code> exposes JMS
                     ConnectionFactory configuration through its attributes (e.g. <code class="literal">getConsumerWindowSize()</code> to retrieve the consumer window size for
                     flow control, <code class="literal">isBlockOnNonDurableSend()</code> to know whether the
                     producers created from the connection factory will block or not when sending
                     non-durable messages, etc.)</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6642"/>30.1.2.3. JMS Queue Management</h4></div></div></div><p>JMS queues can be managed using the <code class="literal">JMSQueueControl</code> class (with
               the ObjectName <code class="literal">org.hornetq:module=JMS,type=Queue,name="&lt;the queue
                  name&gt;"</code> or the resource name <code class="literal">jms.queue.&lt;the queue
                  name&gt;</code>). </p><p><span class="emphasis"><em>The management operations on a JMS queue are very similar to the
                  operations on a core queue. </em></span></p><div class="itemizedlist"><ul><li><p>Expiring, sending to a dead letter address and moving messages</p><p>Messages can be expired from a queue by using the <code class="literal">expireMessages()</code> method. If an expiry address is defined,
                     messages will be sent to it, otherwise they are discarded. The queue's
                     expiry address can be set with the <code class="literal">setExpiryAddress()</code>
                     method.</p><p>Messages can also be sent to a dead letter address with the <code class="literal">sendMessagesToDeadLetterAddress()</code> method. It returns the number
                     of messages which are sent to the dead letter address. If a dead letter address
                     is not defined, message are removed from the queue and discarded. The queue's
                     dead letter address can be set with the <code class="literal">setDeadLetterAddress()</code> method.</p><p>Messages can also be moved from a queue to another queue by using the
                        <code class="literal">moveMessages()</code> method.</p></li><li><p>Listing and removing messages</p><p>Messages can be listed from a queue by using the <code class="literal">listMessages()</code> method which returns an array of <code class="literal">Map</code>, one <code class="literal">Map</code> for each message.</p><p>Messages can also be removed from the queue by using the <code class="literal">removeMessages()</code> method which returns a <code class="literal">boolean</code> for the single message ID variant or the number of
                     removed messages for the filter variant. The <code class="literal">removeMessages()</code> method takes a <code class="literal">filter</code>
                     argument to remove only filtered messages. Setting the filter to an empty
                     string will in effect remove all messages.</p></li><li><p>Counting messages</p><p>The number of messages in a queue is returned by the <code class="literal">getMessageCount()</code> method. Alternatively, the <code class="literal">countMessages()</code> will return the number of messages in the queue
                     which <span class="emphasis"><em>match a given filter</em></span></p></li><li><p>Changing message priority</p><p>The message priority can be changed by using the <code class="literal">changeMessagesPriority()</code> method which returns a <code class="literal">boolean</code> for the single message ID variant or the number of
                     updated messages for the filter variant.</p></li><li><p>Message counters</p><p>Message counters can be listed for a queue with the <code class="literal">listMessageCounter()</code> and <code class="literal">listMessageCounterHistory()</code> methods (see <a class="xref" href="#management.message-counters" title="30.6. Message Counters">Section 30.6, “Message Counters”</a>)</p></li><li><p>Retrieving the queue attributes</p><p>The <code class="literal">JMSQueueControl</code> exposes JMS queue settings through
                     its attributes (e.g. <code class="literal">isTemporary()</code> to know whether the queue
                     is temporary or not, <code class="literal">isDurable()</code> to know whether the queue is
                     durable or not, etc.)</p></li><li><p>Pausing and resuming queues</p><p>The <code class="literal">JMSQueueControl</code> can pause and resume the underlying
                     queue. When the queue is paused it will continue to receive messages but will
                     not deliver them. When resumed again it will deliver the enqueued messages, if
                     any. </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6771"/>30.1.2.4. JMS Topic Management</h4></div></div></div><p>JMS Topics can be managed using the <code class="literal">TopicControl</code> class (with
               the ObjectName <code class="literal">org.hornetq:module=JMS,type=Topic,name="&lt;the topic
                  name&gt;"</code> or the resource name <code class="literal">jms.topic.&lt;the topic
                  name&gt;</code>).</p><div class="itemizedlist"><ul><li><p>Listing subscriptions and messages</p><p>JMS topics subscriptions can be listed using the <code class="literal">listAllSubscriptions()</code>, <code class="literal">listDurableSubscriptions()</code>, <code class="literal">listNonDurableSubscriptions()</code> methods. These methods return
                     arrays of <code class="literal">Object</code> representing the subscriptions information
                     (subscription name, client ID, durability, message count, etc.). It is also
                     possible to list the JMS messages for a given subscription with the <code class="literal">listMessagesForSubscription()</code> method.</p></li><li><p>Dropping subscriptions</p><p>Durable subscriptions can be dropped from the topic using the <code class="literal">dropDurableSubscription()</code> method.</p></li><li><p>Counting subscriptions messages</p><p>The <code class="literal">countMessagesForSubscription()</code> method can be used to
                     know the number of messages held for a given subscription (with an optional
                     message selector to know the number of messages matching the selector)</p></li></ul></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="management.jmx"/>30.2. Using Management Via JMX</h2></div></div></div><p>HornetQ can be managed using <a class="ulink" href="http://www.oracle.com/technetwork/java/javase/tech/javamanagement-140525.html">JMX</a>. </p><p>The management API is exposed by HornetQ using MBeans interfaces. HornetQ registers its
         resources with the domain <code class="literal">org.hornetq</code>.</p><p>For example, the <code class="literal">ObjectName</code> to manage a JMS Queue <code class="literal">exampleQueue</code> is:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
org.hornetq:module=JMS,type=Queue,name="exampleQueue"</pre><p>and the MBean is:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
org.hornetq.api.jms.management.JMSQueueControl</pre><p>The MBean's <code class="literal">ObjectName</code> are built using the helper class <code class="literal">org.hornetq.api.core.management.ObjectNameBuilder</code>. You can also use <code class="literal">jconsole</code> to find the <code class="literal">ObjectName</code> of the MBeans you want to
         manage. </p><p>Managing HornetQ using JMX is identical to management of any Java Applications using
         JMX. It can be done by reflection or by creating proxies of the MBeans.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="management.jmx.configuration"/>30.2.1. Configuring JMX</h3></div></div></div><p>By default, JMX is enabled to manage HornetQ. It can be disabled by setting <code class="literal">jmx-management-enabled</code> to <code class="literal">false</code> in <code class="literal">hornetq-configuration.xml</code>:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;!-- false to disable JMX management for HornetQ --&gt;
&lt;jmx-management-enabled&gt;false&lt;/jmx-management-enabled&gt;</pre><p>If JMX is enabled, HornetQ can be managed locally using <code class="literal">jconsole</code>.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Remote connections to JMX are not enabled by default for security reasons. Please refer
            to <a class="ulink" href="http://docs.oracle.com/javase/6/docs/technotes/guides/management/agent.html">Java Management guide</a> to configure the server for remote management (system
            properties must be set in <code class="literal">run.sh</code> or <code class="literal">run.bat</code>
            scripts).</p></div><p>By default, HornetQ server uses the JMX domain "org.hornetq". To manage several
            HornetQ servers from the <span class="emphasis"><em>same</em></span> MBeanServer, the JMX domain can be
            configured for each individual HornetQ server by setting <code class="literal">jmx-domain</code>
            in <code class="literal">hornetq-configuration.xml</code>: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;!-- use a specific JMX domain for HornetQ MBeans --&gt;
&lt;jmx-domain&gt;my.org.hornetq&lt;/jmx-domain&gt;</pre><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6911"/>30.2.1.1. MBeanServer configuration</h4></div></div></div><p>When HornetQ is run in standalone, it uses the Java Virtual Machine's <code class="literal">Platform MBeanServer</code> to register its MBeans. This is configured in
               JBoss Microcontainer Beans file (see <a class="xref" href="#server.microcontainer.configuration" title="6.7. JBoss Microcontainer Beans File">Section 6.7, “JBoss Microcontainer Beans File”</a>):</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;!-- MBeanServer --&gt;
&lt;bean name="MBeanServer" class="javax.management.MBeanServer"&gt;
   &lt;constructor factoryClass="java.lang.management.ManagementFactory"
                   factoryMethod="getPlatformMBeanServer" /&gt;
&lt;/bean&gt;</pre><p>When it is integrated in JBoss AS 5+, it uses the Application Server's own MBean
               Server so that it can be managed using AS 5's jmx-console:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;!-- MBeanServer --&gt;
&lt;bean name="MBeanServer" class="javax.management.MBeanServer"&gt;
   &lt;constructor factoryClass="org.jboss.mx.util.MBeanServerLocator"
                   factoryMethod="locateJBoss" /&gt;
&lt;/bean&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6927"/>30.2.2. Example</h3></div></div></div><p>See <a class="xref" href="#examples.jmx" title="11.1.35. JMX Management">Section 11.1.35, “JMX Management”</a> for an example which shows how to use a remote
            connection to JMX and MBean proxies to manage HornetQ.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6934"/>30.3. Using Management Via Core API</h2></div></div></div><p>The core management API in HornetQ is called by sending Core messages to a special
         address, the <span class="emphasis"><em>management address</em></span>.</p><p><span class="emphasis"><em>Management messages</em></span> are regular Core messages with well-known
         properties that the server needs to understand to interact with the management API:</p><div class="itemizedlist"><ul><li><p>The name of the managed resource</p></li><li><p>The name of the management operation</p></li><li><p>The parameters of the management operation</p></li></ul></div><p>When such a management message is sent to the management address, HornetQ server will
         handle it, extract the information, invoke the operation on the managed resources and send
         a <span class="emphasis"><em>management reply</em></span> to the management message's reply-to address
         (specified by <code class="literal">ClientMessageImpl.REPLYTO_HEADER_NAME</code>). </p><p>A <code class="literal">ClientConsumer</code> can be used to consume the management reply and
         retrieve the result of the operation (if any) stored in the reply's body. For portability,
         results are returned as a <a class="ulink" href="http://json.org">JSON</a> String rather than Java
         Serialization (the <code class="literal">org.hornetq.api.core.management.ManagementHelper</code> can
         be used to convert the JSON string to Java objects).</p><p>These steps can be simplified to make it easier to invoke management operations using
         Core messages:</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>Create a <code class="literal">ClientRequestor</code> to send messages to the management
               address and receive replies</p></li><li><p>Create a <code class="literal">ClientMessage</code></p></li><li><p>Use the helper class <code class="literal">org.hornetq.api.core.management.ManagementHelper</code> to fill the message
               with the management properties</p></li><li><p>Send the message using the <code class="literal">ClientRequestor</code></p></li><li><p>Use the helper class <code class="literal">org.hornetq.api.core.management.ManagementHelper</code> to retrieve the
               operation result from the management reply</p></li></ol></div><p>For example, to find out the number of messages in the core queue <code class="literal">exampleQueue</code>:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
ClientSession session = ...
ClientRequestor requestor = new ClientRequestor(session, "jms.queue.hornetq.management");
ClientMessage message = session.createMessage(false);
ManagementHelper.putAttribute(message, "core.queue.exampleQueue", "messageCount");
session.start();
ClientMessage reply = requestor.request(m);
int count = (Integer) ManagementHelper.getResult(reply);
System.out.println("There are " + count + " messages in exampleQueue");</pre><p>Management operation name and parameters must conform to the Java interfaces defined in
         the <code class="literal">management</code> packages.</p><p>Names of the resources are built using the helper class <code class="literal">org.hornetq.api.core.management.ResourceNames</code> and are straightforward
            (<code class="literal">core.queue.exampleQueue</code> for the Core Queue <code class="literal">exampleQueue</code>, <code class="literal">jms.topic.exampleTopic</code> for the JMS Topic
            <code class="literal">exampleTopic</code>, etc.).</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="management.core.configuration"/>30.3.1. Configuring Core Management</h3></div></div></div><p>The management address to send management messages is configured in <code class="literal">hornetq-configuration.xml</code>:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;management-address&gt;jms.queue.hornetq.management&lt;/management-address&gt;</pre><p>By default, the address is <code class="literal">jms.queue.hornetq.management</code> (it is
            prepended by "jms.queue" so that JMS clients can also send management messages).</p><p>The management address requires a <span class="emphasis"><em>special</em></span> user permission
               <code class="literal">manage</code> to be able to receive and handle management messages. This
            is also configured in hornetq-configuration.xml:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;!-- users with the admin role will be allowed to manage --&gt;
&lt;!-- HornetQ using management messages        --&gt;
&lt;security-setting match="jms.queue.hornetq.management"&gt;
   &lt;permission type="manage" roles="admin" /&gt;
&lt;/security-setting&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="management.jms"/>30.4. Using Management Via JMS</h2></div></div></div><p>Using JMS messages to manage HornetQ is very similar to using core API.</p><p>An important difference is that JMS requires a JMS queue to send the messages to
         (instead of an address for the core API).</p><p>The <span class="emphasis"><em>management queue</em></span> is a special queue and needs to be
         instantiated directly by the client:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
Queue managementQueue = HornetQJMSClient.createQueue("hornetq.management");</pre><p>All the other steps are the same than for the Core API but they use JMS API
         instead:</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>create a <code class="literal">QueueRequestor</code> to send messages to the management
               address and receive replies</p></li><li><p>create a <code class="literal">Message</code></p></li><li><p>use the helper class <code class="literal">org.hornetq.api.jms.management.JMSManagementHelper</code> to fill the message
               with the management properties</p></li><li><p>send the message using the <code class="literal">QueueRequestor</code></p></li><li><p>use the helper class <code class="literal">org.hornetq.api.jms.management.JMSManagementHelper</code> to retrieve the
               operation result from the management reply</p></li></ol></div><p>For example, to know the number of messages in the JMS queue <code class="literal">exampleQueue</code>:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
Queue managementQueue = HornetQJMSClient.createQueue("hornetq.management");

QueueSession session = ...
QueueRequestor requestor = new QueueRequestor(session, managementQueue);
connection.start();
Message message = session.createMessage();
JMSManagementHelper.putAttribute(message, "jms.queue.exampleQueue", "messageCount");
Message reply = requestor.request(message);
int count = (Integer)JMSManagementHelper.getResult(reply);
System.out.println("There are " + count + " messages in exampleQueue");</pre><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7112"/>30.4.1. Configuring JMS Management</h3></div></div></div><p>Whether JMS or the core API is used for management, the configuration steps are the
            same (see <a class="xref" href="#management.core.configuration" title="30.3.1. Configuring Core Management">Section 30.3.1, “Configuring Core Management”</a>).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7119"/>30.4.2. Example</h3></div></div></div><p>See <a class="xref" href="#examples.management" title="11.1.38. Management">Section 11.1.38, “Management”</a> for an example which shows how to use JMS
            messages to manage HornetQ server.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="management.notifications"/>30.5. Management Notifications</h2></div></div></div><p>HornetQ emits <span class="emphasis"><em>notifications</em></span> to inform listeners of potentially
         interesting events (creation of new resources, security violation, etc.).</p><p>These notifications can be received by 3 different ways:</p><div class="itemizedlist"><ul><li><p>JMX notifications</p></li><li><p>Core messages</p></li><li><p>JMS messages</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7146"/>30.5.1. JMX Notifications</h3></div></div></div><p>If JMX is enabled (see <a class="xref" href="#management.jmx.configuration" title="30.2.1. Configuring JMX">Section 30.2.1, “Configuring JMX”</a>), JMX
            notifications can be received by subscribing to 2 MBeans:</p><div class="itemizedlist"><ul><li><p><code class="literal">org.hornetq:module=Core,type=Server</code> for notifications on
                     <span class="emphasis"><em>Core</em></span> resources</p></li><li><p><code class="literal">org.hornetq:module=JMS,type=Server</code> for notifications on
                     <span class="emphasis"><em>JMS</em></span> resources</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7170"/>30.5.2. Core Messages Notifications</h3></div></div></div><p>HornetQ defines a special <span class="emphasis"><em>management notification address</em></span>. Core
            queues can be bound to this address so that clients will receive management
            notifications as Core messages</p><p>A Core client which wants to receive management notifications must create a core
            queue bound to the management notification address. It can then receive the
            notifications from its queue.</p><p>Notifications messages are regular core messages with additional properties
            corresponding to the notification (its type, when it occurred, the resources which were
            concerned, etc.).</p><p>Since notifications are regular core messages, it is possible to use message
            selectors to filter out notifications and receives only a subset of all the
            notifications emitted by the server.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="management.notifications.core.configuration"/>30.5.2.1. Configuring The Core Management Notification Address</h4></div></div></div><p>The management notification address to receive management notifications is
               configured in <code class="literal">hornetq-configuration.xml</code>:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;management-notification-address&gt;hornetq.notifications&lt;/management-notification-address&gt;</pre><p>By default, the address is <code class="literal">hornetq.notifications</code>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7199"/>30.5.3. JMS Messages Notifications</h3></div></div></div><p>HornetQ's notifications can also be received using JMS messages.</p><p>It is similar to receiving notifications using Core API but an important difference
            is that JMS requires a JMS Destination to receive the messages (preferably a
            Topic).</p><p>To use a JMS Destination to receive management notifications, you must change the server's
            management notification address to start with <code class="literal">jms.queue</code> if it is a JMS Queue
            or <code class="literal">jms.topic</code> if it is a JMS Topic:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;!-- notifications will be consumed from "notificationsTopic" JMS Topic --&gt;
&lt;management-notification-address&gt;jms.topic.notificationsTopic&lt;/management-notification-address&gt;</pre><p>Once the notification topic is created, you can receive messages from it or set a
               <code class="literal">MessageListener</code>:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
Topic notificationsTopic = HornetQJMSClient.createTopic("notificationsTopic");

Session session = ...
MessageConsumer notificationConsumer = session.createConsumer(notificationsTopic);
notificationConsumer.setMessageListener(new MessageListener()
{
   public void onMessage(Message notif)
   {
      System.out.println("------------------------");
      System.out.println("Received notification:");
      try
      {
         Enumeration propertyNames = notif.getPropertyNames();
         while (propertyNames.hasMoreElements())
         {
            String propertyName = (String)propertyNames.nextElement();
            System.out.format("  %s: %s\n", propertyName, notif.getObjectProperty(propertyName));
         }
      }
      catch (JMSException e)
      {
      }
      System.out.println("------------------------");
   }
});</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7223"/>30.5.4. Example</h3></div></div></div><p>See <a class="xref" href="#examples.management-notifications" title="11.1.39. Management Notification">Section 11.1.39, “Management Notification”</a> for an example which shows
               how to use a JMS <code class="literal">MessageListener</code> to receive management notifications
               from HornetQ server.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7233"/>30.5.5. Notification Types and Headers</h3></div></div></div><p>Below is a list of all the different kinds of notifications as well as which headers are
                on the messages.  Every notification has a <code class="literal">_HQ_NotifType</code> (value noted in parentheses)
                and <code class="literal">_HQ_NotifTimestamp</code> header.  The timestamp is the un-formatted result of a call
                to <code class="literal">java.lang.System.currentTimeMillis()</code>.</p><div class="itemizedlist"><ul><li><p><code class="literal">BINDING_ADDED</code> (0)</p><p><code class="literal">_HQ_Binding_Type</code>, <code class="literal">_HQ_Address</code>,
                       <code class="literal">_HQ_ClusterName</code>, <code class="literal">_HQ_RoutingName</code>,
                       <code class="literal">_HQ_Binding_ID</code>, <code class="literal">_HQ_Distance</code>,
                       <code class="literal">_HQ_FilterString</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">BINDING_REMOVED</code> (1)</p><p><code class="literal">_HQ_Address</code>, <code class="literal">_HQ_ClusterName</code>,
                       <code class="literal">_HQ_RoutingName</code>, <code class="literal">_HQ_Binding_ID</code>,
                       <code class="literal">_HQ_Distance</code>, <code class="literal">_HQ_FilterString</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">CONSUMER_CREATED</code> (2)</p><p><code class="literal">_HQ_Address</code>, <code class="literal">_HQ_ClusterName</code>,
                       <code class="literal">_HQ_RoutingName</code>, <code class="literal">_HQ_Distance</code>,
                       <code class="literal">_HQ_ConsumerCount</code>, <code class="literal">_HQ_User</code>,
                       <code class="literal">_HQ_RemoteAddress</code>, <code class="literal">_HQ_SessionName</code>,
                       <code class="literal">_HQ_FilterString</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">CONSUMER_CLOSED</code> (3)</p><p><code class="literal">_HQ_Address</code>, <code class="literal">_HQ_ClusterName</code>,
                       <code class="literal">_HQ_RoutingName</code>, <code class="literal">_HQ_Distance</code>,
                       <code class="literal">_HQ_ConsumerCount</code>, <code class="literal">_HQ_User</code>,
                       <code class="literal">_HQ_RemoteAddress</code>, <code class="literal">_HQ_SessionName</code>,
                       <code class="literal">_HQ_FilterString</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">SECURITY_AUTHENTICATION_VIOLATION</code> (6)</p><p><code class="literal">_HQ_User</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">SECURITY_PERMISSION_VIOLATION</code> (7)</p><p><code class="literal">_HQ_Address</code>, <code class="literal">_HQ_CheckType</code>,
                       <code class="literal">_HQ_User</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">DISCOVERY_GROUP_STARTED</code> (8)</p><p><code class="literal">name</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">DISCOVERY_GROUP_STOPPED</code> (9)</p><p><code class="literal">name</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">BROADCAST_GROUP_STARTED</code> (10)</p><p><code class="literal">name</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">BROADCAST_GROUP_STOPPED</code> (11)</p><p><code class="literal">name</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">BRIDGE_STARTED</code> (12)</p><p><code class="literal">name</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">BRIDGE_STOPPED</code> (13)</p><p><code class="literal">name</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">CLUSTER_CONNECTION_STARTED</code> (14)</p><p><code class="literal">name</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">CLUSTER_CONNECTION_STOPPED</code> (15)</p><p><code class="literal">name</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">ACCEPTOR_STARTED</code> (16)</p><p><code class="literal">factory</code>, <code class="literal">id</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">ACCEPTOR_STOPPED</code> (17)</p><p><code class="literal">factory</code>, <code class="literal">id</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">PROPOSAL</code> (18)</p><p><code class="literal">_JBM_ProposalGroupId</code>, <code class="literal">_JBM_ProposalValue</code>,
                       <code class="literal">_HQ_Binding_Type</code>, <code class="literal">_HQ_Address</code>,
                       <code class="literal">_HQ_Distance</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">PROPOSAL_RESPONSE</code> (19)</p><p><code class="literal">_JBM_ProposalGroupId</code>, <code class="literal">_JBM_ProposalValue</code>,
                       <code class="literal">_JBM_ProposalAltValue</code>, <code class="literal">_HQ_Binding_Type</code>,
                       <code class="literal">_HQ_Address</code>, <code class="literal">_HQ_Distance</code></p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="management.message-counters"/>30.6. Message Counters</h2></div></div></div><p>Message counters can be used to obtain information on queues <span class="emphasis"><em>over
            time</em></span> as HornetQ keeps a history on queue metrics.</p><p>They can be used to show <span class="emphasis"><em>trends</em></span> on queues. For example, using the
         management API, it would be possible to query the number of messages in a queue at regular
         interval. However, this would not be enough to know if the queue is used: the number of
         messages can remain constant because nobody is sending or receiving messages from the queue
         or because there are as many messages sent to the queue than messages consumed from it. The
         number of messages in the queue remains the same in both cases but its use is widely
         different.</p><p>Message counters gives additional information about the queues:</p><div class="itemizedlist"><ul><li><p><code class="literal">count</code></p><p>The <span class="emphasis"><em>total</em></span> number of messages added to the queue since the
               server was started</p></li><li><p><code class="literal">countDelta</code></p><p>the number of messages added to the queue <span class="emphasis"><em>since the last message counter
                  update</em></span></p></li><li><p><code class="literal">messageCount</code></p><p>The <span class="emphasis"><em>current</em></span> number of messages in the queue</p></li><li><p><code class="literal">messageCountDelta</code></p><p>The <span class="emphasis"><em>overall</em></span> number of messages added/removed from the queue
                  <span class="emphasis"><em>since the last message counter update</em></span>. For example, if
                  <code class="literal">messageCountDelta</code> is equal to <code class="literal">-10</code> this means that
               overall 10 messages have been removed from the queue (e.g. 2 messages were added and
               12 were removed)</p></li><li><p><code class="literal">lastAddTimestamp</code></p><p>The timestamp of the last time a message was added to the queue</p></li><li><p><code class="literal">udpateTimestamp</code></p><p>The timestamp of the last message counter update</p></li></ul></div><p>These attributes can be used to determine other meaningful data as well.  For example, to know
      specifically how many messages were <span class="emphasis"><em>consumed</em></span> from the queue since the last update
      simply subtract the <code class="literal">messageCountDelta</code> from <code class="literal">countDelta</code>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="configuring.message.counters"/>30.6.1. Configuring Message Counters</h3></div></div></div><p>By default, message counters are disabled as it might have a small negative effect on
            memory.</p><p>To enable message counters, you can set it to <code class="literal">true</code> in <code class="literal">hornetq-configuration.xml</code>:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;message-counter-enabled&gt;true&lt;/message-counter-enabled&gt;</pre><p>Message counters keeps a history of the queue metrics (10 days by default) and
            samples all the queues at regular interval (10 seconds by default). If message counters
            are enabled, these values should be configured to suit your messaging use case in
               <code class="literal">hornetq-configuration.xml</code>:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;!-- keep history for a week --&gt;
&lt;message-counter-max-day-history&gt;7&lt;/message-counter-max-day-history&gt;
&lt;!-- sample the queues every minute (60000ms) --&gt;
&lt;message-counter-sample-period&gt;60000&lt;/message-counter-sample-period&gt;</pre><p>Message counters can be retrieved using the Management API. For example, to retrieve
            message counters on a JMS Queue using JMX:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
// retrieve a connection to HornetQ's MBeanServer
MBeanServerConnection mbsc = ...
JMSQueueControlMBean queueControl = (JMSQueueControl)MBeanServerInvocationHandler.newProxyInstance(mbsc,
   on,
   JMSQueueControl.class,
   false);
// message counters are retrieved as a JSON String                                                                                                      
String counters = queueControl.listMessageCounter();
// use the MessageCounterInfo helper class to manipulate message counters more easily
MessageCounterInfo messageCounter = MessageCounterInfo.fromJSON(counters);         
System.out.format("%s message(s) in the queue (since last sample: %s)\n",
messageCounter.getMessageCount(),
messageCounter.getMessageCountDelta());</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7638"/>30.6.2. Example</h3></div></div></div><p>See <a class="xref" href="#examples.message-counters" title="11.1.40. Message Counter">Section 11.1.40, “Message Counter”</a> for an example which shows how to use
            message counters to retrieve information on a JMS <code class="literal">Queue</code>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7648"/>30.7. Administering HornetQ Resources Using The JBoss AS Admin Console</h2></div></div></div><p>Its possible to create and configure HornetQ resources via the admin console within the JBoss Application Server.</p><p>The Admin Console will allow you to create destinations (JMS Topics and Queues) and JMS Connection Factories.</p><p>Once logged in to the admin console you will see a JMS Manager item in the left hand tree. All HornetQ resources
      will be configured via this. This will have a child items for JMS Queues, Topics and Connection Factories, clicking
         on each node will reveal which resources are currently available. The following sections explain how to create
         and configure each resource in turn.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7657"/>30.7.1. JMS Queues</h3></div></div></div><p>To create a new JMS Queue click on the JMS Queues item to reveal the available queues. On the right hand
            panel you will see an add a new resource button, click on this and then choose the default(JMS Queue) template
         and click continue. The important things to fill in here are the name of the queue and the JNDI name of the
            queue. The JNDI name is what you will use to look up the queue in JNDI from your client. For most queues this
            will be the only info you will need to provide as sensible defaults are provided for the others. You will also
            see a security roles section near the bottom. If you do not provide any roles for this queue then the servers
         default security configuration will be used, after you have created the queue these will be shown in the configuration.
         All configuration values, except the name and JNDI name, can be changed via the configuration tab after clicking
            on the queue in the admin console. The following section explains these in more detail</p><p>After highlighting the configuration you will see the following screen</p><p>
            </p><div align="center"><img src="images/console1.png" align="middle"/></div><p>
        </p><p>The name and JNDI name can't be changed, if you want to change these recreate the queue with the appropriate
         settings. The rest of the configuration options, apart from security roles, relate to address settings for a particular
         address. The default address settings are picked up from the servers configuration, if you change any of these
         settings or create a queue via the console a new Address Settings entry will be added. For a full explanation on
         Address Settings see <a class="xref" href="#queue-attributes.address-settings" title="25.3. Configuring Queues Via Address Settings">Section 25.3, “Configuring Queues Via Address Settings”</a></p><p>To delete a queue simply click on the delete button beside the queue name in the main JMS Queues screen.
         This will also delete any address settings or security settings previously created for the queues address</p><p>The last part of the configuration options are security roles. If non are provided on creation then the
            servers default security settings will be shown. If these are changed or updated then new security settings are
         created for the address of this queue. For more information on security setting see <a class="xref" href="#security" title="Chapter 31. Security">Chapter 31, <i>Security</i></a> </p><p>It is also possible via the metrics tab to view statistics for this queue. This will show statistics such
            as message count, consumer count etc.</p><p>Operations can be performed on a queue via the control tab. This will allow you to start and stop the queue,
         list,move,expire and delete messages from the queue and other useful operations. To invoke an operation click on
         the button for the operation you want, this will take you to a screen where you can parameters for the operation can be set.
         Once set clicking the ok button will invoke the operation, results appear at the bottom of the screen.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7681"/>30.7.2. JMS Topics</h3></div></div></div><p>Creating and configuring JMS Topics is almost identical to creating queues. The only difference is that the
         configuration will be applied to the queue representing a subscription.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7686"/>30.7.3. JMS Connection Factories</h3></div></div></div><p>The format for creating connection factories is the same as for JMS Queues and topics apart from the configuration
         being different. For as list of all the connection factory settings see the configuration index </p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="security"/>Chapter 31. Security</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#security.settings.roles">31.1. Role based security for addresses</a></span></dt><dt><span class="section"><a href="#d0e7879">31.2. Secure Sockets Layer (SSL) Transport</a></span></dt><dt><span class="section"><a href="#d0e7888">31.3. Basic user credentials</a></span></dt><dt><span class="section"><a href="#change-security-manager">31.4. Changing the security manager</a></span></dt><dt><span class="section"><a href="#d0e7975">31.5. JAAS Security Manager</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8008">31.5.1. Example</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e8015">31.6. JBoss AS Security Manager</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8029">31.6.1. Configuring Client Login</a></span></dt><dt><span class="section"><a href="#d0e8048">31.6.2. Changing the Security Domain</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e8059">31.7. Changing the username/password for clustering</a></span></dt></dl></div><p>This chapter describes how security works with HornetQ and how you can configure it. To
        disable security completely simply set the <code class="literal">security-enabled</code> property to
        false in the <code class="literal">hornetq-configuration.xml</code> file.</p><p>For performance reasons security is cached and invalidated every so long. To change this
        period set the property <code class="literal">security-invalidation-interval</code>, which is in
        milliseconds. The default is <code class="literal">10000</code> ms.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="security.settings.roles"/>31.1. Role based security for addresses</h2></div></div></div><p>HornetQ contains a flexible role-based security model for applying security to queues,
            based on their addresses.</p><p>As explained in <a class="xref" href="#using-core" title="Chapter 8. Using Core">Chapter 8, <i>Using Core</i></a>, HornetQ core consists mainly of sets of
            queues bound to addresses. A message is sent to an address and the server looks up the
            set of queues that are bound to that address, the server then routes the message to
            those set of queues.</p><p>HornetQ allows sets of permissions to be defined against the queues based on their
            address. An exact match on the address can be used or a wildcard match can be used using
            the wildcard characters '<code class="literal">#</code>' and '<code class="literal">*</code>'.</p><p>Seven different permissions can be given to the set of queues which match the address.
            Those permissions are:</p><div class="itemizedlist"><ul><li><p><code class="literal">createDurableQueue</code>. This permission allows the user to
                    create a durable queue under matching addresses.</p></li><li><p><code class="literal">deleteDurableQueue</code>. This permission allows the user to
                    delete a durable queue under matching addresses.</p></li><li><p><code class="literal">createNonDurableQueue</code>. This permission allows the user to create
                    a non-durable queue under matching addresses.</p></li><li><p><code class="literal">deleteNonDurableQueue</code>. This permission allows the user to delete
                    a non-durable queue under matching addresses.</p></li><li><p><code class="literal">send</code>. This permission allows the user to send a message to
                    matching addresses.</p></li><li><p><code class="literal">consume</code>. This permission allows the user to consume a
                    message from a queue bound to matching addresses.</p></li><li><p><code class="literal">manage</code>. This permission allows the user to invoke
                    management operations by sending management messages to the management
                    address.</p></li></ul></div><p>For each permission, a list of roles who are granted that permission is specified. If
            the user has any of those roles, he/she will be granted that permission for that set of
            addresses.</p><p>Let's take a simple example, here's a security block from <code class="literal">hornetq-configuration.xml</code> or <code class="literal">hornetq-queues.xml</code>
            file:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;security-setting match="globalqueues.europe.#"&gt;
   &lt;permission type="createDurableQueue" roles="admin"/&gt;
   &lt;permission type="deleteDurableQueue" roles="admin"/&gt;
   &lt;permission type="createNonDurableQueue" roles="admin, guest, europe-users"/&gt;
   &lt;permission type="deleteNonDurableQueue" roles="admin, guest, europe-users"/&gt;
   &lt;permission type="send" roles="admin, europe-users"/&gt;
   &lt;permission type="consume" roles="admin, europe-users"/&gt;
&lt;/security-setting&gt;</pre><p>The '<code class="literal">#</code>' character signifies "any sequence of words". Words are
            delimited by the '<code class="literal">.</code>' character. For a full description of the
            wildcard syntax please see <a class="xref" href="#wildcard-syntax" title="Chapter 13. Understanding the HornetQ Wildcard Syntax">Chapter 13, <i>Understanding the HornetQ Wildcard Syntax</i></a>. The above security block
            applies to any address that starts with the string "globalqueues.europe.":</p><p>Only users who have the <code class="literal">admin</code> role can create or delete durable
            queues bound to an address that starts with the string "globalqueues.europe."</p><p>Any users with the roles <code class="literal">admin</code>, <code class="literal">guest</code>, or
                <code class="literal">europe-users</code> can create or delete temporary queues bound to an
            address that starts with the string "globalqueues.europe."</p><p>Any users with the roles <code class="literal">admin</code> or <code class="literal">europe-users</code>
            can send messages to these addresses or consume messages from queues bound to an address
            that starts with the string "globalqueues.europe."</p><p>The mapping between a user and what roles they have is handled by the security
            manager. HornetQ ships with a user manager that reads user credentials from a file on
            disk, and can also plug into JAAS or JBoss Application Server security.</p><p>For more information on configuring the security manager, please see <a class="xref" href="#change-security-manager" title="31.4. Changing the security manager">Section 31.4, “Changing the security manager”</a>.</p><p>There can be zero or more <code class="literal">security-setting</code> elements in each xml
            file. Where more than one match applies to a set of addresses the <span class="emphasis"><em>more
                specific</em></span> match takes precedence.</p><p>Let's look at an example of that, here's another <code class="literal">security-setting</code>
            block:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;security-setting match="globalqueues.europe.orders.#"&gt;
   &lt;permission type="send" roles="europe-users"/&gt;
   &lt;permission type="consume" roles="europe-users"/&gt;
&lt;/security-setting&gt;</pre><p>In this <code class="literal">security-setting</code> block the match
            'globalqueues.europe.orders.#' is more specific than the previous match
            'globalqueues.europe.#'. So any addresses which match 'globalqueues.europe.orders.#'
            will take their security settings <span class="emphasis"><em>only</em></span> from the latter
            security-setting block.</p><p>Note that settings are not inherited from the former block. All the settings will be
            taken from the more specific matching block, so for the address
            'globalqueues.europe.orders.plastics' the only permissions that exist are <code class="literal">send</code> and <code class="literal">consume</code> for the role europe-users. The
            permissions <code class="literal">createDurableQueue</code>, <code class="literal">deleteDurableQueue</code>, <code class="literal">createNonDurableQueue</code>, <code class="literal">deleteNonDurableQueue</code> are not inherited from the other security-setting
            block.</p><p>By not inheriting permissions, it allows you to effectively deny permissions in more
            specific security-setting blocks by simply not specifying them. Otherwise it would not
            be possible to deny permissions in sub-groups of addresses.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7879"/>31.2. Secure Sockets Layer (SSL) Transport</h2></div></div></div><p>When messaging clients are connected to servers, or servers are connected to other
            servers (e.g. via bridges) over an untrusted network then HornetQ allows that traffic to
            be encrypted using the Secure Sockets Layer (SSL) transport.</p><p>For more information on configuring the SSL transport, please see <a class="xref" href="#configuring-transports" title="Chapter 16. Configuring the Transport">Chapter 16, <i>Configuring the Transport</i></a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7888"/>31.3. Basic user credentials</h2></div></div></div><p>HornetQ ships with a security manager implementation that reads user credentials, i.e.
            user names, passwords and role information from an xml file on the classpath called
                <code class="literal">hornetq-users.xml</code>. This is the default security manager.</p><p>If you wish to use this security manager, then users, passwords and roles can easily
            be added into this file.</p><p>Let's take a look at an example file:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;configuration xmlns="urn:hornetq" 
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="urn:hornetq ../schemas/hornetq-users.xsd "&gt;

   &lt;defaultuser name="guest" password="guest"&gt;
      &lt;role name="guest"/&gt;
   &lt;/defaultuser&gt;

   &lt;user name="tim" password="marmite"&gt;
      &lt;role name="admin"/&gt;
   &lt;/user&gt;

   &lt;user name="andy" password="doner_kebab"&gt;
      &lt;role name="admin"/&gt;
      &lt;role name="guest"/&gt;
   &lt;/user&gt;

   &lt;user name="jeff" password="camembert"&gt;
      &lt;role name="europe-users"/&gt;
      &lt;role name="guest"/&gt;
   &lt;/user&gt;

&lt;/configuration&gt;</pre><p>The first thing to note is the element <code class="literal">defaultuser</code>. This defines
            what user will be assumed when the client does not specify a username/password when
            creating a session. In this case they will be the user <code class="literal">guest</code> and have
            the role also called <code class="literal">guest</code>. Multiple roles can be specified for a
            default user.</p><p>We then have three more users, the user <code class="literal">tim</code> has the role <code class="literal">admin</code>. The user <code class="literal">andy</code> has the roles <code class="literal">admin</code> and <code class="literal">guest</code>, and the user <code class="literal">jeff</code>
            has the roles <code class="literal">europe-users</code> and <code class="literal">guest</code>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="change-security-manager"/>31.4. Changing the security manager</h2></div></div></div><p>If you do not want to use the default security manager then you can specify a
            different one by editing the file <code class="literal">hornetq-beans.xml</code> (or <code class="literal">hornetq-jboss-beans.xml</code> if you're running JBoss Application Server) and
            changing the class for the <code class="literal">HornetQSecurityManager</code> bean.</p><p>Let's take a look at a snippet from the default beans file:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">           
&lt;bean name="HornetQSecurityManager" class="org.hornetq.spi.core.security.HornetQSecurityManagerImpl"&gt;
   &lt;start ignored="true"/&gt;
   &lt;stop ignored="true"/&gt;
&lt;/bean&gt;</pre><p>The class <code class="literal">org.hornetq.spi.core.security.HornetQSecurityManagerImpl</code>
            is the default security manager that is used by the standalone server.</p><p>HornetQ ships with two other security manager implementations you can use
            off-the-shelf; one a JAAS security manager and another for integrating with JBoss
            Application Sever security, alternatively you could write your own implementation by
            implementing the <code class="literal">org.hornetq.spi.core.security.HornetQSecurityManager</code>
            interface, and specifying the classname of your implementation in the file <code class="literal">hornetq-beans.xml</code> (or <code class="literal">hornetq-jboss-beans.xml</code> if
            you're running JBoss Application Server).</p><p>These two implementations are discussed in the next two sections.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7975"/>31.5. JAAS Security Manager</h2></div></div></div><p>JAAS stands for 'Java Authentication and Authorization Service' and is a standard part
            of the Java platform. It provides a common API for security authentication and
            authorization, allowing you to plugin your pre-built implementations.</p><p>To configure the JAAS security manager to work with your pre-built JAAS infrastructure
            you need to specify the security manager as a <code class="literal">JAASSecurityManager</code> in
            the beans file. Here's an example:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;bean name="HornetQSecurityManager" class="org.hornetq.integration.jboss.security.JAASSecurityManager"&gt;
   &lt;start ignored="true"/&gt;
   &lt;stop ignored="true"/&gt;

   &lt;property name="ConfigurationName"&gt;org.hornetq.jms.example.ExampleLoginModule&lt;/property&gt;
   &lt;property name="Configuration"&gt;
      &lt;inject bean="ExampleConfiguration"/&gt;
   &lt;/property&gt;
   &lt;property name="CallbackHandler"&gt;
      &lt;inject bean="ExampleCallbackHandler"/&gt;
   &lt;/property&gt;
&lt;/bean&gt;</pre><p>Note that you need to feed the JAAS security manager with three properties:</p><div class="itemizedlist"><ul><li><p>ConfigurationName: the name of the <code class="literal">LoginModule</code>
                    implementation that JAAS must use</p></li><li><p>Configuration: the <code class="literal">Configuration</code> implementation used by
                    JAAS</p></li><li><p>CallbackHandler: the <code class="literal">CallbackHandler</code> implementation to use
                    if user interaction are required</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8008"/>31.5.1. Example</h3></div></div></div><p>See <a class="xref" href="#examples.jaas" title="11.1.29. JAAS">Section 11.1.29, “JAAS”</a> for an example which shows how HornetQ can be
                configured to use JAAS.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e8015"/>31.6. JBoss AS Security Manager</h2></div></div></div><p>The JBoss AS security manager is used when running HornetQ inside the JBoss
            Application server. This allows tight integration with the JBoss Application Server's
            security model.</p><p>The class name of this security manager is <code class="literal">org.hornetq.integration.jboss.security.JBossASSecurityManager</code></p><p>Take a look at one of the default <code class="literal">hornetq-jboss-beans.xml</code> files for
            JBoss Application Server that are bundled in the distribution for an example of how this
            is configured.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8029"/>31.6.1. Configuring Client Login</h3></div></div></div><p>JBoss can be configured to allow client login, basically this is when a JEE component such as a Servlet
             or EJB sets security credentials on the current security context  and these are used throughout the call.
             If you would like these credentials to be used by HornetQ when sending or consuming messages then
          set <code class="literal">allowClientLogin</code> to true. This will bypass HornetQ authentication and propagate the
          provided Security Context. If you would like HornetQ to authenticate using the propagated security then set the
          <code class="literal">authoriseOnClientLogin</code> to true also.</p><p>There is more info on using the JBoss client login module <a class="ulink" href="http://community.jboss.org/wiki/ClientLoginModule">here</a> </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>If messages are sent non blocking then there is a chance that these could arrive on the server after
          the calling thread has completed meaning that the security context has been cleared. If this is the case then messages
          will need to be sent blocking</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8048"/>31.6.2. Changing the Security Domain</h3></div></div></div><p>The name of the security domain used by the JBoss AS security manager defaults to <code class="literal">java:/jaas/hornetq
          </code>.  This can be changed by specifying <code class="literal">securityDomainName</code> (e.g. java:/jaas/myDomain).
          </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e8059"/>31.7. Changing the username/password for clustering</h2></div></div></div><p>In order for cluster connections to work correctly, each node in the cluster must make
            connections to the other nodes. The username/password they use for this should always be
            changed from the installation default to prevent a security risk.</p><p>Please see <a class="xref" href="#management" title="Chapter 30. Management">Chapter 30, <i>Management</i></a> for instructions on how to do this.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="appserver-integration"/>Chapter 32. Application Server Integration and Java EE</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#configuring-mdbs">32.1. Configuring Message-Driven Beans</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8151">32.1.1. Using Container-Managed Transactions</a></span></dt><dt><span class="section"><a href="#d0e8183">32.1.2. Using Bean-Managed Transactions</a></span></dt><dt><span class="section"><a href="#d0e8205">32.1.3. Using Message Selectors with Message-Driven Beans</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e8212">32.2. Sending Messages from within JEE components</a></span></dt><dt><span class="section"><a href="#d0e8229">32.3. MDB and Consumer pool size</a></span></dt><dt><span class="section"><a href="#d0e8242">32.4. Configuring the JCA Adaptor</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8271">32.4.1. Global Properties</a></span></dt><dt><span class="section"><a href="#d0e8646">32.4.2. Adapter Outbound Configuration</a></span></dt><dt><span class="section"><a href="#d0e8720">32.4.3. Adapter Inbound Configuration</a></span></dt><dt><span class="section"><a href="#d0e8839">32.4.4. Configuring the adapter to use a standalone HornetQ Server</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e8991">32.5. Configuring the JBoss Application Server to connect to Remote HornetQ Server</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8996">32.5.1. Configuring JBoss 5</a></span></dt><dt><span class="section"><a href="#d0e9100">32.5.2. Configuring JBoss 5</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e9112">32.6. High Availability JNDI (HA-JNDI)</a></span></dt><dt><span class="section"><a href="#xa-recovery">32.7. XA Recovery</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9139">32.7.1. XA Recovery Configuration</a></span></dt><dt><span class="section"><a href="#d0e9242">32.7.2. Example</a></span></dt></dl></dd></dl></div><p>HornetQ can be easily installed in JBoss Application Server 4 or later. For details on
        installing HornetQ in the JBoss Application Server please refer to quick-start guide.</p><p>Since HornetQ also provides a JCA adapter, it is also possible to integrate HornetQ
        as a JMS provider in other JEE compliant app servers. For instructions on how to integrate a
        remote JCA adaptor into another application sever, please consult the other application server's
        instructions.</p><p>A JCA Adapter basically controls the inflow of messages to Message-Driven Beans (MDBs) and the
        outflow of messages sent from other JEE components, e.g. EJBs and Servlets.</p><p>This section explains the basics behind configuring the different JEE components in the
        AS.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="configuring-mdbs"/>32.1. Configuring Message-Driven Beans</h2></div></div></div><p>The delivery of messages to an MDB using HornetQ is configured on the JCA Adapter via
            a configuration file <code class="literal">ra.xml</code> which can be found under the <code class="literal">jms-ra.rar</code> directory. By default this is configured to consume
            messages using an InVM connector from the instance of HornetQ running within the
            application server. The configuration properties are listed later in this chapter. </p><p>All MDBs however need to have the destination type and the destination configured.
            The following example shows how this can be done using annotations:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
@MessageDriven(name = "MDBExample", activationConfig =
{
   @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue"),
   @ActivationConfigProperty(propertyName = "destination", propertyValue = "queue/testQueue")
})
@ResourceAdapter("hornetq-ra.rar")
public class MDBExample implements MessageListener
{
   public void onMessage(Message message)...
}</pre><p>In this example you can see that the MDB will consume messages from a queue that is
            mapped into JNDI with the binding <code class="literal">queue/testQueue</code>. This queue must be
            preconfigured in the usual way using the HornetQ configuration files.</p><p>The <code class="literal">ResourceAdapter</code> annotation is used to specify which adaptor
            should be used. To use this you will need to import <code class="literal">org.jboss.ejb3.annotation.ResourceAdapter</code> for JBoss AS 5.X and later version which can be found in the
                <code class="literal">jboss-ejb3-ext-api.jar</code> which can be found in the JBoss
            repository. For JBoss AS 4.X, the annotation to use is <code class="literal">org.jboss.annotation.ejb.ResourceAdaptor</code>.</p><p>
             Alternatively you can add use a deployment descriptor and add something like
            the following to <code class="literal">jboss.xml</code></p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;message-driven&gt;
   &lt;ejb-name&gt;ExampleMDB&lt;/ejb-name&gt;
   &lt;resource-adapter-name&gt;hornetq-ra.rar&lt;/resource-adapter-name&gt;
&lt;/message-driven&gt;
</pre><p>You
            can also rename the hornetq-ra.rar directory to jms-ra.rar and neither the annotation or
            the extra descriptor information will be needed. If you do this you will need to edit
            the <code class="literal">jms-ds.xml</code> datasource file and change <code class="literal">rar-name</code>
            element.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>HornetQ is the default JMS provider for JBoss AS 6. Starting with this AS version, HornetQ resource
              adapter is named <code class="literal">jms-ra.rar</code> and you no longer need to annotate the MDB for the resource adapter name.</p></div><p>All the examples shipped with the HornetQ distribution use the annotation.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8151"/>32.1.1. Using Container-Managed Transactions</h3></div></div></div><p>When an MDB is using Container-Managed Transactions (CMT), the delivery of the
                message is done within the scope of a JTA transaction. The commit or rollback of
                this transaction is controlled by the container itself. If the transaction is rolled
                back then the message delivery semantics will kick in (by default, it will try to
                redeliver the message up to 10 times before sending to a DLQ). Using annotations
                this would be configured as follows:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
@MessageDriven(name = "MDB_CMP_TxRequiredExample", activationConfig =
{
   @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue"),
   @ActivationConfigProperty(propertyName = "destination", propertyValue = "queue/testQueue")
})
@TransactionManagement(value= TransactionManagementType.CONTAINER)
@TransactionAttribute(value= TransactionAttributeType.REQUIRED)
@ResourceAdapter("hornetq-ra.rar")
public class MDB_CMP_TxRequiredExample implements MessageListener
{
   public void onMessage(Message message)...
}</pre><p>The <code class="literal">TransactionManagement</code> annotation tells the container to manage the
            transaction. The <code class="literal">TransactionAttribute</code> annotation tells the container that a JTA
                transaction is required for this MDB. Note that the only other valid value for this
                is <code class="literal">TransactionAttributeType.NOT_SUPPORTED</code> which tells the
                container that this MDB does not support JTA transactions and one should not be
                created.</p><p>It is also possible to inform the container that it must rollback the transaction
                by calling <code class="literal">setRollbackOnly</code> on the <code class="literal">MessageDrivenContext</code>. The code for this would look something
                like:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
@Resource
MessageDrivenContextContext ctx;

public void onMessage(Message message)
{
   try
   {
      //something here fails
   }
   catch (Exception e)
   {
      ctx.setRollbackOnly();
   }
}</pre><p>If you do not want the overhead of an XA transaction being created every time but
                you would still like the message delivered within a transaction (i.e. you are only
                using a JMS resource) then you can configure the MDB to use a local transaction.
                This would be configured as such:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
@MessageDriven(name = "MDB_CMP_TxLocalExample", activationConfig =
{
      @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue"),
      @ActivationConfigProperty(propertyName = "destination", propertyValue = "queue/testQueue"),
      @ActivationConfigProperty(propertyName = "useLocalTx", propertyValue = "true")
})
@TransactionManagement(value = TransactionManagementType.CONTAINER)
@TransactionAttribute(value = TransactionAttributeType.NOT_SUPPORTED)
@ResourceAdapter("hornetq-ra.rar")
public class MDB_CMP_TxLocalExample implements MessageListener
{
   public void onMessage(Message message)...
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8183"/>32.1.2. Using Bean-Managed Transactions</h3></div></div></div><p>Message-driven beans can also be configured to use Bean-Managed Transactions
                (BMT). In this case a User Transaction is created. This would be configured as
                follows:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
@MessageDriven(name = "MDB_BMPExample", activationConfig =
{
   @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue"),
   @ActivationConfigProperty(propertyName = "destination", propertyValue = "queue/testQueue"),
   @ActivationConfigProperty(propertyName = "acknowledgeMode", propertyValue = "Dups-ok-acknowledge")
})
@TransactionManagement(value= TransactionManagementType.BEAN)
@ResourceAdapter("hornetq-ra.rar")
public class MDB_BMPExample implements MessageListener
{
   public void onMessage(Message message)
}</pre><p>When using Bean-Managed Transactions the message delivery to the MDB will occur
                outside the scope of the user transaction and use the acknowledge mode specified by
                the user with the <code class="literal">acknowledgeMode</code> property. There are only 2
                acceptable values for this <code class="literal">Auto-acknowledge</code> and <code class="literal">Dups-ok-acknowledge</code>. Please note that because the message delivery is outside
                the scope of the transaction a failure within the MDB will not cause the message to
                be redelivered.</p><p>A user would control the life-cycle of the transaction something like the
                following:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
@Resource
MessageDrivenContext ctx;

public void onMessage(Message message)
{
   UserTransaction tx;
   try
   {
      TextMessage textMessage = (TextMessage)message;

      String text = textMessage.getText();

      UserTransaction tx = ctx.getUserTransaction();

      tx.begin();

      //do some stuff within the transaction

      tx.commit();

   }
   catch (Exception e)
   {
      tx.rollback();
   }
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8205"/>32.1.3. Using Message Selectors with Message-Driven Beans</h3></div></div></div><p>It is also possible to use MDBs with message selectors. To do this simple define
                your message selector as follows:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
@MessageDriven(name = "MDBMessageSelectorExample", activationConfig =
{
   @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue"),
   @ActivationConfigProperty(propertyName = "destination", propertyValue = "queue/testQueue"),
   @ActivationConfigProperty(propertyName = "messageSelector", propertyValue = "color = 'RED'")
})
@TransactionManagement(value= TransactionManagementType.CONTAINER)
@TransactionAttribute(value= TransactionAttributeType.REQUIRED)
@ResourceAdapter("hornetq-ra.rar")
public class MDBMessageSelectorExample implements MessageListener
{
   public void onMessage(Message message)....
}</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e8212"/>32.2. Sending Messages from within JEE components</h2></div></div></div><p>The JCA adapter can also be used for sending messages. The Connection Factory to use
            is configured by default in the <code class="literal">jms-ds.xml</code> file and is mapped to
                <code class="literal">java:/JmsXA</code>. Using this from within a JEE component will mean
            that the sending of the message will be done as part of the JTA transaction being used
            by the component.</p><p>This means that if the sending of the message fails the overall transaction would
            rollback and the message be re-sent. Heres an example of this from within an
            MDB:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
@MessageDriven(name = "MDBMessageSendTxExample", activationConfig =
{
   @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue"),
   @ActivationConfigProperty(propertyName = "destination", propertyValue = "queue/testQueue")
})
@TransactionManagement(value= TransactionManagementType.CONTAINER)
@TransactionAttribute(value= TransactionAttributeType.REQUIRED)
@ResourceAdapter("hornetq-ra.rar")
public class MDBMessageSendTxExample implements MessageListener
{
   @Resource(mappedName = "java:/JmsXA")
   ConnectionFactory connectionFactory;

   @Resource(mappedName = "queue/replyQueue")
   Queue replyQueue;

   public void onMessage(Message message)
   {
      Connection conn = null;
      try
      {
         //Step 9. We know the client is sending a text message so we cast
         TextMessage textMessage = (TextMessage)message;

         //Step 10. get the text from the message.
         String text = textMessage.getText();

         System.out.println("message " + text);

         conn = connectionFactory.createConnection();

         Session sess = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);

         MessageProducer producer = sess.createProducer(replyQueue);

         producer.send(sess.createTextMessage("this is a reply"));

      }
      catch (Exception e)
      {
         e.printStackTrace();
      }
      finally
      {
         if(conn != null)
         {
            try
            {
               conn.close();
            }
            catch (JMSException e)
            { 
            }
         }
      }
   }
   }</pre><p>In JBoss Application Server you can use the JMS JCA adapter for sending messages from
            EJBs (including Session, Entity and Message-Driven Beans), Servlets (including jsps) and
            custom MBeans.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e8229"/>32.3. MDB and Consumer pool size</h2></div></div></div><p>Most application servers, including JBoss, allow you to configure how many MDB's there are in a pool. In
         JBoss this is configured via the <code class="literal">MaxPoolSize</code> parameter in the ejb3-interceptors-aop.xml file. Configuring
         this has no actual effect on how many sessions/consumers there actually are created. This is because the Resource
      Adaptor implementation knows nothing about the application servers MDB implementation. So even if you set the MDB
         pool size to 1, 15 sessions/consumers will be created (this is the default). If you want to limit how many
         sessions/consumers are created then you need to set the <code class="literal">maxSession</code> parameter either on the
      resource adapter itself or via an an Activation Config Property on the MDB itself</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
@MessageDriven(name = "MDBMessageSendTxExample", activationConfig =
{
   @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue"),
   @ActivationConfigProperty(propertyName = "destination", propertyValue = "queue/testQueue"),
   @ActivationConfigProperty(propertyName = "maxSession", propertyValue = "1")
})
@TransactionManagement(value= TransactionManagementType.CONTAINER)
@TransactionAttribute(value= TransactionAttributeType.REQUIRED)
@ResourceAdapter("hornetq-ra.rar")
public class MyMDB implements MessageListener
{ ....}
      </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e8242"/>32.4. Configuring the JCA Adaptor</h2></div></div></div><p>The Java Connector Architecture (JCA) Adapter is what allows HornetQ to be integrated
            with JEE components such as MDBs and EJBs. It configures how components such as MDBs
            consume messages from the HornetQ server and also how components such as EJBs or
            Servlets can send messages.</p><p>The HornetQ JCA adapter is deployed via the <code class="literal">jms-ra.rar</code> archive. The
            configuration of the adapter is found in this archive under <code class="literal">META-INF/ra.xml</code>.</p><p>The configuration will look something like the following:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;resourceadapter&gt;
   &lt;resourceadapter-class&gt;org.hornetq.ra.HornetQResourceAdapter&lt;/resourceadapter-class&gt;
   &lt;config-property&gt;
      &lt;description&gt;The transport type. Multiple connectors can be configured by using a comma separated list,
         i.e. org.hornetq.core.remoting.impl.invm.InVMConnectorFactory,org.hornetq.core.remoting.impl.invm.InVMConnectorFactory.&lt;/description&gt;
      &lt;config-property-name&gt;ConnectorClassName&lt;/config-property-name&gt;
      &lt;config-property-type&gt;java.lang.String&lt;/config-property-type&gt;
      &lt;config-property-value&gt;org.hornetq.core.remoting.impl.invm.InVMConnectorFactory&lt;/config-property-value&gt;
   &lt;/config-property&gt;
   &lt;config-property&gt;
      &lt;description&gt;The transport configuration. These values must be in the form of key=val;key=val;,
         if multiple connectors are used then each set must be separated by a comma i.e. host=host1;port=5445,host=host2;port=5446.
         Each set of parameters maps to the connector classname specified.&lt;/description&gt;
      &lt;config-property-name&gt;ConnectionParameters&lt;/config-property-name&gt;
      &lt;config-property-type&gt;java.lang.String&lt;/config-property-type&gt;
      &lt;config-property-value&gt;server-id=0&lt;/config-property-value&gt;
   &lt;/config-property&gt;

   &lt;outbound-resourceadapter&gt;
      &lt;connection-definition&gt;
         &lt;managedconnectionfactory-class&gt;org.hornetq.ra.HornetQRAManagedConnection
         Factory&lt;/managedconnectionfactory-class&gt;

         &lt;config-property&gt;
            &lt;description&gt;The default session type&lt;/description&gt;
            &lt;config-property-name&gt;SessionDefaultType&lt;/config-property-name&gt;
            &lt;config-property-type&gt;java.lang.String&lt;/config-property-type&gt;
            &lt;config-property-value&gt;javax.jms.Queue&lt;/config-property-value&gt;
         &lt;/config-property&gt;
         &lt;config-property&gt;
            &lt;description&gt;Try to obtain a lock within specified number of seconds; less
            than or equal to 0 disable this functionality&lt;/description&gt;
            &lt;config-property-name&gt;UseTryLock&lt;/config-property-name&gt;
            &lt;config-property-type&gt;java.lang.Integer&lt;/config-property-type&gt;
            &lt;config-property-value&gt;0&lt;/config-property-value&gt;
         &lt;/config-property&gt;

         &lt;connectionfactory-interface&gt;org.hornetq.ra.HornetQRAConnectionFactory
         &lt;/connectionfactory-interface&gt;
         &lt;connectionfactororg.hornetq.ra.HornetQConnectionFactoryImplonFactoryImpl
         &lt;/connectionfactory-impl-class&gt;
         &lt;connection-interface&gt;javax.jms.Session&lt;/connection-interface&gt;
         &lt;connection-impl-class&gt;org.hornetq.ra.HornetQRASession
         &lt;/connection-impl-class&gt;
      &lt;/connection-definition&gt;
      &lt;transaction-support&gt;XATransaction&lt;/transaction-support&gt;
      &lt;authentication-mechanism&gt;
         &lt;authentication-mechanism-type&gt;BasicPassword
         &lt;/authentication-mechanism-type&gt;
         &lt;credential-interface&gt;javax.resource.spi.security.PasswordCredential
         &lt;/credential-interface&gt;
      &lt;/authentication-mechanism&gt;
      &lt;reauthentication-support&gt;false&lt;/reauthentication-support&gt;
   &lt;/outbound-resourceadapter&gt;

   &lt;inbound-resourceadapter&gt;
      &lt;messageadapter&gt;
         &lt;messagelistener&gt;
            &lt;messagelistener-type&gt;javax.jms.MessageListener&lt;/messagelistener-type&gt;
            &lt;activationspec&gt;
               &lt;activationspec-class&gt;org.hornetq.ra.inflow.HornetQActivationSpec
               &lt;/activationspec-class&gt;
               &lt;required-config-property&gt;
                   &lt;config-property-name&gt;destination&lt;/config-property-name&gt;
               &lt;/required-config-property&gt;
            &lt;/activationspec&gt;
         &lt;/messagelistener&gt;
      &lt;/messageadapter&gt;
   &lt;/inbound-resourceadapter&gt;
&lt;/resourceadapter&gt;</pre><p>There are three main parts to this configuration.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>A set of global properties for the adapter</p></li><li><p>The configuration for the outbound part of the adapter. This is used for
                    creating JMS resources within EE components. </p></li><li><p>The configuration of the inbound part of the adapter. This is used for
                    controlling the consumption of messages via MDBs. </p></li></ol></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8271"/>32.4.1. Global Properties</h3></div></div></div><p>The first element you see is <code class="literal">resourceadapter-class</code> which should
                be left unchanged. This is the HornetQ resource adapter class.</p><p>After that there is a list of configuration properties. This will be where most of
                the configuration is done. The first two properties configure the transport used by the adapter
                and the rest configure the connection factory itself.
            </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>All connection factory properties will use the defaults if they are not provided, except
                  for the <code class="literal">reconnectAttempts</code> which will default to -1. This
                  signifies that the connection should attempt to reconnect on connection
                  failure indefinitely. This is only used when the adapter is configured to
                  connect to a remote server as an InVM connector can never fail.
                </p></div><p>The following table explains what each property is for.</p><div class="table"><a id="d0e8289"/><p class="title"><b>Table 32.1. Global Configuration Properties</b></p><div class="table-contents"><table summary="Global Configuration Properties" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>Property Name</th><th>Property Type</th><th>Property Description</th></tr></thead><tbody><tr><td>ConnectorClassName</td><td>String</td><td>The Connector class name (see <a class="xref" href="#configuring-transports" title="Chapter 16. Configuring the Transport">Chapter 16, <i>Configuring the Transport</i></a> for more information). If multiple connectors are
                               needed this should be provided as a comma separated list.</td></tr><tr><td>ConnectionParameters</td><td>String</td><td>The transport configuration. These parameters must be in the form of
                                <code class="literal">key1=val1;key2=val2;</code> and will be specific to the connector used. If
                               multiple connectors are configured then parameters should be supplied for each connector
                               separated by a comma.
                            </td></tr><tr><td>ha</td><td>boolean</td><td>True if high availability is needed.</td></tr><tr><td>useLocalTx</td><td>boolean</td><td>True will enable local transaction optimisation.</td></tr><tr><td>UserName</td><td>String</td><td>The user name to use when making a connection </td></tr><tr><td>Password</td><td>String</td><td>The password to use when making a connection</td></tr><tr><td>
                               <a class="link" href="#">DiscoveryAddress</a></td><td>String</td><td>The discovery group address to use to auto-detect a server</td></tr><tr><td>
                               <a class="link" href="#">DiscoveryPort</a></td><td>Integer</td><td>The port to use for discovery</td></tr><tr><td>
                               <a class="link" href="#">DiscoveryRefreshTimeout</a></td><td>Long</td><td>The timeout, in milliseconds, to refresh.</td></tr><tr><td>
                               <a class="link" href="#configuration.connection-factory.discovery-initial-wait-timeout">
                                  DiscoveryInitialWaitTimeout
                               </a>
                            </td><td>Long</td><td>The initial time to wait for discovery.</td></tr><tr><td>
                               <a class="link" href="#configuration.connection-factory.connection-load-balancing-policy-class-name">
                                  ConnectionLoadBalancingPolicyClassName</a>
                            </td><td>String</td><td>The load balancing policy class to use.</td></tr><tr><td>
                               <a class="link" href="#configuration.connection-factory.connection-ttl">ConnectionTTL</a>
                            </td><td>Long</td><td>The time to live (in milliseconds) for the connection.</td></tr><tr><td>
                               <a class="link" href="#configuration.connection-factory.call-timeout">CallTimeout</a>
                            </td><td>Long</td><td>the call timeout (in milliseconds) for each packet sent.</td></tr><tr><td>
                               <a class="link" href="#configuration.connection-factory.dups-ok-batch-size">DupsOKBatchSize</a>
                            </td><td>Integer</td><td>the batch size (in bytes) between acknowledgements when using
                                 DUPS_OK_ACKNOWLEDGE mode</td></tr><tr><td>
                               <a class="link" href="#configuration.connection-factory.transaction-batch-size">TransactionBatchSize</a>
                            </td><td>Integer</td><td>the batch size (in bytes) between acknowledgements when using a
                                 transactional session</td></tr><tr><td>
                               <a class="link" href="#configuration.connection-factory.consumer-window-size">ConsumerWindowSize</a>
                            </td><td>Integer</td><td>the window size (in bytes) for consumer flow control</td></tr><tr><td>
                               <a class="link" href="#configuration.connection-factory.consumer-max-rate">ConsumerMaxRate</a>
                            </td><td>Integer</td><td>the fastest rate a consumer may consume messages per second</td></tr><tr><td>
                               <a class="link" href="#configuration.connection-factory.confirmation-window-size">ConfirmationWindowSize</a>
                            </td><td>Integer</td><td>the window size (in bytes) for reattachment confirmations</td></tr><tr><td>
                               <a class="link" href="#configuration.connection-factory.producer-max-rate">ProducerMaxRate</a>
                            </td><td>Integer</td><td>the maximum rate of messages per second that can be sent</td></tr><tr><td>
                               <a class="link" href="#configuration.connection-factory.min-large-message-size">MinLargeMessageSize</a>
                            </td><td>Integer</td><td>the size (in bytes) before a message is treated as large </td></tr><tr><td>
                               <a class="link" href="#configuration.connection-factory.block-on-acknowledge">BlockOnAcknowledge</a>
                            </td><td>Boolean</td><td>whether or not messages are acknowledged synchronously</td></tr><tr><td>
                               <a class="link" href="#configuration.connection-factory.block-on-non-durable-send">BlockOnNonDurableSend</a>
                            </td><td>Boolean</td><td>whether or not non-durable messages are sent synchronously</td></tr><tr><td>
                               <a class="link" href="#configuration.connection-factory.block-on-durable-send">BlockOnDurableSend</a>
                            </td><td>Boolean</td><td>whether or not durable messages are sent synchronously</td></tr><tr><td>
                               <a class="link" href="#configuration.connection-factory.auto-group">AutoGroup</a>
                            </td><td>Boolean</td><td>whether or not message grouping is automatically used</td></tr><tr><td>
                               <a class="link" href="#configuration.connection-factory.pre-acknowledge">PreAcknowledge</a>
                            </td><td>Boolean</td><td>whether messages are pre acknowledged by the server before
                                 sending</td></tr><tr><td>
                               <a class="link" href="#configuration.connection-factory.reconnect-attempts">ReconnectAttempts</a>
                            </td><td>Integer</td><td>maximum number of retry attempts, default for the resource adapter is -1 (infinite attempts)</td></tr><tr><td>
                               <a class="link" href="#configuration.connection-factory.retry-interval">RetryInterval</a>
                            </td><td>Long</td><td>the time (in milliseconds) to retry a connection after failing</td></tr><tr><td>
                               <a class="link" href="#configuration.connection-factory.retry-interval-multiplier">RetryIntervalMultiplier</a>
                            </td><td>Double</td><td>multiplier to apply to successive retry intervals</td></tr><tr><td>
                               <a class="link" href="#configuration.connection-factory.failover-on-server-shutdown">FailoverOnServerShutdown</a>
                            </td><td>Boolean</td><td>If true client will reconnect to another server if
                                available</td></tr><tr><td>
                               <a class="link" href="#configuration.connection-factory.client-id">ClientID</a>
                            </td><td>String</td><td>the pre-configured client ID for the connection factory</td></tr><tr><td>
                               <a class="link" href="#configuration.connection-factory.client-failure-check-period">ClientFailureCheckPeriod</a>
                            </td><td>Long</td><td>the period (in ms) after which the client will consider the
                                 connection failed after not receiving packets from the
                                 server</td></tr><tr><td>
                               <a class="link" href="#configuration.connection-factory.use-global-pools">UseGlobalPools</a>
                            </td><td>Boolean</td><td>whether or not to use a global thread pool for threads</td></tr><tr><td>
                               <a class="link" href="#configuration.connection-factory.scheduled-thread-pool-max-size">ScheduledThreadPoolMaxSize</a>
                            </td><td>Integer</td><td>the size of the <span class="emphasis"><em>scheduled thread</em></span> pool</td></tr><tr><td>
                               <a class="link" href="#configuration.connection-factory.thread-pool-max-size">ThreadPoolMaxSize</a>
                            </td><td>Integer</td><td>the size of the thread pool</td></tr><tr><td>SetupAttempts</td><td>Integer</td><td>Number of attempts to setup a JMS connection (default is 10, -1 means to attempt infinitely). It is possible
                               that the MDB is deployed before the JMS resources are available. In that case, the resource
                               adapter will try to setup several times until the resources are available. This applies only for inbound connections</td></tr><tr><td>SetupInterval</td><td>Long</td><td>Interval in milliseconds between consecutive attempts to setup a JMS connection (default is 2000m). This applies only for inbound connections</td></tr></tbody></table></div></div><br class="table-break"/></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8646"/>32.4.2. Adapter Outbound Configuration</h3></div></div></div><p>The outbound configuration should remain unchanged as they define connection
                factories that are used by Java EE components. These Connection Factories can be
                defined inside a configuration file that matches the name <code class="literal">*-ds.xml</code>. You'll find a default <code class="literal">jms-ds.xml</code>
                configuration under the <code class="literal">hornetq</code> directory in the JBoss AS
                deployment. The connection factories defined in this file inherit their
                properties from the main <code class="literal">ra.xml</code> configuration but can also be
                overridden. The following example shows how to override them.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Please note that this configuration only applies when HornetQ resource adapter is installed in 
                JBoss Application Server. If you are using another JEE application
                server please refer to your application servers documentation for how to do
                this.</p></div><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;tx-connection-factory&gt;
   &lt;jndi-name&gt;RemoteJmsXA&lt;/jndi-name&gt;
   &lt;xa-transaction/&gt;
   &lt;rar-name&gt;jms-ra.rar&lt;/rar-name&gt;
   &lt;connection-definition&gt;org.hornetq.ra.HornetQRAConnectionFactory
&lt;/connection-definition&gt;
&lt;config-property name="SessionDefaultType" type="String"&gt;javax.jms.Topic&lt;/config-property&gt;
   &lt;config-property name="ConnectorClassName" type="String"&gt;
      org.hornetq.core.remoting.impl.netty.NettyConnectorFactory
   &lt;/config-property&gt;
   &lt;config-property name="ConnectionParameters" type="String"&gt;
      port=5445&lt;/config-property&gt;
   &lt;max-pool-size&gt;20&lt;/max-pool-size&gt;
&lt;/tx-connection-factory&gt;</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>overriding connectors</h2><p>If the connector class name is overridden the all parameters must also be supplied.</p></div><p>In this example the connection factory will be bound to JNDI with the name
                    <code class="literal">RemoteJmsXA</code> and can be looked up in the usual way using JNDI
                or defined within the EJB or MDB as such:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
@Resource(mappedName="java:/RemoteJmsXA")
private ConnectionFactory connectionFactory;</pre><p>The <code class="literal">config-property</code> elements are what overrides those in the
                    <code class="literal">ra.xml</code> configuration file. Any of the elements pertaining to the
                connection factory can be overridden here.</p><p>The outbound configuration also defines additional properties in addition to the global configuration properties.</p><div class="table"><a id="d0e8690"/><p class="title"><b>Table 32.2. Outbound Configuration Properties</b></p><div class="table-contents"><table summary="Outbound Configuration Properties" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>Property Name</th><th>Property Type</th><th>Property Description</th></tr></thead><tbody><tr><td>SessionDefaultType</td><td>String</td><td>the default session type</td></tr><tr><td>UseTryLock</td><td>Integer</td><td>try to obtain a lock within specified number of seconds. less
                            than or equal to 0 disable this functionality</td></tr></tbody></table></div></div><br class="table-break"/></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8720"/>32.4.3. Adapter Inbound Configuration</h3></div></div></div><p>The inbound configuration should again remain unchanged. This controls what
                forwards messages onto MDBs. It is possible to override properties on the MDB by
                adding an activation configuration to the MDB itself. This could be used to
                configure the MDB to consume from a different server.</p><p>The inbound configuration also defines additional properties in addition to the global configuration properties.</p><div class="table"><a id="d0e8727"/><p class="title"><b>Table 32.3. Inbound Configuration Properties</b></p><div class="table-contents"><table summary="Inbound Configuration Properties" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>Property Name</th><th>Property Type</th><th>Property Description</th></tr></thead><tbody><tr><td>Destination</td><td>String</td><td>JNDI name of the destination</td></tr><tr><td>DestinationType</td><td>String</td><td>type of the destination, either <code class="literal">javax.jms.Queue</code> or <code class="literal">javax.jms.Topic</code>
                                 (default is javax.jms.Queue)</td></tr><tr><td>AcknowledgeMode</td><td>String</td><td>The Acknowledgment mode, either <code class="literal">Auto-acknowledge</code> or <code class="literal">Dups-ok-acknowledge</code>
                                (default is Auto-acknowledge). <code class="literal">AUTO_ACKNOWLEDGE</code> and <code class="literal">DUPS_OK_ACKNOWLEDGE</code> are acceptable values.</td></tr><tr><td>MaxSession</td><td>Integer</td><td>Maximum number of session created by this inbound configuration (default is 15)</td></tr><tr><td>MessageSelector</td><td>String</td><td>the message selector of the consumer</td></tr><tr><td>SubscriptionDurability</td><td>String</td><td>Type of the subscription, either <code class="literal">Durable</code> or <code class="literal">NonDurable</code></td></tr><tr><td>ShareSubscriptions</td><td>Boolean</td><td>When true, multiple MDBs can share the same <code class="literal">Durable</code> subscription</td></tr><tr><td>SubscriptionName</td><td>String</td><td>Name of the subscription</td></tr><tr><td>TransactionTimeout</td><td>Long</td><td>The transaction timeout in milliseconds (default is 0, the transaction does not timeout)</td></tr><tr><td>UseJNDI</td><td>Boolean</td><td>Whether or not use JNDI to look up the destination (default is true)</td></tr></tbody></table></div></div><br class="table-break"/></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8839"/>32.4.4. Configuring the adapter to use a standalone HornetQ Server</h3></div></div></div><p>Sometime you may want your messaging server on a different machine or separate from the application server.
          If this is the case you will only need the hornetq client libs installed. This section explains what config to create
          and what jar dependencies are needed.</p><div class="section" lang="en"><div class="titlepage"/><p>There are two configuration files needed to do this, one for the incoming adapter used for MDB's
                and one for outgoing connections managed by the JCA managed connection pool used by outgoing JEE components
             wanting outgoing connections.</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="d0e8847"/>32.4.4.1.1. Configuring the Incoming Adaptor</h5></div></div></div><p>Firstly you will need to create directory under the
                   <code class="literal">deploy</code>
                   directory ending in
                   <code class="literal">.rar.</code>
                      For this example we will name the directory <code class="literal">hornetq-ra.rar</code>. This detail is
                      important as
                      the name of directory is referred to by the MDB's and the outgoing configuration.

                </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>The jboss default for this is <code class="literal">jms-ra.rar</code>, If you don't want to have to
                      configure your
                      MDB's you can use this but you may need to remove the generic adaptor that uses this.
                   </p></div><p>Under the
                   <code class="literal">hornetq-ra.rar</code>
                   directory you will need to create a
                   <code class="literal">META-INF</code>
                   directory into which you should create an
                   <code class="literal">ra.xml</code>
                   configuration file. You can find a template
                   for the
                   <code class="literal">ra.xml</code>
                   under the config directory of the HornetQ distribution.
                </p><p>To configure MDB's to consume messages from a remote HornetQ server you need to edit the
                   <code class="literal">ra.xml</code>
                   file under
                   <code class="literal">deploy/hornet-ra.rar/META-INF</code>
                   and change the transport type to
                   use a netty connector (instead of the invm connector that is defined) and configure its transport
                   parameters.
                   Heres an example of what this would look like:
                </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;resourceadapter-class&gt;org.hornetq.ra.HornetQResourceAdapter&lt;/resourceadapter-class&gt;
   &lt;config-property&gt;
      &lt;description&gt;The transport type&lt;/description&gt;
      &lt;config-property-name&gt;ConnectorClassName&lt;/config-property-name&gt;
      &lt;config-property-type&gt;java.lang.String&lt;/config-property-type&gt;
      &lt;config-property-value&gt;org.hornetq.core.remoting.impl.netty.NettyConnectorFactory&lt;/config-property-value&gt;
   &lt;/config-property&gt;
      &lt;config-property&gt;
      &lt;description&gt;The transport configuration. These values must be in the form of key=val;key=val;&lt;/description&gt;
      &lt;config-property-name&gt;ConnectionParameters&lt;/config-property-name&gt;
      &lt;config-property-type&gt;java.lang.String&lt;/config-property-type&gt;
   &lt;config-property-value&gt;host=127.0.0.1;port=5446&lt;/config-property-value&gt;
&lt;/config-property&gt;</pre><p>
                   If you want to provide a list of servers that the adapter can connect to you can provide a list of
                   connectors, each separated by a comma.
                </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;resourceadapter-class&gt;org.hornetq.ra.HornetQResourceAdapter&lt;/resourceadapter-class&gt;
   &lt;config-property&gt;
      &lt;description&gt;The transport type&lt;/description&gt;
      &lt;config-property-name&gt;ConnectorClassName&lt;/config-property-name&gt;
      &lt;config-property-type&gt;java.lang.String&lt;/config-property-type&gt;
      &lt;config-property-value&gt;org.hornetq.core.remoting.impl.netty.NettyConnectorFactory,org.hornetq.core.remoting.impl.netty.NettyConnectorFactory&lt;/config-property-value&gt;
   &lt;/config-property&gt;
      &lt;config-property&gt;
      &lt;description&gt;The transport configuration. These values must be in the form of key=val;key=val;&lt;/description&gt;
      &lt;config-property-name&gt;ConnectionParameters&lt;/config-property-name&gt;
      &lt;config-property-type&gt;java.lang.String&lt;/config-property-type&gt;
   &lt;config-property-value&gt;host=127.0.0.1;port=5446,host=127.0.0.2;port=5447&lt;/config-property-value&gt;
&lt;/config-property&gt;</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>provide all parameters</h2><p>
                      Make sure you provide parameters for each connector configured. The position of the parameters in the
                      list maps to each connector provided.
                   </p></div><p>This configures the resource adapter to connect to a server running on localhost listening on port
                   5446
                </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="d0e8902"/>32.4.4.1.2. Configuring the outgoing adaptor</h5></div></div></div><p>You will also need to configure the outbound connection by creating a <code class="literal">hornetq-ds.xml</code>
                   and placing it under any directory that will be deployed under the <code class="literal">deploy</code> directory.
                   In a standard HornetQ jboss configuration this would be under <code class="literal">hornetq</code> or <code class="literal">hornetq.sar</code>
                   but you can place it where ever you like. Actually as long as it ends in <code class="literal">-ds.xml</code> you can
                   call it anything you like. You can again find a template for this file under the config directory of the
                   HornetQ distribution but called <code class="literal">jms-ds.xml</code> which is the jboss default.
                </p><p>The following example shows a sample configuration</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;tx-connection-factory&gt;
   &lt;jndi-name&gt;RemoteJmsXA&lt;/jndi-name&gt;
   &lt;xa-transaction/&gt;
   &lt;rar-name&gt;hornetq-ra.rar&lt;/rar-name&gt;
   &lt;connection-definition&gt;org.hornetq.ra.HornetQRAConnectionFactory&lt;/connection-definition&gt;
   &lt;config-property name="SessionDefaultType" type="java.lang.String"&gt;javax.jms.Topic&lt;/config-property&gt;
   &lt;config-property name="ConnectorClassName" type="java.lang.String"&gt;org.hornetq.core.remoting.impl.netty.NettyConnectorFactory&lt;/config-property&gt;
   &lt;config-property name="ConnectionParameters" type="java.lang.String"&gt;host=127.0.0.1;port=5446&lt;/config-property&gt;
   &lt;max-pool-size&gt;20&lt;/max-pool-size&gt;
&lt;/tx-connection-factory&gt;</pre><p>Again you will see that this uses the netty connector type and will connect to the HornetQ server
                   running on localhost and listening on port 5446. JEE components can access this by using JNDI and looking
                   up the connection factory using JNDI using <code class="literal">java:/RemoteJmsXA</code>, you can see that this
                   is defined under the<code class="literal">jndi-name</code> attribute. You will also note that the outgoing connection
                   will be created by the resource adaptor configured under the directory <code class="literal">hornetq-ra.rar</code>
                   as explained in the last section.
                </p><p>
                   Also if you want to configure multiple connectors do this as a comma separated list as in the ra configuration.
                </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="d0e8942"/>32.4.4.1.3. Jar dependencies</h5></div></div></div><p>This is a list of the HornetQ and third party jars needed</p><div class="table"><a id="d0e8947"/><p class="title"><b>Table 32.4. Jar Dependencies</b></p><div class="table-contents"><table summary="Jar Dependencies" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>Jar Name</th><th>Description</th><th>Location</th></tr></thead><tbody><tr><td>hornetq-ra.jar</td><td>The HornetQ resource adaptor classes</td><td>deploy/hornetq-ra.rar or equivalent</td></tr><tr><td>hornetq-core-client.jar</td><td>The HornetQ core client classes</td><td>either in the config lib, i.e. default/lib or the common lib dir, i.e. $JBOSS_HOME/common lib </td></tr><tr><td>hornetq-jms-client.jar</td><td>The HornetQ JMS classes</td><td>as above</td></tr><tr><td>netty.jar</td><td>The Netty transport classes</td><td>as above</td></tr></tbody></table></div></div><br class="table-break"/></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e8991"/>32.5. Configuring the JBoss Application Server to connect to Remote HornetQ Server</h2></div></div></div><p>This is a step by step guide on how to configure a JBoss application server that doesn't have HornetQ installed
            to use a remote instance of HornetQ</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e8996"/>32.5.1. Configuring JBoss 5</h3></div></div></div><p>Firstly download and install JBoss AS 5 as per the JBoss installation guide and HornetQ as per the
                HornetQ installation guide. After that the following steps are required</p><div class="itemizedlist"><ul><li><p>Copy the following jars from the HornetQ distribution to the <code class="literal">lib</code> directory of
                    which ever JBossAs configuration you have chosen, i.e. <code class="literal">default</code>.</p><div class="itemizedlist"><ul><li><p>hornetq-core-client.jar</p></li><li><p>hornetq-jms-client.jar</p></li><li><p>hornetq-ra.jar (this can be found inside the <code class="literal">hornetq-ra.rar</code> archive)</p></li><li><p>netty.jar</p></li></ul></div></li><li><p>create the directories <code class="literal">hornetq-ra.rar</code> and <code class="literal">hornetq-ra.rar/META-INF</code>
                        under the <code class="literal">deploy</code> directory in your JBoss config directory</p></li><li><p>under the <code class="literal">hornetq-ra.rar/META-INF</code> create a <code class="literal">ra.xml</code> file or
                    copy it from the HornetQ distribution (again it can be found in the <code class="literal">hornetq-ra.rar</code> archive)
                    and configure it as follows</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;connector xmlns="http://java.sun.com/xml/ns/j2ee"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee
           http://java.sun.com/xml/ns/j2ee/connector_1_5.xsd"
           version="1.5"&gt;

   &lt;description&gt;HornetQ 2.0 Resource Adapter Alternate Configuration&lt;/description&gt;
   &lt;display-name&gt;HornetQ 2.0 Resource Adapter Alternate Configuration&lt;/display-name&gt;

   &lt;vendor-name&gt;Red Hat Middleware LLC&lt;/vendor-name&gt;
   &lt;eis-type&gt;JMS 1.1 Server&lt;/eis-type&gt;
   &lt;resourceadapter-version&gt;1.0&lt;/resourceadapter-version&gt;

   &lt;license&gt;
      &lt;description&gt;
Copyright 2009 Red Hat, Inc.
 Red Hat licenses this file to you under the Apache License, version
 2.0 (the "License"); you may not use this file except in compliance
 with the License.  You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 implied.  See the License for the specific language governing
 permissions and limitations under the License.
      &lt;/description&gt;
      &lt;license-required&gt;true&lt;/license-required&gt;
   &lt;/license&gt;

   &lt;resourceadapter&gt;
      &lt;resourceadapter-class&gt;org.hornetq.ra.HornetQResourceAdapter&lt;/resourceadapter-class&gt;
      &lt;config-property&gt;
         &lt;description&gt;The transport type&lt;/description&gt;
         &lt;config-property-name&gt;ConnectorClassName&lt;/config-property-name&gt;
         &lt;config-property-type&gt;java.lang.String&lt;/config-property-type&gt;
         &lt;config-property-value&gt;org.hornetq.core.remoting.impl.netty.NettyConnectorFactory&lt;/config-property-value&gt;
      &lt;/config-property&gt;
      &lt;config-property&gt;
         &lt;description&gt;The transport configuration. These values must be in the form of key=val;key=val;&lt;/description&gt;
         &lt;config-property-name&gt;ConnectionParameters&lt;/config-property-name&gt;
         &lt;config-property-type&gt;java.lang.String&lt;/config-property-type&gt;
         <span xmlns="http://www.w3.org/1999/xhtml" class="bold"><strong> &lt;config-property-value&gt;host=127.0.0.1;port=5445&lt;/config-property-value&gt;</strong></span>
      &lt;/config-property&gt;

      &lt;outbound-resourceadapter&gt;
         &lt;connection-definition&gt;
            &lt;managedconnectionfactory-class&gt;org.hornetq.ra.HornetQRAManagedConnectionFactory&lt;/managedconnectionfactory-class&gt;

            &lt;config-property&gt;
               &lt;description&gt;The default session type&lt;/description&gt;
               &lt;config-property-name&gt;SessionDefaultType&lt;/config-property-name&gt;
               &lt;config-property-type&gt;java.lang.String&lt;/config-property-type&gt;
               &lt;config-property-value&gt;javax.jms.Queue&lt;/config-property-value&gt;
            &lt;/config-property&gt;
            &lt;config-property&gt;
               &lt;description&gt;Try to obtain a lock within specified number of seconds; less than or equal to 0 disable this functionality&lt;/description&gt;
               &lt;config-property-name&gt;UseTryLock&lt;/config-property-name&gt;
               &lt;config-property-type&gt;java.lang.Integer&lt;/config-property-type&gt;
               &lt;config-property-value&gt;0&lt;/config-property-value&gt;
            &lt;/config-property&gt;

            &lt;connectionfactory-interface&gt;org.hornetq.ra.HornetQRAConnectionFactory&lt;/connectionfactory-interface&gt;
            &lt;connectionfactory-impl-class&gt;org.hornetq.ra.HornetQRAConnectionFactoryImpl&lt;/connectionfactory-impl-class&gt;
            &lt;connection-interface&gt;javax.jms.Session&lt;/connection-interface&gt;
            &lt;connection-impl-class&gt;org.hornetq.ra.HornetQRASession&lt;/connection-impl-class&gt;
         &lt;/connection-definition&gt;
         &lt;transaction-support&gt;XATransaction&lt;/transaction-support&gt;
         &lt;authentication-mechanism&gt;
            &lt;authentication-mechanism-type&gt;BasicPassword&lt;/authentication-mechanism-type&gt;
            &lt;credential-interface&gt;javax.resource.spi.security.PasswordCredential&lt;/credential-interface&gt;
         &lt;/authentication-mechanism&gt;
         &lt;reauthentication-support&gt;false&lt;/reauthentication-support&gt;
      &lt;/outbound-resourceadapter&gt;

      &lt;inbound-resourceadapter&gt;
         &lt;messageadapter&gt;
            &lt;messagelistener&gt;
               &lt;messagelistener-type&gt;javax.jms.MessageListener&lt;/messagelistener-type&gt;
               &lt;activationspec&gt;
                  &lt;activationspec-class&gt;org.hornetq.ra.inflow.HornetQActivationSpec&lt;/activationspec-class&gt;
                  &lt;required-config-property&gt;
                      &lt;config-property-name&gt;destination&lt;/config-property-name&gt;
                  &lt;/required-config-property&gt;
               &lt;/activationspec&gt;
            &lt;/messagelistener&gt;
         &lt;/messageadapter&gt;
      &lt;/inbound-resourceadapter&gt;

   &lt;/resourceadapter&gt;
&lt;/connector&gt;</pre><p>The important part of this configuration is the part in bold, i.e. &lt;config-property-value&gt;host=127.0.0.1;port=5445&lt;/config-property-value&gt;.
                    This should be configured to the host and port of the remote HornetQ server.</p></li></ul></div><p>At this point you should be able to now deploy MDB's that consume from the remote server. You will however,
                have to make sure that your MDB's have the annotation <code class="literal">@ResourceAdapter("hornetq-ra.rar")</code>
            added, this is illustrated in the <a class="xref" href="#configuring-mdbs" title="32.1. Configuring Message-Driven Beans">Section 32.1, “Configuring Message-Driven Beans”</a> section.
            If you don't want to add this annotation then you can delete the generic resource adapter <code class="literal">jms-ra.rar</code>
            and rename the <code class="literal">hornetq-ra.rar</code> to this.</p><p>If you also want to use the remote HornetQ server for outgoing connections, i.e. sending messages, then
            do the following:</p><div class="itemizedlist"><ul><li><p>Create a file called <code class="literal">hornetq-ds.xml</code> in the <code class="literal">deploy</code> directory
                    (in fact you can call this anything you want as long as it ends in <code class="literal">-ds.xml</code>). Then
                        add the following:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;connection-factories&gt;
  &lt;!--
   JMS XA Resource adapter, use this for outbound JMS connections.
   Inbound connections are defined at the @MDB activation or at the resource-adapter properties.
  --&gt;
  &lt;tx-connection-factory&gt;
     &lt;jndi-name&gt;RemoteJmsXA&lt;/jndi-name&gt;
     &lt;xa-transaction/&gt;
     &lt;rar-name&gt;hornetq-ra.rar&lt;/rar-name&gt;
     &lt;connection-definition&gt;org.hornetq.ra.HornetQRAConnectionFactory&lt;/connection-definition&gt;
     &lt;config-property name="SessionDefaultType" type="java.lang.String"&gt;javax.jms.Topic&lt;/config-property&gt;
     &lt;config-property name="ConnectorClassName" type="java.lang.String"&gt;org.hornetq.core.remoting.impl.netty.NettyConnectorFactory&lt;/config-property&gt;
     &lt;config-property name="ConnectionParameters" type="java.lang.String"&gt;host=127.0.0.1;port=5445&lt;/config-property&gt;
     &lt;max-pool-size&gt;20&lt;/max-pool-size&gt;
  &lt;/tx-connection-factory&gt;


&lt;/connection-factories&gt;</pre><p>Again you will see that the host and port are configured here to match the remote HornetQ servers
                        configuration. The other important attributes are:</p><div class="itemizedlist"><ul><li><p>jndi-name - This is the name used to look up the JMS connection factory from within your JEE client</p></li><li><p>rar-name - This should match the directory that you created to hold the Resource Adapter
                            configuration</p></li></ul></div></li></ul></div><p>Now you should be able to send messages using the JCA JMS connection pooling within an XA transaction.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9100"/>32.5.2. Configuring JBoss 5</h3></div></div></div><p>The steps to do this are exactly the same as for JBoss 4, you will have to create a jboss.xml definition
                file for your MDB with the following entry</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;message-driven&gt;
    &lt;ejb-name&gt;MyMDB&lt;/ejb-name&gt;
    &lt;resource-adapter-name&gt;jms-ra.rar&lt;/resource-adapter-name&gt;
 &lt;/message-driven&gt;</pre><p>Also you will need to edit the <code class="literal">standardjboss.xml</code> and uncomment the section with the
            following 'Uncomment to use JMS message inflow from jmsra.rar' and then comment out the invoker-proxy-binding
            called 'message-driven-bean'</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e9112"/>32.6. High Availability JNDI (HA-JNDI)</h2></div></div></div><p>If you are using JNDI to look-up JMS queues, topics and connection factories from a
            cluster of servers, it is likely you will want to use HA-JNDI so that your JNDI look-ups
            will continue to work if one or more of the servers in the cluster fail.</p><p>HA-JNDI is a JBoss Application Server service which allows you to use JNDI from
            clients without them having to know the exact JNDI connection details of every server in
            the cluster. This service is only available if using a cluster of JBoss Application
            Server instances.</p><p>To use it use the following properties when connecting to JNDI.</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
Hashtable&lt;String, String&gt; jndiParameters = new Hashtable&lt;String, String&gt;();
jndiParameters.put("java.naming.factory.initial", "org.jnp.interfaces.NamingContextFactory");
jndiParameters.put("java.naming.factory.url.pkgs=", "org.jboss.naming:org.jnp.interfaces");

initialContext = new InitialContext(jndiParameters);</pre><p>For more information on using HA-JNDI see the <a class="ulink" href="http://www.jboss.org/file-access/default/members/jbossas/freezone/docs/Clustering_Guide/5/html/clustering-jndi.html">JBoss Application Server clustering documentation</a></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="xa-recovery"/>32.7. XA Recovery</h2></div></div></div><p><span class="emphasis"><em>XA recovery</em></span> deals with system or application failures to ensure
            that of a transaction are applied consistently to all resources affected by the
            transaction, even if any of the application processes or the machine hosting them crash
            or lose network connectivity. For more information on XA Recovery,please refer to <a class="ulink" href="http://www.jboss.org/community/wiki/JBossTransactions">JBoss
                Transactions</a>.</p><p>When HornetQ is integrated with JBoss AS, it can take advantage of JBoss Transactions
            to provide recovery of messaging resources. If messages are involved in a XA
            transaction, in the event of a server crash, the recovery manager will ensure that the
            transactions are recovered and the messages will either be committed or rolled back
            (depending on the transaction outcome) when the server is restarted.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9139"/>32.7.1. XA Recovery Configuration</h3></div></div></div><p>To enable HornetQ's XA Recovery, the Recovery Manager must be configured to connect
                to HornetQ to recover its resources. The following property must be added to the
                    <code class="literal">jta</code> section of <code class="literal">conf/jbossts-properties.xml</code>
                of JBoss AS profiles:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;properties depends="arjuna" name="jta"&gt;
   ...
                     
   &lt;property name="com.arjuna.ats.jta.recovery.XAResourceRecovery.HornetQ1"
                value="org.hornetq.jms.server.recovery.HornetQXAResourceRecovery;[connection configuration]"/&gt;
   &lt;property name="com.arjuna.ats.jta.xaRecoveryNode" value="1"/&gt;
&lt;/properties&gt;</pre><p>The <code class="literal">[connection configuration]</code> contains all the information
                required to connect to HornetQ node under the form <code class="literal">[connector factory class
                    name],[user name], [password], [connector parameters]</code>. </p><div class="itemizedlist"><ul><li><p><code class="literal">[connector factory class name]</code> corresponds to the name
                        of the <code class="literal">ConnectorFactory</code> used to connect to HornetQ.
                        Values can be <code class="literal">org.hornetq.core.remoting.impl.invm.InVMConnectorFactory</code> or
                            <code class="literal">org.hornetq.core.remoting.impl.netty.NettyConnectorFactory</code></p></li><li><p><code class="literal">[user name]</code> is the user name to create a client
                        session. It is optional</p></li><li><p><code class="literal">[password]</code> is the password to create a client session.
                        It is mandatory only if the user name is specified</p></li><li><p><code class="literal">[connector parameters]</code> is a list of comma-separated
                        key=value pair which are passed to the connector factory (see <a class="xref" href="#configuring-transports" title="Chapter 16. Configuring the Transport">Chapter 16, <i>Configuring the Transport</i></a> for a list of the transport
                        parameters).</p></li></ul></div><p>Also note the <code class="literal">com.arjuna.ats.jta.xaRecoveryNode</code> parameter. If you want recovery
              enabled then this must be configured to what ever the tx node id is set to, this is configured in the
           same file by the <code class="literal">com.arjuna.ats.arjuna.xa.nodeIdentifier</code> property.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>HornetQ must have a valid acceptor which corresponds to the connector
                    specified in <code class="literal">conf/jbossts-properties.xml</code>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e9205"/>32.7.1.1. Configuration Settings</h4></div></div></div><p>If HornetQ is configured with a default in-vm acceptor:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;acceptor name="in-vm"&gt;
   &lt;factory-class&gt;org.hornetq.core.remoting.impl.invm.InVMAcceptorFactory&lt;/factory-class&gt;
&lt;/acceptor&gt;</pre><p>the corresponding configuration in <code class="literal">conf/jbossts-properties.xml</code> is:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;property name="com.arjuna.ats.jta.recovery.XAResourceRecovery.HORNETQ1"
   value="org.hornetq.jms.server.recovery.HornetQXAResourceRecovery;org.hornetq.core.remoting.impl.invm.InVMConnectorFactory"/&gt;</pre><p>If it is now configured with a netty acceptor on a non-default port:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;acceptor name="netty"&gt;
   &lt;factory-class&gt;org.hornetq.core.remoting.impl.netty.NettyAcceptorFactory&lt;/factory-class&gt;
   &lt;param key="port" value="8888"/&gt;
&lt;/acceptor&gt;</pre><p>the corresponding configuration in <code class="literal">conf/jbossts-properties.xml</code> is:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;property name="com.arjuna.ats.jta.recovery.XAResourceRecovery.HORNETQ1"
       value="org.hornetq.jms.server.recovery.HornetQXAResourceRecovery;org.hornetq.core.remoting.impl.netty.NettyConnectorFactory, , , port=8888"/&gt;</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Note the additional commas to skip the user and password before connector
                        parameters</p></div><p>If the recovery must use <code class="literal">admin, adminpass</code>, the
                    configuration would have been:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;property name="com.arjuna.ats.jta.recovery.XAResourceRecovery.HORNETQ1"
      value="org.hornetq.jms.server.recovery.HornetQXAResourceRecovery;org.hornetq.core.remoting.impl.netty.NettyConnectorFactory, admin, adminpass, port=8888"/&gt;</pre><p>Configuring HornetQ with an invm acceptor and configuring the Recovery Manager
                    with an invm connector is the recommended way to enable XA Recovery.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9242"/>32.7.2. Example</h3></div></div></div><p>See <a class="xref" href="#xa-recovery-example" title="11.3.8. XA Recovery">Section 11.3.8, “XA Recovery”</a> which shows how to configure XA Recovery
                and recover messages after a server crash.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="jms-bridge"/>Chapter 33. The JMS Bridge</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e9297">33.1. JMS Bridge Parameters</a></span></dt><dt><span class="section"><a href="#d0e9506">33.2. Source and Target Connection Factories</a></span></dt><dt><span class="section"><a href="#d0e9516">33.3. Source and Target Destination Factories</a></span></dt><dt><span class="section"><a href="#quality-of-service">33.4. Quality Of Service</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9533">33.4.1. AT_MOST_ONCE</a></span></dt><dt><span class="section"><a href="#d0e9540">33.4.2. DUPLICATES_OK</a></span></dt><dt><span class="section"><a href="#d0e9547">33.4.3. ONCE_AND_ONLY_ONCE</a></span></dt><dt><span class="section"><a href="#d0e9557">33.4.4. Time outs and the JMS bridge</a></span></dt><dt><span class="section"><a href="#d0e9584">33.4.5. Examples</a></span></dt></dl></dd></dl></div><p>HornetQ includes a fully functional JMS message bridge.</p><p>The function of the bridge is to consume messages from a source queue or topic, and
            send them to a target queue or topic, typically on a different server.</p><p>The source and target servers do not have to be in the same cluster which makes
            bridging suitable for reliably sending messages from one cluster to another, for
            instance across a WAN, and where the connection may be unreliable.</p><p>A bridge can be deployed as a standalone application, with HornetQ standalone server or inside a JBoss AS
            instance. The source and the target can be located in the same virtual machine or another one.</p><p>The bridge can also be used to bridge messages from other non HornetQ JMS servers, as
            long as they are JMS 1.1 compliant.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Do not confuse a JMS bridge with a core
                    bridge. A JMS bridge can be used to bridge any two JMS 1.1 compliant JMS
                    providers and uses the JMS API. A core bridge (described in <a class="xref" href="#core-bridges" title="Chapter 36. Core Bridges">Chapter 36, <i>Core Bridges</i></a>) is used to bridge any two HornetQ instances and
                    uses the core API. Always use a core bridge if you can in preference to a JMS
                    bridge. The core bridge will typically provide better performance than a JMS
                    bridge. Also the core bridge can provide <span class="emphasis"><em>once and only once</em></span>
                    delivery guarantees without using XA.</p></div><p>The bridge has built-in resilience to failure so if the source or target server
            connection is lost, e.g. due to network failure, the bridge will retry connecting to the
            source and/or target until they come back online. When it comes back online it will
            resume operation as normal.</p><p>The bridge can be configured with an optional JMS selector, so it will only consume
            messages matching that JMS selector</p><p>It can be configured to consume from a queue or a topic. When it consumes from a topic
            it can be configured to consume using a non durable or durable subscription</p><p>Typically, the bridge is deployed by the JBoss Micro Container via a beans configuration file.
            This would typically be deployed inside the JBoss Application Server and the following
            example shows an example of a beans file that bridges 2 destinations which are actually
            on the same server. </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;deployment xmlns="urn:jboss:bean-deployer:2.0"&gt;
   &lt;bean name="JMSBridge" class="org.hornetq.api.jms.bridge.impl.JMSBridgeImpl"&gt;
      &lt;!-- HornetQ must be started before the bridge --&gt;
      &lt;depends&gt;HornetQServer&lt;/depends&gt;
      &lt;constructor&gt;
         &lt;!-- Source ConnectionFactory Factory --&gt;
         &lt;parameter&gt;
            &lt;inject bean="SourceCFF"/&gt;
         &lt;/parameter&gt;
         &lt;!-- Target ConnectionFactory Factory --&gt;
         &lt;parameter&gt;
            &lt;inject bean="TargetCFF"/&gt;
         &lt;/parameter&gt;
         &lt;!-- Source DestinationFactory --&gt;
         &lt;parameter&gt;
            &lt;inject bean="SourceDestinationFactory"/&gt;
         &lt;/parameter&gt;
         &lt;!-- Target DestinationFactory --&gt;
         &lt;parameter&gt;
            &lt;inject bean="TargetDestinationFactory"/&gt;
         &lt;/parameter&gt;
         &lt;!-- Source User Name (no username here) --&gt;
         &lt;parameter&gt;&lt;null /&gt;&lt;/parameter&gt;
         &lt;!-- Source Password (no password here)--&gt;
         &lt;parameter&gt;&lt;null /&gt;&lt;/parameter&gt;
         &lt;!-- Target User Name (no username here)--&gt;
         &lt;parameter&gt;&lt;null /&gt;&lt;/parameter&gt;
         &lt;!-- Target Password (no password here)--&gt;
         &lt;parameter&gt;&lt;null /&gt;&lt;/parameter&gt;
         &lt;!-- Selector --&gt;
         &lt;parameter&gt;&lt;null /&gt;&lt;/parameter&gt;
         &lt;!-- Failure Retry Interval (in ms) --&gt;
         &lt;parameter&gt;5000&lt;/parameter&gt;
         &lt;!-- Max Retries --&gt;
         &lt;parameter&gt;10&lt;/parameter&gt;
         &lt;!-- Quality Of Service --&gt;
         &lt;parameter&gt;ONCE_AND_ONLY_ONCE&lt;/parameter&gt;
         &lt;!-- Max Batch Size --&gt;
         &lt;parameter&gt;1&lt;/parameter&gt;
         &lt;!-- Max Batch Time (-1 means infinite) --&gt;
         &lt;parameter&gt;-1&lt;/parameter&gt;
         &lt;!-- Subscription name (no subscription name here)--&gt;
         &lt;parameter&gt;&lt;null /&gt;&lt;/parameter&gt;
         &lt;!-- Client ID  (no client ID here)--&gt;
         &lt;parameter&gt;&lt;null /&gt;&lt;/parameter&gt;
         &lt;!-- Add MessageID In Header --&gt;
         &lt;parameter&gt;true&lt;/parameter&gt;
         &lt;!-- register the JMS Bridge in the AS MBeanServer --&gt;
         &lt;parameter&gt;
            &lt;inject bean="MBeanServer"/&gt;
         &lt;/parameter&gt;
         &lt;parameter&gt;org.hornetq:service=JMSBridge&lt;/parameter&gt;
      &lt;/constructor&gt;
      &lt;property name="transactionManager"&gt;
         &lt;inject bean="RealTransactionManager"/&gt;
      &lt;/property&gt;
   &lt;/bean&gt;

   &lt;!-- SourceCFF describes the ConnectionFactory used to connect to the source destination --&gt;
   &lt;bean name="SourceCFF"
       class="org.hornetq.api.jms.bridge.impl.JNDIConnectionFactoryFactory"&gt;
      &lt;constructor&gt;
         &lt;parameter&gt;
            &lt;inject bean="JNDI" /&gt;
         &lt;/parameter&gt;
         &lt;parameter&gt;/ConnectionFactory&lt;/parameter&gt;
      &lt;/constructor&gt;
   &lt;/bean&gt;

   &lt;!-- TargetCFF describes the ConnectionFactory used to connect to the target destination --&gt;
   &lt;bean name="TargetCFF"
       class="org.hornetq.api.jms.bridge.impl.JNDIConnectionFactoryFactory"&gt;
      &lt;constructor&gt;
         &lt;parameter&gt;
            &lt;inject bean="JNDI" /&gt;
         &lt;/parameter&gt;
         &lt;parameter&gt;/ConnectionFactory&lt;/parameter&gt;
      &lt;/constructor&gt;
   &lt;/bean&gt;

   &lt;!-- SourceDestinationFactory describes the Destination used as the source --&gt;
   &lt;bean name="SourceDestinationFactory" class="org.hornetq.api.jms.bridge.impl.JNDIDestinationFactory"&gt;
      &lt;constructor&gt;
         &lt;parameter&gt;
            &lt;inject bean="JNDI" /&gt;
         &lt;/parameter&gt;
         &lt;parameter&gt;/queue/source&lt;/parameter&gt;
      &lt;/constructor&gt;
   &lt;/bean&gt;

   &lt;!-- TargetDestinationFactory describes the Destination used as the target --&gt;
   &lt;bean name="TargetDestinationFactory" class="org.hornetq.api.jms.bridge.impl.JNDIDestinationFactory"&gt;
      &lt;constructor&gt;
         &lt;parameter&gt;
            &lt;inject bean="JNDI" /&gt;
         &lt;/parameter&gt;
         &lt;parameter&gt;/queue/target&lt;/parameter&gt;
      &lt;/constructor&gt;
   &lt;/bean&gt;

   &lt;!-- JNDI is a Hashtable containing the JNDI properties required --&gt;
   &lt;!-- to connect to the sources and targets JMS resrouces         --&gt;
   &lt;bean name="JNDI" class="java.util.Hashtable"&gt;
      &lt;constructor class="java.util.Map"&gt;
         &lt;map class="java.util.Hashtable" keyClass="String"
                                          valueClass="String"&gt;
            &lt;entry&gt;
               &lt;key&gt;java.naming.factory.initial&lt;/key&gt;
               &lt;value&gt;org.jnp.interfaces.NamingContextFactory&lt;/value&gt;
            &lt;/entry&gt;
            &lt;entry&gt;
               &lt;key&gt;java.naming.provider.url&lt;/key&gt;
               &lt;value&gt;jnp://localhost:1099&lt;/value&gt;
            &lt;/entry&gt;
            &lt;entry&gt;
               &lt;key&gt;java.naming.factory.url.pkgs&lt;/key&gt;
               &lt;value&gt;org.jboss.naming:org.jnp.interfaces"&lt;/value&gt;
            &lt;/entry&gt;
            &lt;entry&gt;
               &lt;key&gt;jnp.timeout&lt;/key&gt;
               &lt;value&gt;5000&lt;/value&gt;
            &lt;/entry&gt;
            &lt;entry&gt;
               &lt;key&gt;jnp.sotimeout&lt;/key&gt;
               &lt;value&gt;5000&lt;/value&gt;
            &lt;/entry&gt;
         &lt;/map&gt;
      &lt;/constructor&gt;
   &lt;/bean&gt;

   &lt;bean name="MBeanServer" class="javax.management.MBeanServer"&gt;
      &lt;constructor factoryClass="org.jboss.mx.util.MBeanServerLocator" factoryMethod="locateJBoss"/&gt;
   &lt;/bean&gt;
&lt;/deployment&gt;</pre><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e9297"/>33.1. JMS Bridge Parameters</h2></div></div></div><p>The main bean deployed is the <code class="literal">JMSBridge</code> bean. The bean is
                configurable by the parameters passed to its constructor.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>To let a parameter be unspecified (for example, if the authentication is
                    anonymous or no message selector is provided), use <code class="literal">&lt;null
                        /&gt;</code> for the unspecified parameter value.</p></div><div class="itemizedlist"><ul><li><p>Source Connection Factory Factory</p><p>This injects the <code class="literal">SourceCFF</code> bean (also defined in the
                        beans file). This bean is used to create the <span class="emphasis"><em>source</em></span>
                        <code class="literal">ConnectionFactory</code>
                    </p></li><li><p>Target Connection Factory Factory</p><p>This injects the <code class="literal">TargetCFF</code> bean (also defined in the
                        beans file). This bean is used to create the <span class="emphasis"><em>target</em></span>
                        <code class="literal">ConnectionFactory</code>
                    </p></li><li><p>Source Destination Factory Factory</p><p>This injects the <code class="literal">SourceDestinationFactory</code> bean (also
                        defined in the beans file). This bean is used to create the
                            <span class="emphasis"><em>source</em></span>
                        <code class="literal">Destination</code>
                    </p></li><li><p>Target Destination Factory Factory</p><p>This injects the <code class="literal">TargetDestinationFactory</code> bean (also
                        defined in the beans file). This bean is used to create the
                            <span class="emphasis"><em>target</em></span>
                        <code class="literal">Destination</code>
                    </p></li><li><p>Source User Name</p><p>this parameter is the username for creating the
                            <span class="emphasis"><em>source</em></span> connection</p></li><li><p>Source Password</p><p>this parameter is the parameter for creating the
                            <span class="emphasis"><em>source</em></span> connection</p></li><li><p>Target User Name</p><p>this parameter is the username for creating the
                            <span class="emphasis"><em>target</em></span> connection</p></li><li><p>Target Password</p><p>this parameter is the password for creating the
                            <span class="emphasis"><em>target</em></span> connection</p></li><li><p>Selector</p><p>This represents a JMS selector expression used for consuming messages from
                        the source destination. Only messages that match the selector expression
                        will be bridged from the source to the target destination</p><p>The selector expression must follow the <a class="ulink" href="http://docs.oracle.com/javaee/6/api/javax/jms/Message.html">JMS
                            selector syntax</a></p></li><li><p>Failure Retry Interval</p><p>This represents the amount of time in ms to wait between trying to
                        recreate connections to the source or target servers when the bridge has
                        detected they have failed</p></li><li><p>Max Retries</p><p>This represents the number of times to attempt to recreate connections to
                        the source or target servers when the bridge has detected they have failed.
                        The bridge will give up after trying this number of times. <code class="literal">-1</code> represents 'try forever'</p></li><li><p>Quality Of Service</p><p>This parameter represents the desired quality of service mode</p><p>Possible values are:</p><div class="itemizedlist"><ul><li><p><code class="literal">AT_MOST_ONCE</code></p></li><li><p><code class="literal">DUPLICATES_OK</code></p></li><li><p><code class="literal">ONCE_AND_ONLY_ONCE</code></p></li></ul></div><p>See <a class="xref" href="#quality-of-service" title="33.4. Quality Of Service">Section 33.4, “Quality Of Service”</a> for a explanation of these
                        modes.</p></li><li><p>Max Batch Size</p><p>This represents the maximum number of messages to consume from the source
                        destination before sending them in a batch to the target destination. Its
                        value must <code class="literal">&gt;= 1</code>
                    </p></li><li><p>Max Batch Time</p><p>This represents the maximum number of milliseconds to wait before sending
                        a batch to target, even if the number of messages consumed has not reached
                            <code class="literal">MaxBatchSize</code>. Its value must be <code class="literal">-1</code>
                        to represent 'wait forever', or <code class="literal">&gt;= 1</code> to specify an actual
                        time </p></li><li><p>Subscription Name</p><p>If the source destination represents a topic, and you want to consume from
                        the topic using a durable subscription then this parameter represents the
                        durable subscription name</p></li><li><p>Client ID</p><p>If the source destination represents a topic, and you want to consume from
                        the topic using a durable subscription then this attribute represents the
                        the JMS client ID to use when creating/looking up the durable
                        subscription</p></li><li><p>Add MessageID In Header</p><p>If <code class="literal">true</code>, then the original message's message ID will be
                        appended in the message sent to the destination in the header <code class="literal">HORNETQ_BRIDGE_MSG_ID_LIST</code>. If the message is bridged more
                        than once, each message ID will be appended. This enables a distributed
                        request-response pattern to be used</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>when you receive the message you can send back a response using the
                            correlation id of the first message id, so when the original sender gets
                            it back it will be able to correlate it. </p></div></li><li><p>MBean Server</p><p>To manage the JMS Bridge using JMX, set the MBeanServer where the JMS Bridge MBean
                      must be registered (e.g. the JVM Platform MBeanServer or JBoss AS MBeanServer)</p></li><li><p>ObjectName</p><p>If you set the MBeanServer, you also need to set the ObjectName used to register
                      the JMS Bridge MBean (must be unique)</p></li></ul></div><p>The "transactionManager" property points to a JTA transaction manager implementation.
                HornetQ doesn't ship with such an implementation, but one is available in the JBoss
                Community.  If you are running HornetQ in standalone mode and wish to use a JMS bridge
                simply download the latest version of JBossTS from http://www.jboss.org/jbosstm/downloads
                and add it to HornetQ's classpath.  If you are running HornetQ with JBoss AS then you
                won't need to do this as JBoss AS ships with a JTA transaction manager already.  The
                bean definition for the transaction manager would look something like this:
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">&lt;bean name="RealTransactionManager" class="com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionManagerImple"/&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e9506"/>33.2. Source and Target Connection Factories</h2></div></div></div><p>The source and target connection factory factories are used to create the
                connection factory used to create the connection for the source or target
                server.</p><p>The configuration example above uses the default implementation provided by
                HornetQ that looks up the connection factory using JNDI. For other Application
                Servers or JMS providers a new implementation may have to be provided. This can
                easily be done by implementing the interface <code class="literal">org.hornetq.jms.bridge.ConnectionFactoryFactory</code>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e9516"/>33.3. Source and Target Destination Factories</h2></div></div></div><p>Again, similarly, these are used to create or lookup up the destinations.</p><p>In the configuration example above, we have used the default provided by HornetQ
                that looks up the destination using JNDI.</p><p>A new implementation can be provided by implementing <code class="literal">org.hornetq.jms.bridge.DestinationFactory</code> interface.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="quality-of-service"/>33.4. Quality Of Service</h2></div></div></div><p>The quality of service modes used by the bridge are described here in more
                detail.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9533"/>33.4.1. AT_MOST_ONCE</h3></div></div></div><p>With this QoS mode messages will reach the destination from the source at most
                    once. The messages are consumed from the source and acknowledged before sending
                    to the destination. Therefore there is a possibility that if failure occurs
                    between removing them from the source and them arriving at the destination they
                    could be lost. Hence delivery will occur at most once.</p><p>This mode is available for both durable and non-durable messages.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9540"/>33.4.2. DUPLICATES_OK</h3></div></div></div><p>With this QoS mode, the messages are consumed from the source and then
                    acknowledged after they have been successfully sent to the destination.
                    Therefore there is a possibility that if failure occurs after sending to the
                    destination but before acknowledging them, they could be sent again when the
                    system recovers. I.e. the destination might receive duplicates after a
                    failure.</p><p>This mode is available for both durable and non-durable messages.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9547"/>33.4.3. ONCE_AND_ONLY_ONCE</h3></div></div></div><p>This QoS mode ensures messages will reach the destination from the source once
                    and only once. (Sometimes this mode is known as "exactly once"). If both the
                    source and the destination are on the same HornetQ server instance then this can
                    be achieved by sending and acknowledging the messages in the same local
                    transaction. If the source and destination are on different servers this is
                    achieved by enlisting the sending and consuming sessions in a JTA transaction.
                    The JTA transaction is controlled by JBoss Transactions JTA * implementation
                    which is a fully recovering transaction manager, thus providing a very high
                    degree of durability. If JTA is required then both supplied connection factories
                    need to be XAConnectionFactory implementations. This is likely to be the slowest
                    mode since it requires extra persistence for the transaction logging.</p><p>This mode is only available for durable messages.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>For a specific application it may possible to provide once and only once
                        semantics without using the ONCE_AND_ONLY_ONCE QoS level. This can be done
                        by using the DUPLICATES_OK mode and then checking for duplicates at the
                        destination and discarding them. Some JMS servers provide automatic
                        duplicate message detection functionality, or this may be possible to
                        implement on the application level by maintaining a cache of received
                        message ids on disk and comparing received messages to them. The cache would
                        only be valid for a certain period of time so this approach is not as
                        watertight as using ONCE_AND_ONLY_ONCE but may be a good choice depending on
                        your specific application.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9557"/>33.4.4. Time outs and the JMS bridge</h3></div></div></div><p>There is a possibility that the target or source server will not be available at some point in time.
              If this occurs then the bridge will try <code class="literal">Max Retries</code> to reconnect every
              <code class="literal">Failure Retry Interval</code> milliseconds as specified in the JMS Bridge definition.</p><p>However since a third party JNDI is used, in this case the JBoss naming server, it is possible for the
              JNDI lookup to hang if the network were to disappear during the JNDI lookup. To stop this from occurring the JNDI
              definition can be configured to time out if this occurs. To do this set the <code class="literal">jnp.timeout</code>
               and the <code class="literal">jnp.sotimeout</code> on the Initial Context definition. The first sets the connection
              timeout for the initial connection and the second the read timeout for the socket.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Once the initial JNDI connection has succeeded all calls are made using RMI. If you want to control
                    the timeouts for the RMI connections then this can be done via system properties. JBoss uses Sun's RMI
                 and the properties can be found <a class="ulink" href="http://docs.oracle.com/javase/6/docs/technotes/guides/rmi/sunrmiproperties.html">here</a>.
                 The default connection timeout is 10 seconds and the default read timeout is 18 seconds.</p></div><p>If you implement your own factories for looking up JMS resources then you will have to bear in mind timeout issues.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e9584"/>33.4.5. Examples</h3></div></div></div><p>Please see <a class="xref" href="#examples.javaee.jms-bridge" title="11.3.4. JMS Bridge">Section 11.3.4, “JMS Bridge”</a> which shows how to configure
                    and use a JMS Bridge with JBoss AS to send messages to the source destination and consume them
                    from the target destination.</p><p>Please see <a class="xref" href="#examples.jms.jms-bridge" title="11.1.32. JMS Bridge">Section 11.1.32, “JMS Bridge”</a> which shows how to configure
                    and use a JMS Bridge between two standalone HornetQ servers.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="client-reconnection"/>Chapter 34. Client Reconnection and Session Reattachment</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e9617">34.1. 100% Transparent session re-attachment</a></span></dt><dt><span class="section"><a href="#d0e9666">34.2. Session reconnection</a></span></dt><dt><span class="section"><a href="#d0e9685">34.3. Configuring reconnection/reattachment attributes</a></span></dt><dt><span class="section"><a href="#client-reconnection.exceptionlistener">34.4. ExceptionListeners and SessionFailureListeners</a></span></dt></dl></div><p>HornetQ clients can be configured to automatically reconnect or re-attach to the server in
        the event that a failure is detected in the connection between the client and the server. </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e9617"/>34.1. 100% Transparent session re-attachment</h2></div></div></div><p>If the failure was due to some transient failure such as a temporary network failure,
            and the target server was not restarted, then the sessions will still be existent on the
            server, assuming the client hasn't been disconnected for more than connection-ttl <a class="xref" href="#connection-ttl" title="Chapter 17. Detecting Dead Connections">Chapter 17, <i>Detecting Dead Connections</i></a>.</p><p>In this scenario, HornetQ will automatically re-attach the client sessions to the
            server sessions when the connection reconnects. This is done 100% transparently and the
            client can continue exactly as if nothing had happened.</p><p>The way this works is as follows:</p><p>As HornetQ clients send commands to their servers they store each sent command in an
            in-memory buffer. In the case that connection failure occurs and the client subsequently
            reattaches to the same server, as part of the reattachment protocol the server informs
            the client during reattachment with the id of the last command it successfully received
            from that client.</p><p>If the client has sent more commands than were received before failover it can replay
            any sent commands from its buffer so that the client and server can reconcile their
            states.</p><p>The size of this buffer is configured by the <code class="literal">ConfirmationWindowSize</code>
            parameter, when the server has received <code class="literal">ConfirmationWindowSize</code> bytes
            of commands and processed them it will send back a command confirmation to the client,
            and the client can then free up space in the buffer.</p><p>If you are using JMS and you're using the JMS service on the server to load your JMS
            connection factory instances into JNDI then this parameter can be configured in <code class="literal">hornetq-jms.xml</code> using the element <code class="literal">confirmation-window-size</code> a. If you're using JMS but not using JNDI then
            you can set these values directly on the <code class="literal">HornetQConnectionFactory</code>
            instance using the appropriate setter method.</p><p>If you're using the core API you can set these values directly on the <code class="literal">ServerLocator</code> instance using the appropriate setter method.</p><p>The window is specified in bytes.</p><p>Setting this parameter to <code class="literal">-1</code> disables any buffering and prevents
            any re-attachment from occurring, forcing reconnect instead. The default value for this
            parameter is <code class="literal">-1</code>. (Which means by default no auto re-attachment will occur)</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e9666"/>34.2. Session reconnection</h2></div></div></div><p>Alternatively, the server might have actually been restarted after crashing or being
            stopped. In this case any sessions will no longer be existent on the server and it won't
            be possible to 100% transparently re-attach to them.</p><p>In this case, HornetQ will automatically reconnect the connection and <span class="italic">recreate</span> any sessions and consumers on the server
            corresponding to the sessions and consumers on the client. This process is exactly the
            same as what happens during failover onto a backup server.</p><p>Client reconnection is also used internally by components such as core bridges to
            allow them to reconnect to their target servers.</p><p>Please see the section on failover <a class="xref" href="#ha.automatic.failover" title="39.2.1. Automatic Client Failover">Section 39.2.1, “Automatic Client Failover”</a> to get a
            full understanding of how transacted and non-transacted sessions are reconnected during
            failover/reconnect and what you need to do to maintain <span class="italic">once and
                only once </span>delivery guarantees.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e9685"/>34.3. Configuring reconnection/reattachment attributes</h2></div></div></div><p>Client reconnection is configured using the following parameters:</p><div class="itemizedlist"><ul><li><p><code class="literal">retry-interval</code>. This optional parameter determines the
                    period in milliseconds between subsequent reconnection attempts, if the
                    connection to the target server has failed. The default value is <code class="literal">2000</code> milliseconds.</p></li><li><p><code class="literal">retry-interval-multiplier</code>. This optional parameter
                    determines determines a multiplier to apply to the time since the last retry to
                    compute the time to the next retry.</p><p>This allows you to implement an <span class="emphasis"><em>exponential backoff</em></span>
                    between retry attempts.</p><p>Let's take an example:</p><p>If we set <code class="literal">retry-interval</code> to <code class="literal">1000</code> ms and
                    we set <code class="literal">retry-interval-multiplier</code> to <code class="literal">2.0</code>,
                    then, if the first reconnect attempt fails, we will wait <code class="literal">1000</code>
                    ms then <code class="literal">2000</code> ms then <code class="literal">4000</code> ms between
                    subsequent reconnection attempts.</p><p>The default value is <code class="literal">1.0</code> meaning each reconnect attempt is
                    spaced at equal intervals.</p></li><li><p><code class="literal">max-retry-interval</code>. This optional parameter determines the
                    maximum retry interval that will be used. When setting <code class="literal">retry-interval-multiplier</code> it would otherwise be possible that
                    subsequent retries exponentially increase to ridiculously large values. By
                    setting this parameter you can set an upper limit on that value. The default
                    value is <code class="literal">2000</code> milliseconds.</p></li><li><p><code class="literal">reconnect-attempts</code>. This optional parameter determines the
                    total number of reconnect attempts to make before giving up and shutting down. A
                    value of <code class="literal">-1</code> signifies an unlimited number of attempts. The
                    default value is <code class="literal">0</code>.</p></li></ul></div><p>If you're using JMS, and you're using the JMS Service on the server to load your JMS
            connection factory instances directly into JNDI, then you can specify these parameters
            in the xml configuration in <code class="literal">hornetq-jms.xml</code>, for example:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;connection-factory name="ConnectionFactory"&gt;
   &lt;connectors&gt;
      &lt;connector-ref connector-name="netty"/&gt;
   &lt;/connectors&gt;
   &lt;entries&gt;
      &lt;entry name="ConnectionFactory"/&gt;
      &lt;entry name="XAConnectionFactory"/&gt;
   &lt;/entries&gt;
   &lt;retry-interval&gt;1000&lt;/retry-interval&gt;
   &lt;retry-interval-multiplier&gt;1.5&lt;/retry-interval-multiplier&gt;
   &lt;max-retry-interval&gt;60000&lt;/max-retry-interval&gt;
   &lt;reconnect-attempts&gt;1000&lt;/reconnect-attempts&gt;
&lt;/connection-factory&gt;</pre><p>If you're using JMS, but instantiating your JMS connection factory directly, you can
            specify the parameters using the appropriate setter methods on the <code class="literal">HornetQConnectionFactory</code> immediately after creating it.</p><p>If you're using the core API and instantiating the <code class="literal">ServerLocator</code> instance directly you can also specify the
            parameters using the appropriate setter methods on the <code class="literal">ServerLocator</code> immediately after creating it.</p><p>If your client does manage to reconnect but the session is no longer available on the
            server, for instance if the server has been restarted or it has timed out, then the
            client won't be able to re-attach, and any <code class="literal">ExceptionListener</code> or
                <code class="literal">FailureListener</code> instances registered on the connection or session
            will be called.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="client-reconnection.exceptionlistener"/>34.4. ExceptionListeners and SessionFailureListeners</h2></div></div></div><p>Please note, that when a client reconnects or re-attaches, any registered JMS <code class="literal">ExceptionListener</code> or core API <code class="literal">SessionFailureListener</code>
            will be called.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="diverts"/>Chapter 35. Diverting and Splitting Message Flows</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e9869">35.1. Exclusive Divert</a></span></dt><dt><span class="section"><a href="#d0e9907">35.2. Non-exclusive Divert</a></span></dt></dl></div><p>HornetQ allows you to configure objects called <span class="emphasis"><em>diverts</em></span> with
        some simple server configuration.</p><p>Diverts allow you to transparently divert messages routed to one address to some other
        address, without making any changes to any client application logic.</p><p>Diverts can be <span class="emphasis"><em>exclusive</em></span>, meaning that the message is diverted
        to the new address, and does not go to the old address at all, or they can be
            <span class="emphasis"><em>non-exclusive</em></span> which means the message continues to go the old
        address, and a <span class="emphasis"><em>copy</em></span> of it is also sent to the new address.
        Non-exclusive diverts can therefore be used for <span class="emphasis"><em>splitting</em></span> message
        flows, e.g. there may be a requirement to monitor every order sent to an order queue.</p><p>Diverts can also be configured to have an optional message filter. If specified then only
        messages that match the filter will be diverted.</p><p>Diverts can also be configured to apply a <code class="literal">Transformer</code>. If specified,
        all diverted messages will have the opportunity of being transformed by the <code class="literal">Transformer</code>.</p><p>A divert will only divert a message to an address on the <span class="emphasis"><em>same server</em></span>,
        however, if you want to divert to an address on a different server, a common pattern would
        be to divert to a local store-and-forward queue, then set up a bridge which consumes from
        that queue and forwards to an address on a different server.</p><p>Diverts are therefore a very sophisticated concept, which when combined with bridges can
        be used to create interesting and complex routings. The set of diverts on a server can be
        thought of as a type of routing table for messages. Combining diverts with bridges allows
        you to create a distributed network of reliable routing connections between multiple
        geographically distributed servers, creating your global messaging mesh.</p><p>Diverts are defined as xml in the <code class="literal">hornetq-configuration.xml</code> file. There can
        be zero or more diverts in the file.</p><p>Please see <a class="xref" href="#divert-example" title="11.1.20. Divert">Section 11.1.20, “Divert”</a> for a full working
        example showing you how to configure and use diverts.</p><p>Let's take a look at some divert examples:</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e9869"/>35.1. Exclusive Divert</h2></div></div></div><p>Let's take a look at an exclusive divert. An exclusive divert diverts all matching
            messages that are routed to the old address to the new address. Matching messages do not
            get routed to the old address.</p><p>Here's some example xml configuration for an exclusive divert, it's taken from the
            divert example:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;divert name="prices-divert"&gt;
   &lt;address&gt;jms.topic.priceUpdates&lt;/address&gt;
   &lt;forwarding-address&gt;jms.queue.priceForwarding&lt;/forwarding-address&gt;
   &lt;filter string="office='New York'"/&gt;
   &lt;transformer-class-name&gt;
      org.hornetq.jms.example.AddForwardingTimeTransformer
   &lt;/transformer-class-name&gt;
   &lt;exclusive&gt;true&lt;/exclusive&gt;
&lt;/divert&gt;</pre><p>We define a divert called '<code class="literal">prices-divert</code>' that will divert any
            messages sent to the address '<code class="literal">jms.topic.priceUpdates</code>' (this
            corresponds to any messages sent to a JMS Topic called '<code class="literal">priceUpdates</code>') to another local address '<code class="literal">jms.queue.priceForwarding</code>' (this corresponds to a local JMS queue called
                '<code class="literal">priceForwarding</code>'</p><p>We also specify a message filter string so only messages with the message property
                <code class="literal">office</code> with value <code class="literal">New York</code> will get diverted,
            all other messages will continue to be routed to the normal address. The filter string
            is optional, if not specified then all messages will be considered matched.</p><p>In this example a transformer class is specified. Again this is optional, and if
            specified the transformer will be executed for each matching message. This allows you to
            change the messages body or properties before it is diverted. In this example the
            transformer simply adds a header that records the time the divert happened.</p><p>This example is actually diverting messages to a local store and forward queue, which
            is configured with a bridge which forwards the message to an address on another HornetQ
            server. Please see the example for more details.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e9907"/>35.2. Non-exclusive Divert</h2></div></div></div><p>Now we'll take a look at a non-exclusive divert. Non exclusive diverts are the same as
            exclusive diverts, but they only forward a <span class="emphasis"><em>copy</em></span> of the message to
            the new address. The original message continues to the old address</p><p>You can therefore think of non-exclusive diverts as <span class="emphasis"><em>splitting</em></span> a
            message flow.</p><p>Non exclusive diverts can be configured in the same way as exclusive diverts with an
            optional filter and transformer, here's an example non-exclusive divert, again from the
            divert example:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;divert name="order-divert"&gt;
    &lt;address&gt;jms.queue.orders&lt;/address&gt;
    &lt;forwarding-address&gt;jms.topic.spyTopic&lt;/forwarding-address&gt;
    &lt;exclusive&gt;false&lt;/exclusive&gt;
&lt;/divert&gt;</pre><p>The above divert example takes a copy of every message sent to the address '<code class="literal">jms.queue.orders</code>' (Which corresponds to a JMS Queue called '<code class="literal">orders</code>') and sends it to a local address called '<code class="literal">jms.topic.SpyTopic</code>' (which corresponds to a JMS Topic called '<code class="literal">SpyTopic</code>').</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="core-bridges"/>Chapter 36. Core Bridges</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e9981">36.1. Configuring Bridges</a></span></dt></dl></div><p>The function of a bridge is to consume messages from a source queue, and forward them to a
        target address, typically on a different HornetQ server.</p><p>The source and target servers do not have to be in the same cluster which makes bridging
        suitable for reliably sending messages from one cluster to another, for instance across a
        WAN, or internet and where the connection may be unreliable.</p><p>The bridge has built in resilience to failure so if the target server connection is lost,
        e.g. due to network failure, the bridge will retry connecting to the target until it comes
        back online. When it comes back online it will resume operation as normal.</p><p>In summary, bridges are a way to reliably connect two separate HornetQ servers together.
        With a core bridge both source and target servers must be HornetQ servers.</p><p>Bridges can be configured to provide <span class="emphasis"><em>once and only once</em></span> delivery
        guarantees even in the event of the failure of the source or the target server. They do this
        by using duplicate detection (described in <a class="xref" href="#duplicate-detection" title="Chapter 37. Duplicate Message Detection">Chapter 37, <i>Duplicate Message Detection</i></a>).</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Although they have similar function, don't confuse core bridges with JMS
            bridges!</p><p>Core bridges are for linking a HornetQ node with another HornetQ node and do not use
            the JMS API. A JMS Bridge is used for linking any two JMS 1.1 compliant JMS providers.
            So, a JMS Bridge could be used for bridging to or from different JMS compliant messaging
            system. It's always preferable to use a core bridge if you can. Core bridges use
            duplicate detection to provide <span class="emphasis"><em>once and only once</em></span> guarantees. To
            provide the same guarantee using a JMS bridge you would have to use XA which has a
            higher overhead and is more complex to configure.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e9981"/>36.1. Configuring Bridges</h2></div></div></div><p>Bridges are configured in <code class="literal">hornetq-configuration.xml</code>. Let's kick off
            with an example (this is actually from the bridge example):</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;bridge name="my-bridge"&gt;
   &lt;queue-name&gt;jms.queue.sausage-factory&lt;/queue-name&gt;
   &lt;forwarding-address&gt;jms.queue.mincing-machine&lt;/forwarding-address&gt;
   &lt;filter-string="name='aardvark'"/&gt;
   &lt;transformer-class-name&gt;
      org.hornetq.jms.example.HatColourChangeTransformer
   &lt;/transformer-class-name&gt;
   &lt;retry-interval&gt;1000&lt;/retry-interval&gt;
   &lt;ha&gt;true&lt;/ha&gt;
   &lt;retry-interval-multiplier&gt;1.0&lt;/retry-interval-multiplier&gt;
   &lt;reconnect-attempts&gt;-1&lt;/reconnect-attempts&gt;
   &lt;failover-on-server-shutdown&gt;false&lt;/failover-on-server-shutdown&gt;
   &lt;use-duplicate-detection&gt;true&lt;/use-duplicate-detection&gt;
   &lt;confirmation-window-size&gt;10000000&lt;/confirmation-window-size&gt;
   &lt;user&gt;foouser&lt;/user&gt;
   &lt;password&gt;foopassword&lt;/password&gt;
   &lt;static-connectors&gt;
      &lt;connector-ref&gt;remote-connector&lt;/connector-ref&gt;
   &lt;/static-connectors&gt;
   &lt;!-- alternative to static-connectors
   &lt;discovery-group-ref discovery-group-name="bridge-discovery-group"/&gt;
   --&gt;
&lt;/bridge&gt;</pre><p>In the above example we have shown all the parameters its possible to configure for a
            bridge. In practice you might use many of the defaults so it won't be necessary to
            specify them all explicitly.</p><p>Let's take a look at all the parameters in turn:</p><div class="itemizedlist"><ul><li><p><code class="literal">name</code> attribute. All bridges must have a unique name in the
                    server.</p></li><li><p><code class="literal">queue-name</code>. This is the unique name of the local queue that
                    the bridge consumes from, it's a mandatory parameter.</p><p>The queue must already exist by the time the bridge is instantiated at
                    start-up.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>If you're using JMS then normally the JMS configuration <code class="literal">hornetq-jms.xml</code> is loaded after the core configuration file
                            <code class="literal">hornetq-configuration.xml</code> is loaded. If your bridge
                        is consuming from a JMS queue then you'll need to make sure the JMS queue is
                        also deployed as a core queue in the core configuration. Take a look at the
                        bridge example for an example of how this is done.</p></div></li><li><p><code class="literal">forwarding-address</code>. This is the address on the target
                    server that the message will be forwarded to. If a forwarding address is not
                    specified, then the original address of the message will be retained.</p></li><li><p><code class="literal">filter-string</code>. An optional filter string can be supplied.
                    If specified then only messages which match the filter expression specified in
                    the filter string will be forwarded. The filter string follows the HornetQ
                    filter expression syntax described in <a class="xref" href="#filter-expressions" title="Chapter 14. Filter Expressions">Chapter 14, <i>Filter Expressions</i></a>.</p></li><li><p><code class="literal">transformer-class-name</code>. An optional transformer-class-name
                    can be specified. This is the name of a user-defined class which implements the
                        <code class="literal">org.hornetq.core.server.cluster.Transformer</code>
                    interface.</p><p>If this is specified then the transformer's <code class="literal">transform()</code>
                    method will be invoked with the message before it is forwarded. This gives you
                    the opportunity to transform the message's header or body before forwarding
                    it.</p></li><li><p><code class="literal">ha</code>. This optional parameter determines whether or not this
                   bridge should support high availability. True means it will connect to any available
                   server in a cluster and support failover. The default value is <code class="literal">false</code>.</p></li><li><p><code class="literal">retry-interval</code>. This optional parameter determines the
                    period in milliseconds between subsequent reconnection attempts, if the
                    connection to the target server has failed. The default value is <code class="literal">2000</code>milliseconds.</p></li><li><p><code class="literal">retry-interval-multiplier</code>. This optional parameter
                    determines determines a multiplier to apply to the time since the last retry to
                    compute the time to the next retry.</p><p>This allows you to implement an <span class="emphasis"><em>exponential backoff</em></span>
                    between retry attempts.</p><p>Let's take an example:</p><p>If we set <code class="literal">retry-interval</code>to <code class="literal">1000</code> ms and
                    we set <code class="literal">retry-interval-multiplier</code> to <code class="literal">2.0</code>,
                    then, if the first reconnect attempt fails, we will wait <code class="literal">1000</code>
                    ms then <code class="literal">2000</code> ms then <code class="literal">4000</code> ms between
                    subsequent reconnection attempts.</p><p>The default value is <code class="literal">1.0</code> meaning each reconnect attempt is
                    spaced at equal intervals.</p></li><li><p><code class="literal">reconnect-attempts</code>. This optional parameter determines the
                    total number of reconnect attempts the bridge will make before giving up and
                    shutting down. A value of <code class="literal">-1</code> signifies an unlimited number of
                    attempts. The default value is <code class="literal">-1</code>.</p></li><li><p><code class="literal">failover-on-server-shutdown</code>. This optional parameter
                    determines whether the bridge will attempt to failover onto a backup server (if
                    specified) when the target server is cleanly shutdown rather than
                    crashed.</p><p>The bridge connector can specify both a live and a backup server, if it
                    specifies a backup server and this parameter is set to <code class="literal">true</code>
                    then if the target server is <span class="emphasis"><em>cleanly</em></span> shutdown the bridge
                    connection will attempt to failover onto its backup. If the bridge connector has
                    no backup server configured then this parameter has no effect. </p><p>Sometimes you want a bridge configured with a live and a backup target server,
                    but you don't want to failover to the backup if the live server is simply taken
                    down temporarily for maintenance, this is when this parameter comes in
                    handy.</p><p>The default value for this parameter is <code class="literal">false</code>.</p></li><li><p><code class="literal">use-duplicate-detection</code>. This optional parameter determines
                    whether the bridge will automatically insert a duplicate id property into each
                    message that it forwards.</p><p>Doing so, allows the target server to perform duplicate detection on messages
                    it receives from the source server. If the connection fails or server crashes,
                    then, when the bridge resumes it will resend unacknowledged messages. This might
                    result in duplicate messages being sent to the target server. By enabling
                    duplicate detection allows these duplicates to be screened out and
                    ignored.</p><p>This allows the bridge to provide a <span class="emphasis"><em>once and only once</em></span>
                    delivery guarantee without using heavyweight methods such as XA (see <a class="xref" href="#duplicate-detection" title="Chapter 37. Duplicate Message Detection">Chapter 37, <i>Duplicate Message Detection</i></a> for more information).</p><p>The default value for this parameter is <code class="literal">true</code>.</p></li><li><p><code class="literal">confirmation-window-size</code>. This optional parameter
                    determines the <code class="literal">confirmation-window-size</code> to use for the
                    connection used to forward messages to the target node. This attribute is
                    described in section <a class="xref" href="#client-reconnection" title="Chapter 34. Client Reconnection and Session Reattachment">Chapter 34, <i>Client Reconnection and Session Reattachment</i></a></p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>When using the bridge to forward messages from a queue which has a
                    max-size-bytes set it's important that confirmation-window-size is less than
                    or equal to <code class="literal">max-size-bytes</code> to prevent the flow of
                    messages from ceasing.</p></div></li><li><p><code class="literal">user</code>. This optional parameter determines the user name to
                    use when creating the bridge connection to the remote server. If it is not
                    specified the default cluster user specified by <code class="literal">cluster-user</code>
                    in <code class="literal">hornetq-configuration.xml</code> will be used. </p></li><li><p><code class="literal">password</code>. This optional parameter determines the password
                    to use when creating the bridge connection to the remote server. If it is not
                    specified the default cluster password specified by <code class="literal">cluster-password</code> in <code class="literal">hornetq-configuration.xml</code>
                    will be used. </p></li><li><p><code class="literal">static-connectors</code> or <code class="literal">discovery-group-ref</code>.
                    Pick either of these options to connect the bridge to the target server.
                </p><p> The <code class="literal">static-connectors</code> is a list of <code class="literal">connector-ref</code>
                    elements pointing to <code class="literal">connector</code> elements defined elsewhere.
                    A <span class="emphasis"><em>connector</em></span> encapsulates knowledge of what transport to
                    use (TCP, SSL, HTTP etc) as well as the server connection parameters (host, port
                    etc). For more information about what connectors are and how to configure them,
                    please see <a class="xref" href="#configuring-transports" title="Chapter 16. Configuring the Transport">Chapter 16, <i>Configuring the Transport</i></a>.
                </p><p>The <code class="literal">discovery-group-ref</code> element has one attribute -
                    <code class="literal">discovery-group-name</code>.  This attribute points to a
                    <code class="literal">discovery-group</code> defined elsewhere. For more information about
                    what discovery-groups are and how to configure them, please see
                    <a class="xref" href="#clusters.discovery-groups" title="38.2.1.2. Discovery Groups">Section 38.2.1.2, “Discovery Groups”</a>.
                </p></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="duplicate-detection"/>Chapter 37. Duplicate Message Detection</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e10254">37.1. Using Duplicate Detection for Message Sending</a></span></dt><dt><span class="section"><a href="#duplicate.id.cache">37.2. Configuring the Duplicate ID Cache</a></span></dt><dt><span class="section"><a href="#d0e10343">37.3. Duplicate Detection and Bridges</a></span></dt><dt><span class="section"><a href="#d0e10368">37.4. Duplicate Detection and Cluster Connections</a></span></dt></dl></div><p>HornetQ includes powerful automatic duplicate message detection, filtering out
        duplicate messages without you having to code your own fiddly duplicate detection logic at
        the application level. This chapter will explain what duplicate detection is, how HornetQ
        uses it and how and where to configure it.</p><p>When sending messages from a client to a server, or indeed from a server to another
        server, if the target server or connection fails sometime after sending the message, but
        before the sender receives a response that the send (or commit) was processed successfully
        then the sender cannot know for sure if the message was sent successfully to the
        address.</p><p>If the target server or connection failed after the send was received and processed but
        before the response was sent back then the message will have been sent to the address
        successfully, but if the target server or connection failed before the send was received and
        finished processing then it will not have been sent to the address successfully. From the
        senders point of view it's not possible to distinguish these two cases.</p><p>When the server recovers this leaves the client in a difficult situation. It knows the
        target server failed, but it does not know if the last message reached its destination ok.
        If it decides to resend the last message, then that could result in a duplicate message
        being sent to the address. If each message was an order or a trade then this could result in
        the order being fulfilled twice or the trade being double booked. This is clearly not a
        desirable situation.</p><p>Sending the message(s) in a transaction does not help out either. If the server or
        connection fails while the transaction commit is being processed it is also indeterminate
        whether the transaction was successfully committed or not!</p><p>To solve these issues HornetQ provides automatic duplicate messages detection for
        messages sent to addresses.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e10254"/>37.1. Using Duplicate Detection for Message Sending</h2></div></div></div><p>Enabling duplicate message detection for sent messages is simple: you just need to set
            a special property on the message to a unique value. You can create the value however
            you like, as long as it is unique. When the target server receives the message it will
            check if that property is set, if it is, then it will check in its in memory cache if it
            has already received a message with that value of the header. If it has received a
            message with the same value before then it will ignore the message.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Using duplicate detection to move messages between nodes can give you the same
                    <span class="emphasis"><em>once and only once</em></span> delivery guarantees as if you were using
                an XA transaction to consume messages from source and send them to the target, but
                with less overhead and much easier configuration than using XA.</p></div><p>If you're sending messages in a transaction then you don't have to set the property
            for <span class="emphasis"><em>every</em></span> message you send in that transaction, you only need to
            set it once in the transaction. If the server detects a duplicate message for any
            message in the transaction, then it will ignore the entire transaction.</p><p>The name of the property that you set is given by the value of <code class="literal">org.hornetq.api.core.Message.HDR_DUPLICATE_DETECTION_ID</code>, which
            is <code class="literal">_HQ_DUPL_ID</code></p><p>The value of the property can be of type <code class="literal">byte[]</code> or <code class="literal">SimpleString</code> if you're using the core API. If you're using JMS it must be
            a <code class="literal">String</code>, and its value should be unique. An easy way of generating
            a unique id is by generating a UUID.</p><p>Here's an example of setting the property using the core API:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
...     

ClientMessage message = session.createMessage(true);

SimpleString myUniqueID = "This is my unique id";   // Could use a UUID for this

message.setStringProperty(HDR_DUPLICATE_DETECTION_ID, myUniqueID);

...</pre><p>And here's an example using the JMS API:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
...     

Message jmsMessage = session.createMessage();

String myUniqueID = "This is my unique id";   // Could use a UUID for this

message.setStringProperty(HDR_DUPLICATE_DETECTION_ID.toString(), myUniqueID);

...</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="duplicate.id.cache"/>37.2. Configuring the Duplicate ID Cache</h2></div></div></div><p>The server maintains caches of received values of the <code class="literal">org.hornetq.core.message.impl.HDR_DUPLICATE_DETECTION_ID</code> property
            sent to each address. Each address has its own distinct cache.</p><p>The cache is a circular fixed size cache. If the cache has a maximum size of <code class="literal">n</code> elements, then the <code class="literal">n + 1</code>th id stored will overwrite
            the <code class="literal">0</code>th element in the cache.</p><p>The maximum size of the cache is configured by the parameter <code class="literal">id-cache-size</code> in <code class="literal">hornetq-configuration.xml</code>, the default
            value is <code class="literal">2000</code> elements.</p><p>The caches can also be configured to persist to disk or not. This is configured by the
            parameter <code class="literal">persist-id-cache</code>, also in <code class="literal">hornetq-configuration.xml</code>. If this is set to <code class="literal">true</code> then
            each id will be persisted to permanent storage as they are received. The default value
            for this parameter is <code class="literal">true</code>.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>When choosing a size of the duplicate id cache be sure to set it to a larger
                enough size so if you resend messages all the previously sent ones are in the cache
                not having been overwritten.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e10343"/>37.3. Duplicate Detection and Bridges</h2></div></div></div><p>Core bridges can be configured to automatically add a unique duplicate id value (if there
            isn't already one in the message) before forwarding the message to it's target. This
            ensures that if the target server crashes or the connection is interrupted and the
            bridge resends the message, then if it has already been received by the target server,
            it will be ignored.</p><p>To configure a core bridge to add the duplicate id header, simply set the <em class="parameter"><code>use-duplicate-detection</code></em> to <code class="literal">true</code> when configuring a
            bridge in <code class="literal">hornetq-configuration.xml</code>.</p><p>The default value for this parameter is <code class="literal">true</code>.</p><p>For more information on core bridges and how to configure them, please see 
                <a class="xref" href="#core-bridges" title="Chapter 36. Core Bridges">Chapter 36, <i>Core Bridges</i></a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e10368"/>37.4. Duplicate Detection and Cluster Connections</h2></div></div></div><p>Cluster connections internally use core bridges to move messages reliable between
            nodes of the cluster. Consequently they can also be configured to insert the duplicate
            id header for each message they move using their internal bridges.</p><p>To configure a cluster connection to add the duplicate id header, simply set the
                <em class="parameter"><code>use-duplicate-detection</code></em> to <code class="literal">true</code> when
            configuring a cluster connection in <code class="literal">hornetq-configuration.xml</code>.</p><p>The default value for this parameter is <code class="literal">true</code>.</p><p>For more information on cluster connections and how to configure them, please see <a class="xref" href="#clusters" title="Chapter 38. Clusters">Chapter 38, <i>Clusters</i></a>.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="clusters"/>Chapter 38. Clusters</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e10413">38.1. Clusters Overview</a></span></dt><dt><span class="section"><a href="#clusters.server-discovery">38.2. Server discovery</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10490">38.2.1. Dynamic Discovery</a></span></dt><dt><span class="section"><a href="#d0e10813">38.2.2. Discovery using static Connectors</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e10861">38.3. Server-Side Message Load Balancing</a></span></dt><dd><dl><dt><span class="section"><a href="#clusters.cluster-connections">38.3.1. Configuring Cluster Connections</a></span></dt><dt><span class="section"><a href="#clusters.clusteruser">38.3.2. Cluster User Credentials</a></span></dt></dl></dd><dt><span class="section"><a href="#clusters.client.loadbalancing">38.4. Client-Side Load balancing</a></span></dt><dt><span class="section"><a href="#d0e11190">38.5. Specifying Members of a Cluster Explicitly</a></span></dt><dt><span class="section"><a href="#clusters.message-redistribution">38.6. Message Redistribution</a></span></dt><dt><span class="section"><a href="#d0e11262">38.7. Cluster topologies</a></span></dt><dd><dl><dt><span class="section"><a href="#symmetric-cluster">38.7.1. Symmetric cluster</a></span></dt><dt><span class="section"><a href="#d0e11289">38.7.2. Chain cluster</a></span></dt></dl></dd></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e10413"/>38.1. Clusters Overview</h2></div></div></div><p>HornetQ clusters allow groups of HornetQ servers to be grouped together in order to
            share message processing load. Each active node in the cluster is an active HornetQ
            server which manages its own messages and handles its own connections. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><a id="clustered-deprecation"/><h2>Note</h2><p>The <span class="emphasis"><em>clustered</em></span> parameter is deprecated and no longer needed for
            setting up a cluster. If your configuration contains this parameter it will be ignored and
            a message with the ID <code class="literal">HQ221038</code> will be logged.</p></div><p>The cluster is formed by each node declaring <span class="emphasis"><em>cluster connections</em></span>
            to other nodes in the core configuration file <code class="literal">hornetq-configuration.xml</code>. When a node forms a cluster connection to
            another node, internally it creates a <span class="emphasis"><em>core bridge</em></span> (as described in
            <a class="xref" href="#core-bridges" title="Chapter 36. Core Bridges">Chapter 36, <i>Core Bridges</i></a>) connection between it and the other node, this is
            done transparently behind the scenes - you don't have to declare an explicit bridge for
            each node. These cluster connections allow messages to flow between the nodes of the
            cluster to balance load.</p><p>Nodes can be connected together to form a cluster in many different topologies, we
            will discuss a couple of the more common topologies later in this chapter.</p><p>We'll also discuss client side load balancing, where we can balance client connections
            across the nodes of the cluster, and we'll consider message redistribution where HornetQ
            will redistribute messages between nodes to avoid starvation.</p><p>Another important part of clustering is <span class="emphasis"><em>server discovery</em></span> where
            servers can broadcast their connection details so clients or other servers can connect
            to them with the minimum of configuration.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><a id="copy-warning"/><h2>Warning</h2><p>Once a cluster node has been configured it is common to simply copy that configuration
            to other nodes to produce a symmetric cluster. However, care must be taken when copying the
            HornetQ files. Do not copy the HornetQ <span class="emphasis"><em>data</em></span> (i.e. the
            <code class="literal">bindings</code>, <code class="literal">journal</code>, and <code class="literal">large-messages</code>
            directories) from one node to another. When a node is started for the first time and initializes
            its journal files it also persists a special identifier to the <code class="literal">journal</code>
            directory. This id <span class="emphasis"><em>must</em></span> be unique among nodes in the cluster or the
            cluster will not form properly.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="clusters.server-discovery"/>38.2. Server discovery</h2></div></div></div><p>Server discovery is a mechanism by which servers can propagate their connection details to:</p><div class="itemizedlist"><ul><li><p>
                    Messaging clients. A messaging client wants to be able to connect
                    to the servers of the cluster without having specific knowledge of which servers
                    in the cluster are up at any one time.
                </p></li><li><p>Other servers. Servers in a cluster want to be able to create
                    cluster connections to each other without having prior knowledge of all the
                    other servers in the cluster.</p></li></ul></div><p>
            This information, let's call it the Cluster Topology, is actually sent around normal HornetQ
            connections to clients and to other servers over cluster connections. This being the case we need a
            way of establishing the initial first connection. This can be done using
            dynamic discovery techniques like <a class="ulink" href="http://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>
            and <a class="ulink" href="http://www.jgroups.org/">JGroups</a>, or by
            providing a list of initial connectors.
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e10490"/>38.2.1. Dynamic Discovery</h3></div></div></div><p>
                Server discovery uses <a class="ulink" href="http://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>
                multicast or <a class="ulink" href="http://www.jgroups.org/">JGroups</a> to broadcast server connection settings. 
            </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="clusters.broadcast-groups"/>38.2.1.1. Broadcast Groups</h4></div></div></div><p>A broadcast group is the means by which a server broadcasts connectors over the
                    network. A connector defines a way in which a client (or other server) can make
                    connections to the server. For more information on what a connector is, please see
                    <a class="xref" href="#configuring-transports" title="Chapter 16. Configuring the Transport">Chapter 16, <i>Configuring the Transport</i></a>.</p><p>The broadcast group takes a set of connector pairs, each connector pair contains
                    connection settings for a live and backup server (if one exists) and broadcasts them on
                    the network. Depending on which broadcasting technique you configure the cluster, it
                    uses either UDP or JGroups to broadcast connector pairs information.</p><p>Broadcast groups are defined in the server configuration file <code class="literal">hornetq-configuration.xml</code>. There can be many broadcast groups per
                    HornetQ server. All broadcast groups must be defined in a <code class="literal">broadcast-groups</code> element.</p><p>Let's take a look at an example broadcast group from <code class="literal">hornetq-configuration.xml</code> that defines a UDP broadcast group:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;broadcast-groups&gt;
   &lt;broadcast-group name="my-broadcast-group"&gt;
      &lt;local-bind-address&gt;172.16.9.3&lt;/local-bind-address&gt;
      &lt;local-bind-port&gt;5432&lt;/local-bind-port&gt;
      &lt;group-address&gt;231.7.7.7&lt;/group-address&gt;
      &lt;group-port&gt;9876&lt;/group-port&gt;
      &lt;broadcast-period&gt;2000&lt;/broadcast-period&gt;
      &lt;connector-ref connector-name="netty-connector"/&gt;
   &lt;/broadcast-group&gt;
&lt;/broadcast-groups&gt;</pre><p>Some of the broadcast group parameters are optional and you'll normally use the
                    defaults, but we specify them all in the above example for clarity. Let's discuss
                    each one in turn:</p><div class="itemizedlist"><ul><li><p><code class="literal">name</code> attribute. Each broadcast group in the server must
                            have a unique name. </p></li><li><p><code class="literal">local-bind-address</code>. This is the local bind address that
                            the datagram socket is bound to. If you have multiple network interfaces on
                            your server, you would specify which one you wish to use for broadcasts by
                            setting this property. If this property is not specified then the socket
                            will be bound to the wildcard address, an IP address chosen by the
                            kernel. This is a UDP specific attribute.</p></li><li><p><code class="literal">local-bind-port</code>. If you want to specify a local port to
                            which the datagram socket is bound you can specify it here. Normally you
                            would just use the default value of <code class="literal">-1</code> which signifies
                            that an anonymous port should be used. This parameter is always specified in conjunction with
                            <code class="literal">local-bind-address</code>. This is a UDP specific attribute.</p></li><li><p><code class="literal">group-address</code>. This is the multicast address to which
                            the data will be broadcast. It is a class D IP address in the range <code class="literal">224.0.0.0</code> to <code class="literal">239.255.255.255</code>, inclusive.
                            The address <code class="literal">224.0.0.0</code> is reserved and is not available
                            for use. This parameter is mandatory. This is a UDP specific attribute.</p></li><li><p><code class="literal">group-port</code>. This is the UDP port number used for
                            broadcasting. This parameter is mandatory. This is a UDP specific attribute.</p></li><li><p><code class="literal">broadcast-period</code>. This is the period in milliseconds
                            between consecutive broadcasts. This parameter is optional, the default
                            value is <code class="literal">2000</code> milliseconds.</p></li><li><p><code class="literal">connector-ref</code>. This specifies the connector and
                            optional backup connector that will be broadcasted (see <a class="xref" href="#configuring-transports" title="Chapter 16. Configuring the Transport">Chapter 16, <i>Configuring the Transport</i></a> for more information on connectors).
                            The connector to be broadcasted is specified by the <code class="literal">connector-name</code> attribute.</p></li></ul></div><p><a id="clusters.jgroups-example"/>Here is another example broadcast group that defines a JGroups broadcast group:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;broadcast-groups&gt;
   &lt;broadcast-group name="my-broadcast-group"&gt;
      &lt;jgroups-file&gt;test-jgroups-file_ping.xml&lt;/jgroups-file&gt;
      &lt;jgroups-channel&gt;hornetq_broadcast_channel&lt;/jgroups-channel&gt;
      &lt;broadcast-period&gt;2000&lt;/broadcast-period&gt;
    &lt;connector-ref connector-name="netty-connector"/&gt;
   &lt;/broadcast-group&gt;
&lt;/broadcast-groups&gt;</pre><p>To be able to use JGroups to broadcast, one must specify two attributes, i.e. 
                    <code class="literal">jgroups-file</code> and <code class="literal">jgroups-channel</code>, as discussed
                    in details as following:</p><div class="itemizedlist"><ul><li><p><code class="literal">jgroups-file</code> attribute. This is the name of JGroups configuration
                            file. It will be used to initialize JGroups channels. Make sure the file is in the 
                            java resource path so that HornetQ can load it. </p></li><li><p><code class="literal">jgroups-channel</code> attribute. The name that JGroups channels connect
                        to for broadcasting.</p></li></ul></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>The JGroups attributes (<code class="literal">jgroups-file</code> and <code class="literal">jgroups-channel</code>)
                    and UDP specific attributes described above are exclusive of each other. Only one set can be
                    specified in a broadcast group configuration. Don't mix them!</p></div><p><a id="clusters.jgroups-file"/>
                   The following is an example of a JGroups file
                   </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;config xmlns="urn:org:jgroups"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="urn:org:jgroups http://www.jgroups.org/schema/JGroups-3.0.xsd"&gt;
   &lt;TCP loopback="true"
      recv_buf_size="20000000"
      send_buf_size="640000"
      discard_incompatible_packets="true"
      max_bundle_size="64000"
      max_bundle_timeout="30"
      enable_bundling="true"
      use_send_queues="false"
      sock_conn_timeout="300"

      thread_pool.enabled="true"
      thread_pool.min_threads="1"
      thread_pool.max_threads="10"
      thread_pool.keep_alive_time="5000"
      thread_pool.queue_enabled="false"
      thread_pool.queue_max_size="100"
      thread_pool.rejection_policy="run"

      oob_thread_pool.enabled="true"
      oob_thread_pool.min_threads="1"
      oob_thread_pool.max_threads="8"
      oob_thread_pool.keep_alive_time="5000"
      oob_thread_pool.queue_enabled="false"
      oob_thread_pool.queue_max_size="100"
      oob_thread_pool.rejection_policy="run"/&gt;

   &lt;FILE_PING location="../file.ping.dir"/&gt;
   &lt;MERGE2 max_interval="30000"
      min_interval="10000"/&gt;
   &lt;FD_SOCK/&gt;
   &lt;FD timeout="10000" max_tries="5" /&gt;
   &lt;VERIFY_SUSPECT timeout="1500"  /&gt;
   &lt;BARRIER /&gt;
   &lt;pbcast.NAKACK
      use_mcast_xmit="false"
      retransmit_timeout="300,600,1200,2400,4800"
      discard_delivered_msgs="true"/&gt;
   &lt;UNICAST timeout="300,600,1200" /&gt;
   &lt;pbcast.STABLE stability_delay="1000" desired_avg_gossip="50000"
      max_bytes="400000"/&gt;
   &lt;pbcast.GMS print_local_addr="true" join_timeout="3000"
      view_bundling="true"/&gt;
   &lt;FC max_credits="2000000"
      min_threshold="0.10"/&gt;
   &lt;FRAG2 frag_size="60000"  /&gt;
   &lt;pbcast.STATE_TRANSFER/&gt;
   &lt;pbcast.FLUSH timeout="0"/&gt;
&lt;/config&gt;</pre><p>
                </p><p>
                   As it shows, the file content defines a jgroups protocol stacks. If you want hornetq
                   to use this stacks for channel creation, you have to make sure the value of 
                   <code class="literal">jgroups-file</code> in your broadcast-group/discovery-group configuration
                   to be the name of this jgroups configuration file. For example if the above stacks 
                   configuration is stored in a file named "jgroups-stacks.xml" then your
                   <code class="literal">jgroups-file</code> should be like
                   </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;jgroups-file&gt;jgroups-stacks.xml&lt;/jgroups-file&gt;</pre><p>
                </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="clusters.discovery-groups"/>38.2.1.2. Discovery Groups</h4></div></div></div><p>While the broadcast group defines how connector information is broadcasted from a
                    server, a discovery group defines how connector information is received from a
                    broadcast endpoint (a UDP multicast address or JGroup channel).</p><p>A discovery group maintains a list of connector pairs - one for each broadcast by
                    a different server. As it receives broadcasts on the broadcast endpoint from a
                    particular server it updates its entry in the list for that server.</p><p>If it has not received a broadcast from a particular server for a length of time
                    it will remove that server's entry from its list.</p><p>Discovery groups are used in two places in HornetQ:</p><div class="itemizedlist"><ul><li><p>By cluster connections so they know how to obtain an initial connection to download the topology</p></li><li><p>By messaging clients so they know how to obtain an initial connection to download the topology</p></li></ul></div><p>
                    Although a discovery group will always accept broadcasts, its current list of available live and
                    backup servers is only ever used when an initial connection is made, from then server discovery is
                    done over the normal HornetQ connections.
                </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>
                    Each discovery group must be configured with broadcast endpoint (UDP or JGroups) that matches its broadcast
                    group counterpart. For example, if broadcast is configured using UDP, the discovery group must also use UDP, and the same
                    multicast address.
                    </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e10657"/>38.2.1.3. Defining Discovery Groups on the Server</h4></div></div></div><p>For cluster connections, discovery groups are defined in the server side
                    configuration file <code class="literal">hornetq-configuration.xml</code>. All discovery
                    groups must be defined inside a <code class="literal">discovery-groups</code> element. There
                    can be many discovery groups defined by HornetQ server. Let's look at an
                    example:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;discovery-groups&gt;
   &lt;discovery-group name="my-discovery-group"&gt;
      &lt;local-bind-address&gt;172.16.9.7&lt;/local-bind-address&gt;
      &lt;group-address&gt;231.7.7.7&lt;/group-address&gt;
      &lt;group-port&gt;9876&lt;/group-port&gt;
      &lt;refresh-timeout&gt;10000&lt;/refresh-timeout&gt;
   &lt;/discovery-group&gt;
&lt;/discovery-groups&gt;</pre><p>We'll consider each parameter of the discovery group:</p><div class="itemizedlist"><ul><li><p><code class="literal">name</code> attribute. Each discovery group must have a unique
                            name per server.</p></li><li><p><code class="literal">local-bind-address</code>. If you are running with multiple network interfaces on the same machine, you
                            may want to specify that the discovery group listens only only a specific interface. To do this you can specify the interface
                            address with this parameter. This parameter is optional. This is a UDP specific attribute.</p></li><li><p><code class="literal">group-address</code>. This is the multicast IP address of the
                            group to listen on. It should match the <code class="literal">group-address</code> in
                            the broadcast group that you wish to listen from. This parameter is
                            mandatory.  This is a UDP specific attribute.</p></li><li><p><code class="literal">group-port</code>. This is the UDP port of the multicast
                            group. It should match the <code class="literal">group-port</code> in the broadcast
                            group that you wish to listen from. This parameter is mandatory. This is a UDP specific attribute.</p></li><li><p><code class="literal">refresh-timeout</code>. This is the period the discovery group
                            waits after receiving the last broadcast from a particular server before
                            removing that servers connector pair entry from its list. You would normally
                            set this to a value significantly higher than the <code class="literal">broadcast-period</code> on the broadcast group otherwise servers
                            might intermittently disappear from the list even though they are still
                            broadcasting due to slight differences in timing. This parameter is
                            optional, the default value is <code class="literal">10000</code> milliseconds (10
                            seconds).</p></li></ul></div><p>Here is another example that defines a JGroups discovery group:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;discovery-groups&gt;
   &lt;discovery-group name="my-broadcast-group"&gt;
      &lt;jgroups-file&gt;test-jgroups-file_ping.xml&lt;/jgroups-file&gt;
      &lt;jgroups-channel&gt;hornetq_broadcast_channel&lt;/jgroups-channel&gt;
      &lt;refresh-timeout&gt;10000&lt;/refresh-timeout&gt;
   &lt;/discovery-group&gt;
&lt;/discovery-groups&gt;</pre><p>To receive broadcast from JGroups channels, one must specify two attributes, 
                    <code class="literal">jgroups-file</code> and <code class="literal">jgroups-channel</code>, as discussed
                    in details as following:</p><div class="itemizedlist"><ul><li><p><code class="literal">jgroups-file</code> attribute. This is the name of JGroups configuration
                            file. It will be used to initialize JGroups channels. Make sure the file is in the 
                            java resource path so that HornetQ can load it. </p></li><li><p><code class="literal">jgroups-channel</code> attribute. The name that JGroups channels connect
                        to for receiving broadcasts.</p></li></ul></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>The JGroups attributes (<code class="literal">jgroups-file</code> and <code class="literal">jgroups-channel</code>)
                    and UDP specific attributes described above are exclusive of each other. Only one set can be
                    specified in a discovery group configuration. Don't mix them!</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="clusters-discovery.groups.clientside"/>38.2.1.4. Discovery Groups on the Client Side</h4></div></div></div><p>Let's discuss how to configure a HornetQ client to use discovery to discover a
                    list of servers to which it can connect. The way to do this differs depending on
                    whether you're using JMS or the core API.</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="d0e10747"/>38.2.1.4.1. Configuring client discovery using JMS</h5></div></div></div><p>If you're using JMS and you're also using the JMS Service on the server to
                        load your JMS connection factory instances into JNDI, then you can specify which
                        discovery group to use for your JMS connection factory in the server side xml
                        configuration <code class="literal">hornetq-jms.xml</code>. Let's take a look at an
                        example:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;connection-factory name="ConnectionFactory"&gt;
   &lt;discovery-group-ref discovery-group-name="my-discovery-group"/&gt;
   &lt;entries&gt;
      &lt;entry name="ConnectionFactory"/&gt;
   &lt;/entries&gt;
&lt;/connection-factory&gt;</pre><p>The element <code class="literal">discovery-group-ref</code> specifies the name of a
                        discovery group defined in <code class="literal">hornetq-configuration.xml</code>.</p><p>When this connection factory is downloaded from JNDI by a client application
                        and JMS connections are created from it, those connections will be load-balanced
                        across the list of servers that the discovery group maintains by listening on
                        the multicast address specified in the discovery group configuration.</p><p>If you're using JMS, but you're not using JNDI to lookup a connection factory
                        - you're instantiating the JMS connection factory directly then you can specify
                        the discovery group parameters directly when creating the JMS connection
                        factory. Here's an
                        example:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
final String groupAddress = "231.7.7.7";

final int groupPort = 9876;

ConnectionFactory jmsConnectionFactory =
HornetQJMSClient.createConnectionFactory(new DiscoveryGroupConfiguration(groupAddress, groupPort,
                       new UDPBroadcastGroupConfiguration(groupAddress, groupPort, null, -1)), JMSFactoryType.CF);

Connection jmsConnection1 = jmsConnectionFactory.createConnection();

Connection jmsConnection2 = jmsConnectionFactory.createConnection();</pre><p>The <code class="literal">refresh-timeout</code> can be set directly on the DiscoveryGroupConfiguration
                        by using the setter method <code class="literal">setDiscoveryRefreshTimeout()</code> if you
                        want to change the default value.</p><p>There is also a further parameter settable on the DiscoveryGroupConfiguration using the
                        setter method <code class="literal">setDiscoveryInitialWaitTimeout()</code>. If the connection
                        factory is used immediately after creation then it may not have had enough time
                        to received broadcasts from all the nodes in the cluster. On first usage, the
                        connection factory will make sure it waits this long since creation before
                        creating the first connection. The default value for this parameter is <code class="literal">10000</code> milliseconds.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="d0e10787"/>38.2.1.4.2. Configuring client discovery using Core</h5></div></div></div><p>If you're using the core API to directly instantiate
                        <code class="literal">ClientSessionFactory</code> instances, then you can specify the
                        discovery group parameters directly when creating the session factory. Here's an
                        example:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
final String groupAddress = "231.7.7.7";
final int groupPort = 9876;
ServerLocator factory = HornetQClient.createServerLocatorWithHA(new DiscoveryGroupConfiguration(groupAddress, groupPort,
                           new UDPBroadcastGroupConfiguration(groupAddress, groupPort, null, -1))));
ClientSessionFactory factory = locator.createSessionFactory();
ClientSession session1 = factory.createSession();
ClientSession session2 = factory.createSession();</pre><p>The <code class="literal">refresh-timeout</code> can be set directly on the DiscoveryGroupConfiguration
                        by using the setter method <code class="literal">setDiscoveryRefreshTimeout()</code> if you
                        want to change the default value.</p><p>There is also a further parameter settable on the DiscoveryGroupConfiguration using the
                        setter method <code class="literal">setDiscoveryInitialWaitTimeout()</code>. If the session factory
                        is used immediately after creation then it may not have had enough time to
                        received broadcasts from all the nodes in the cluster. On first usage, the
                        session factory will make sure it waits this long since creation before creating
                        the first session. The default value for this parameter is <code class="literal">10000</code> milliseconds.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e10813"/>38.2.2. Discovery using static Connectors</h3></div></div></div><p>Sometimes it may be impossible to use UDP on the network you are using. In this case its
                possible to configure a connection with an initial list if possible servers. This could be just
                one server that you know will always be available or a list of servers where at least one will
                be available.</p><p>This doesn't mean that you have to know where all your servers are going to be hosted, you
                can configure these servers to use the reliable servers to connect to. Once they are connected
                there connection details will be propagated via the server it connects to</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e10820"/>38.2.2.1. Configuring a Cluster Connection</h4></div></div></div><p>For cluster connections there is no extra configuration needed, you just need to make sure that any
                    connectors are defined in the usual manner, (see <a class="xref" href="#configuring-transports" title="Chapter 16. Configuring the Transport">Chapter 16, <i>Configuring the Transport</i></a> for more
                    information on connectors). These are then referenced by the cluster connection configuration.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e10827"/>38.2.2.2. Configuring a Client Connection</h4></div></div></div><p>A static list of possible servers can also be used by a normal client.</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="d0e10832"/>38.2.2.2.1. Configuring client discovery using JMS</h5></div></div></div><p>If you're using JMS and you're also using the JMS Service on the server to
                        load your JMS connection factory instances into JNDI, then you can specify which
                        connectors to use for your JMS connection factory in the server side xml
                        configuration <code class="literal">hornetq-jms.xml</code>. Let's take a look at an
                        example:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;connection-factory name="ConnectionFactory"&gt;
   &lt;connectors&gt;
      &lt;connector-ref connector-name="netty-connector"/&gt;
      &lt;connector-ref connector-name="netty-connector2"/&gt;
      &lt;connector-ref connector-name="netty-connector3"/&gt;
   &lt;/connectors&gt;
   &lt;entries&gt;
      &lt;entry name="ConnectionFactory"/&gt;
   &lt;/entries&gt;
&lt;/connection-factory&gt;</pre><p>
                        The element <code class="literal">connectors</code> contains a list of pre defined connectors in the
                        <code class="literal">hornetq-configuration.xml</code> file. When this connection factory is downloaded
                        from JNDI by a client application and JMS connections are created from it, those connections will
                        be load-balanced across the list of servers defined by these connectors.
                    </p><p>
                        If you're using JMS, but you're not using JNDI to lookup a connection factory - you're instantiating
                        the JMS connection factory directly then you can specify the connector list directly when creating
                        the JMS connection factory. Here's an example:
                    </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
map.put("host", "myhost");
map.put("port", "5445");
TransportConfiguration server1 = new TransportConfiguration(NettyConnectorFactory.class.getName(), map);
HashMap&lt;String, Object&gt; map2 = new HashMap&lt;String, Object&gt;();
map2.put("host", "myhost2");
map2.put("port", "5446");
TransportConfiguration server2 = new TransportConfiguration(NettyConnectorFactory.class.getName(), map2);

HornetQConnectionFactory cf = HornetQJMSClient.createConnectionFactoryWithHA(JMSFactoryType.CF, server1, server2);</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="d0e10854"/>38.2.2.2.2. Configuring client discovery using Core</h5></div></div></div><p>If you are using the core API then the same can be done as follows:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
map.put("host", "myhost");
map.put("port", "5445");
TransportConfiguration server1 = new TransportConfiguration(NettyConnectorFactory.class.getName(), map);
HashMap&lt;String, Object&gt; map2 = new HashMap&lt;String, Object&gt;();
map2.put("host", "myhost2");
map2.put("port", "5446");
TransportConfiguration server2 = new TransportConfiguration(NettyConnectorFactory.class.getName(), map2);

ServerLocator locator = HornetQClient.createServerLocatorWithHA(server1, server2);
ClientSessionFactory factory = locator.createSessionFactory();
ClientSession session = factory.createSession();</pre></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e10861"/>38.3. Server-Side Message Load Balancing</h2></div></div></div><p>If cluster connections are defined between nodes of a cluster, then HornetQ will load
            balance messages arriving at a particular node from a client.</p><p>Let's take a simple example of a cluster of four nodes A, B, C, and D arranged in a
            <span class="emphasis"><em>symmetric cluster</em></span> (described in
            <a class="xref" href="#symmetric-cluster" title="38.7.1. Symmetric cluster">Section 38.7.1, “Symmetric cluster”</a>). We have a queue called <code class="literal">OrderQueue</code>
            deployed on each node of the cluster.</p><p>We have client Ca connected to node A, sending orders to the server. We have also have
            order processor clients Pa, Pb, Pc, and Pd connected to each of the nodes A, B, C, D. If
            no cluster connection was defined on node A, then as order messages arrive on node A
            they will all end up in the <code class="literal">OrderQueue</code> on node A, so will only get
            consumed by the order processor client attached to node A, Pa.</p><p>If we define a cluster connection on node A, then as ordered messages arrive on node A
            instead of all of them going into the local <code class="literal">OrderQueue</code> instance, they
            are distributed in a round-robin fashion between all the nodes of the cluster. The
            messages are forwarded from the receiving node to other nodes of the cluster. This is
            all done on the server side, the client maintains a single connection to node A.</p><p>For example, messages arriving on node A might be distributed in the following order
            between the nodes: B, D, C, A, B, D, C, A, B, D. The exact order depends on the order
            the nodes started up, but the algorithm used is round robin.</p><p>HornetQ cluster connections can be configured to always blindly load balance messages
            in a round robin fashion irrespective of whether there are any matching consumers on
            other nodes, but they can be a bit cleverer than that and also be configured to only
            distribute to other nodes if they have matching consumers. We'll look at both these
            cases in turn with some examples, but first we'll discuss configuring cluster
            connections in general.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="clusters.cluster-connections"/>38.3.1. Configuring Cluster Connections</h3></div></div></div><p>Cluster connections group servers into clusters so that messages can be load
                balanced between the nodes of the cluster. Let's take a look at a typical cluster
                connection. Cluster connections are always defined in <code class="literal">hornetq-configuration.xml</code> inside a <code class="literal">cluster-connection</code> element. There can be zero or more cluster
                connections defined per HornetQ server.</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;cluster-connections&gt;
   &lt;cluster-connection name="my-cluster"&gt;
      &lt;address&gt;jms&lt;/address&gt;
      &lt;connector-ref&gt;netty-connector&lt;/connector-ref&gt;
      &lt;check-period&gt;1000&lt;/check-period&gt;
      &lt;connection-ttl&gt;5000&lt;/connection-ttl&gt;
      &lt;min-large-message-size&gt;50000&lt;/min-large-message-size&gt;
      &lt;call-timeout&gt;5000&lt;/call-timeout&gt;
      &lt;retry-interval&gt;500&lt;/retry-interval&gt;
      &lt;retry-interval-multiplier&gt;1.0&lt;/retry-interval-multiplier&gt;
      &lt;max-retry-interval&gt;5000&lt;/max-retry-interval&gt;
      &lt;reconnect-attempts&gt;-1&lt;/reconnect-attempts&gt;
      &lt;use-duplicate-detection&gt;true&lt;/use-duplicate-detection&gt;
      &lt;forward-when-no-consumers&gt;false&lt;/forward-when-no-consumers&gt;
      &lt;max-hops&gt;1&lt;/max-hops&gt;
      &lt;confirmation-window-size&gt;32000&lt;/confirmation-window-size&gt;
      &lt;call-failover-timeout&gt;30000&lt;/call-failover-timeout&gt;
      &lt;notification-interval&gt;1000&lt;/notification-interval&gt;
      &lt;notification-attempts&gt;2&lt;/notification-attempts&gt;
      &lt;discovery-group-ref discovery-group-name="my-discovery-group"/&gt;
   &lt;/cluster-connection&gt;
&lt;/cluster-connections&gt;</pre><p>In the above cluster connection all parameters have been explicitly specified. The following
               shows all the available configuration options</p><div class="itemizedlist"><ul><li><p><a id="clusters.address"/><code class="literal">address</code>. Each cluster connection only applies to
                        messages sent to an address that starts with this value. Note: this does
                        not use wild-card matching.</p><p>In this case, this cluster connection will load balance messages sent to
                        address that start with <code class="literal">jms</code>. This cluster connection,
                        will, in effect apply to all JMS queues and topics since they map to core
                        queues that start with the substring "jms".</p><p>The address can be any value and you can have many cluster connections
                        with different values of <code class="literal">address</code>, simultaneously
                        balancing messages for those addresses, potentially to different clusters of
                        servers. By having multiple cluster connections on different addresses a
                        single HornetQ Server can effectively take part in multiple clusters
                        simultaneously.</p><p>Be careful not to have multiple cluster connections with overlapping
                        values of <code class="literal">address</code>, e.g. "europe" and "europe.news" since
                        this could result in the same messages being distributed between more than
                        one cluster connection, possibly resulting in duplicate deliveries.</p><p>This parameter is mandatory.</p></li><li><p><code class="literal">connector-ref</code>. This is the connector which will be sent to other nodes in
                    the cluster so they have the correct cluster topology.</p><p>This parameter is mandatory.</p></li><li><p><code class="literal">check-period</code>. The period (in milliseconds) used to check if the cluster connection
                        has failed to receive pings from another server. Default is 30000.</p></li><li><p><code class="literal">connection-ttl</code>. This is how long a cluster connection should stay alive if it
                   stops receiving messages from a specific node in the cluster. Default is 60000.</p></li><li><p><code class="literal">min-large-message-size</code>. If the message size (in bytes) is larger than this
                    value then it will be split into multiple segments when sent over the network to other cluster
                    members. Default is 102400.</p></li><li><p><code class="literal">call-timeout</code>. When a packet is sent via a cluster connection and is a blocking
                   call, i.e. for acknowledgements, this is how long it will wait (in milliseconds) for the reply before
                   throwing an exception. Default is 30000.</p></li><li><p><code class="literal">retry-interval</code>. We mentioned before that, internally,
                        cluster connections cause bridges to be created between the nodes of the
                        cluster. If the cluster connection is created and the target node has not
                        been started, or say, is being rebooted, then the cluster connections from
                        other nodes will retry connecting to the target until it comes back up, in
                        the same way as a bridge does.</p><p>This parameter determines the interval in milliseconds between retry
                        attempts. It has the same meaning as the <code class="literal">retry-interval</code>
                        on a bridge (as described in <a class="xref" href="#core-bridges" title="Chapter 36. Core Bridges">Chapter 36, <i>Core Bridges</i></a>).</p><p>This parameter is optional and its default value is <code class="literal">500</code>
                        milliseconds.</p></li><li><p><code class="literal">retry-interval-multiplier</code>. This is a multiplier used to increase the
                   <code class="literal">retry-interval</code> after each reconnect attempt, default is 1.</p></li><li><p><code class="literal">max-retry-interval</code>. The maximum delay (in milliseconds) for retries.
                   Default is 2000.</p></li><li><p><code class="literal">reconnect-attempts</code>.The number of times the system will
                        try to connect a node on the cluster. If the max-retry is achieved this node will
                        be considered permanently down and the system will stop routing messages to this
                        node. Default is -1 (infinite retries).</p></li><li><p><code class="literal">use-duplicate-detection</code>. Internally cluster connections
                        use bridges to link the nodes, and bridges can be configured to add a
                        duplicate id property in each message that is forwarded. If the target node
                        of the bridge crashes and then recovers, messages might be resent from the
                        source node. By enabling duplicate detection any duplicate messages will be
                        filtered out and ignored on receipt at the target node.</p><p>This parameter has the same meaning as <code class="literal">use-duplicate-detection</code>
                        on a bridge. For more information on duplicate detection, please see
                        <a class="xref" href="#duplicate-detection" title="Chapter 37. Duplicate Message Detection">Chapter 37, <i>Duplicate Message Detection</i></a>. Default is true.</p></li><li><p><code class="literal">forward-when-no-consumers</code>. This parameter determines
                        whether messages will be distributed round robin between other nodes of the
                        cluster <span class="emphasis"><em>regardless</em></span> of whether or not there are matching or
                        indeed any consumers on other nodes. </p><p>If this is set to <code class="literal">true</code> then each incoming message will
                        be round robin'd even though the same queues on the other nodes of the
                        cluster may have no consumers at all, or they may have consumers that have
                        non matching message filters (selectors). Note that HornetQ will
                        <span class="emphasis"><em>not</em></span> forward messages to other nodes if there are no
                        <span class="emphasis"><em>queues</em></span> of the same name on the other nodes, even if
                        this parameter is set to <code class="literal">true</code>.</p><p>If this is set to <code class="literal">false</code> then HornetQ will only forward
                        messages to other nodes of the cluster if the address to which they are
                        being forwarded has queues which have consumers, and if those consumers have
                        message filters (selectors) at least one of those selectors must match the
                        message.</p><p>Default is false.</p></li><li><p><code class="literal">max-hops</code>. When a cluster connection decides the set of
                        nodes to which it might load balance a message, those nodes do not have to
                        be directly connected to it via a cluster connection. HornetQ can be
                        configured to also load balance messages to nodes which might be connected
                        to it only indirectly with other HornetQ servers as intermediates in a
                        chain.</p><p>This allows HornetQ to be configured in more complex topologies and still
                        provide message load balancing. We'll discuss this more later in this
                        chapter.</p><p>The default value for this parameter is <code class="literal">1</code>, which means
                        messages are only load balanced to other HornetQ serves which are directly
                        connected to this server. This parameter is optional.</p></li><li><p><code class="literal">confirmation-window-size</code>. The size (in bytes) of the window
                   used for sending confirmations from the server connected to. So once the server has
                   received <code class="literal">confirmation-window-size</code> bytes it notifies its client,
                   default is 1048576. A value of -1 means no window.</p></li><li><p><code class="literal">call-failover-timeout</code>. Similar to <code class="literal">call-timeout</code> but used
                   when a call is made during a failover attempt. Default is -1 (no timeout).</p></li><li><p><code class="literal">notification-interval</code>. How often (in milliseconds) the cluster connection
                   should broadcast itself when attaching to the cluster. Default is 1000.</p></li><li><p><code class="literal">notification-attempts</code>. How many times the cluster connection should
                   broadcast itself when connecting to the cluster. Default is 2.</p></li><li><p><code class="literal">discovery-group-ref</code>. This parameter determines which
                        discovery group is used to obtain the list of other servers in the cluster
                        that this cluster connection will make connections to.</p></li></ul></div><p>
                Alternatively if you would like your cluster connections to use a static list of
                servers for discovery then you can do it like this.
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;cluster-connection name="my-cluster"&gt;
   ...
   &lt;static-connectors&gt;
      &lt;connector-ref&gt;server0-connector&lt;/connector-ref&gt;
      &lt;connector-ref&gt;server1-connector&lt;/connector-ref&gt;
   &lt;/static-connectors&gt;
&lt;/cluster-connection&gt;</pre><p>
                Here we have defined 2 servers that we know for sure will that at least one will be available. There may
                be many more servers in the cluster but these will; be discovered via one of these connectors once an
                initial connection has been made.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="clusters.clusteruser"/>38.3.2. Cluster User Credentials</h3></div></div></div><p>When creating connections between nodes of a cluster to form a cluster connection,
                HornetQ uses a cluster user and cluster password which is defined in <code class="literal">hornetq-configuration.xml</code>:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;cluster-user&gt;HORNETQ.CLUSTER.ADMIN.USER&lt;/cluster-user&gt;
&lt;cluster-password&gt;CHANGE ME!!&lt;/cluster-password&gt;</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>It is imperative that these values are changed from their default, or remote
                    clients will be able to make connections to the server using the default values.
                    If they are not changed from the default, HornetQ will detect this and pester
                    you with a warning on every start-up.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="clusters.client.loadbalancing"/>38.4. Client-Side Load balancing</h2></div></div></div><p>With HornetQ client-side load balancing, subsequent sessions created using a single
            session factory can be connected to different nodes of the cluster. This allows sessions
            to spread smoothly across the nodes of a cluster and not be "clumped" on any particular
            node.</p><p>The load balancing policy to be used by the client factory is configurable. HornetQ
            provides four out-of-the-box load balancing policies, and you can also implement your own
            and use that.</p><p>The out-of-the-box policies are</p><div class="itemizedlist"><ul><li><p>Round Robin. With this policy the first node is chosen randomly then each
                    subsequent node is chosen sequentially in the same order.</p><p>For example nodes might be chosen in the order B, C, D, A, B, C, D, A, B or D,
                    A, B, C, D, A, B, C, D or C, D, A, B, C, D, A, B, C.</p><p>Use <code class="literal">org.hornetq.api.core.client.loadbalance.RoundRobinConnectionLoadBalancingPolicy</code>
                    as the <code class="literal">&lt;connection-load-balancing-policy-class-name&gt;</code>.</p></li><li><p>Random. With this policy each node is chosen randomly.</p><p>Use <code class="literal">org.hornetq.api.core.client.loadbalance.RandomConnectionLoadBalancingPolicy</code>
                    as the <code class="literal">&lt;connection-load-balancing-policy-class-name&gt;</code>.</p></li><li><p>Random Sticky. With this policy the first node is chosen randomly and then re-used for subsequent
                    connections.</p><p>Use <code class="literal">org.hornetq.api.core.client.loadbalance.RandomStickyConnectionLoadBalancingPolicy</code>
                    as the <code class="literal">&lt;connection-load-balancing-policy-class-name&gt;</code>.</p></li><li><p>First Element. With this policy the "first" (i.e. 0th) node is always returned.</p><p>Use <code class="literal">org.hornetq.api.core.client.loadbalance.FirstElementConnectionLoadBalancingPolicy</code>
                    as the <code class="literal">&lt;connection-load-balancing-policy-class-name&gt;</code>.</p></li></ul></div><p>You can also implement your own policy by implementing the interface <code class="literal">org.hornetq.api.core.client.loadbalance.ConnectionLoadBalancingPolicy</code></p><p>Specifying which load balancing policy to use differs whether you are using JMS or the
            core API. If you don't specify a policy then the default will be used which is <code class="literal">org.hornetq.api.core.client.loadbalance.RoundRobinConnectionLoadBalancingPolicy</code>.</p><p>If you're using JMS, and you're using JNDI on the server to put your JMS connection
            factories into JNDI, then you can specify the load balancing policy directly in the
            <code class="literal">hornetq-jms.xml</code> configuration file on the server as follows:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;connection-factory name="ConnectionFactory"&gt;
   &lt;discovery-group-ref discovery-group-name="my-discovery-group"/&gt;
   &lt;entries&gt;
      &lt;entry name="ConnectionFactory"/&gt;
   &lt;/entries&gt;
   &lt;connection-load-balancing-policy-class-name&gt;
      org.hornetq.api.core.client.loadbalance.RandomConnectionLoadBalancingPolicy
   &lt;/connection-load-balancing-policy-class-name&gt;
&lt;/connection-factory&gt;</pre><p>The above example would deploy a JMS connection factory that uses the random connection load
            balancing policy. </p><p>If you're using JMS but you're instantiating your connection factory directly on the
            client side then you can set the load balancing policy using the setter on the
            <code class="literal">HornetQConnectionFactory</code> before using it:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
ConnectionFactory jmsConnectionFactory = HornetQJMSClient.createConnectionFactory(...);
jmsConnectionFactory.setLoadBalancingPolicyClassName("com.acme.MyLoadBalancingPolicy");</pre><p>If you're using the core API, you can set the load balancing policy directly on the
            <code class="literal">ServerLocator</code> instance you are using:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
ServerLocator locator = HornetQClient.createServerLocatorWithHA(server1, server2);
locator.setLoadBalancingPolicyClassName("com.acme.MyLoadBalancingPolicy");</pre><p>The set of servers over which the factory load balances can be determined in one of
            two ways:</p><div class="itemizedlist"><ul><li><p>Specifying servers explicitly</p></li><li><p>Using discovery.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e11190"/>38.5. Specifying Members of a Cluster Explicitly</h2></div></div></div><p>
            Sometimes you want to explicitly define a cluster more explicitly, that is control which
            server connect to each other in the cluster. This is typically used to form non symmetrical clusters
            such as chain cluster or ring clusters. This can only be done using a static list of connectors and is
            configured as follows:
        </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;cluster-connection name="my-cluster"&gt;
   &lt;address&gt;jms&lt;/address&gt;
   &lt;connector-ref&gt;netty-connector&lt;/connector-ref&gt;
   &lt;retry-interval&gt;500&lt;/retry-interval&gt;
   &lt;use-duplicate-detection&gt;true&lt;/use-duplicate-detection&gt;
   &lt;forward-when-no-consumers&gt;true&lt;/forward-when-no-consumers&gt;
   &lt;max-hops&gt;1&lt;/max-hops&gt;
   &lt;static-connectors allow-direct-connections-only="true"&gt;
      &lt;connector-ref&gt;server1-connector&lt;/connector-ref&gt;
   &lt;/static-connectors&gt;
&lt;/cluster-connection&gt;</pre><p>
            In this example we have set the attribute <code class="literal">allow-direct-connections-only</code> which means that
            the only server that this server can create a cluster connection to is server1-connector. This means you can
            explicitly create any cluster topology you want.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="clusters.message-redistribution"/>38.6. Message Redistribution</h2></div></div></div><p>Another important part of clustering is message redistribution. Earlier we learned how
            server side message load balancing round robins messages across the cluster. If <code class="literal">forward-when-no-consumers</code> is false, then messages won't be forwarded to
            nodes which don't have matching consumers, this is great and ensures that messages don't
            arrive on a queue which has no consumers to consume them, however there is a situation
            it doesn't solve: What happens if the consumers on a queue close after the messages have
            been sent to the node? If there are no consumers on the queue the message won't get
            consumed and we have a <span class="emphasis"><em>starvation</em></span> situation.</p><p>This is where message redistribution comes in. With message redistribution HornetQ can
            be configured to automatically <span class="emphasis"><em>redistribute</em></span> messages from queues
            which have no consumers back to other nodes in the cluster which do have matching
            consumers.</p><p>Message redistribution can be configured to kick in immediately after the last
            consumer on a queue is closed, or to wait a configurable delay after the last consumer
            on a queue is closed before redistributing. By default message redistribution is
            disabled.</p><p>Message redistribution can be configured on a per address basis, by specifying the
            redistribution delay in the address settings, for more information on configuring
            address settings, please see <a class="xref" href="#queue-attributes" title="Chapter 25. Queue Attributes">Chapter 25, <i>Queue Attributes</i></a>.</p><p>Here's an address settings snippet from <code class="literal">hornetq-configuration.xml</code>
            showing how message redistribution is enabled for a set of queues:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;address-settings&gt;
   &lt;address-setting match="jms.#"&gt;
      &lt;redistribution-delay&gt;0&lt;/redistribution-delay&gt;
   &lt;/address-setting&gt;
&lt;/address-settings&gt;</pre><p>The above <code class="literal">address-settings</code> block would set a <code class="literal">redistribution-delay</code> of <code class="literal">0</code> for any queue which is bound
            to an address that starts with "jms.". All JMS queues and topic subscriptions are bound
            to addresses that start with "jms.", so the above would enable instant (no delay)
            redistribution for all JMS queues and topic subscriptions.</p><p>The attribute <code class="literal">match</code> can be an exact match or it can be a string
            that conforms to the HornetQ wildcard syntax (described in <a class="xref" href="#wildcard-syntax" title="Chapter 13. Understanding the HornetQ Wildcard Syntax">Chapter 13, <i>Understanding the HornetQ Wildcard Syntax</i></a>).</p><p>The element <code class="literal">redistribution-delay</code> defines the delay in milliseconds
            after the last consumer is closed on a queue before redistributing messages from that
            queue to other nodes of the cluster which do have matching consumers. A delay of zero
            means the messages will be immediately redistributed. A value of <code class="literal">-1</code>
            signifies that messages will never be redistributed. The default value is <code class="literal">-1</code>.</p><p>It often makes sense to introduce a delay before redistributing as it's a common case
            that a consumer closes but another one quickly is created on the same queue, in such a
            case you probably don't want to redistribute immediately since the new consumer will
            arrive shortly.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e11262"/>38.7. Cluster topologies</h2></div></div></div><p>HornetQ clusters can be connected together in many different topologies, let's
            consider the two most common ones here</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="symmetric-cluster"/>38.7.1. Symmetric cluster</h3></div></div></div><p>A symmetric cluster is probably the most common cluster topology, and you'll be
                familiar with if you've had experience of JBoss Application Server
                clustering.</p><p>With a symmetric cluster every node in the cluster is connected to every other
                node in the cluster. In other words every node in the cluster is no more than one
                hop away from every other node.</p><p>To form a symmetric cluster every node in the cluster defines a cluster connection
                with the attribute <code class="literal">max-hops</code> set to <code class="literal">1</code>.
                Typically the cluster connection will use server discovery in order to know what
                other servers in the cluster it should connect to, although it is possible to
                explicitly define each target server too in the cluster connection if, for example,
                UDP is not available on your network.</p><p>With a symmetric cluster each node knows about all the queues that exist on all
                the other nodes and what consumers they have. With this knowledge it can determine
                how to load balance and redistribute messages around the nodes.</p><p>Don't forget <a class="link" href="#copy-warning" title="Warning">this warning</a> when creating a
                symmetric cluster.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e11289"/>38.7.2. Chain cluster</h3></div></div></div><p>With a chain cluster, each node in the cluster is not connected to every node in
                the cluster directly, instead the nodes form a chain with a node on each end of the
                chain and all other nodes just connecting to the previous and next nodes in the
                chain.</p><p>An example of this would be a three node chain consisting of nodes A, B and C.
                Node A is hosted in one network and has many producer clients connected to it
                sending order messages. Due to corporate policy, the order consumer clients need to
                be hosted in a different network, and that network is only accessible via a third
                network. In this setup node B acts as a mediator with no producers or consumers on
                it. Any messages arriving on node A will be forwarded to node B, which will in turn
                forward them to node C where they can get consumed. Node A does not need to directly
                connect to C, but all the nodes can still act as a part of the cluster.</p><p>To set up a cluster in this way, node A would define a cluster connection that
                connects to node B, and node B would define a cluster connection that connects to
                node C. In this case we only want cluster connections in one direction since we're
                only moving messages from node A-&gt;B-&gt;C and never from C-&gt;B-&gt;A.</p><p>For this topology we would set <code class="literal">max-hops</code> to <code class="literal">2</code>. With a value of <code class="literal">2</code> the knowledge of what queues and
                consumers that exist on node C would be propagated from node C to node B to node A.
                Node A would then know to distribute messages to node B when they arrive, even
                though node B has no consumers itself, it would know that a further hop away is node
                C which does have consumers.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="ha"/>Chapter 39. High Availability and Failover</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e11342">39.1. Live - Backup Groups</a></span></dt><dd><dl><dt><span class="section"><a href="#ha.mode">39.1.1. HA modes</a></span></dt><dt><span class="section"><a href="#ha.mode.replicated">39.1.2. Data Replication</a></span></dt><dt><span class="section"><a href="#ha.mode.shared">39.1.3. Shared Store</a></span></dt><dt><span class="section"><a href="#ha.allow-fail-back">39.1.4. Failing Back to live Server</a></span></dt></dl></dd><dt><span class="section"><a href="#failover">39.2. Failover Modes</a></span></dt><dd><dl><dt><span class="section"><a href="#ha.automatic.failover">39.2.1. Automatic Client Failover</a></span></dt><dt><span class="section"><a href="#d0e11784">39.2.2. Getting Notified of Connection Failure</a></span></dt><dt><span class="section"><a href="#d0e11836">39.2.3. Application-Level Failover</a></span></dt></dl></dd></dl></div><p>We define high availability as the <span class="emphasis"><em>ability for the system to continue
    functioning after failure of one or more of the servers</em></span>.</p><p>A part of high availability is <span class="emphasis"><em>failover</em></span> which we define as the
    <span class="emphasis"><em>ability for client connections to migrate from one server to another in event of
    server failure so client applications can continue to operate</em></span>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e11342"/>39.1. Live - Backup Groups</h2></div></div></div><p>HornetQ allows servers to be linked together as <span class="emphasis"><em>live - backup</em></span>
        groups where each live server can have 1 or more backup servers. A backup server is owned by
        only one live server.  Backup servers are not operational until failover occurs, however 1
        chosen backup, which will be in passive mode, announces its status and waits to take over
        the live servers work</p><p>Before failover, only the live server is serving the HornetQ clients while the backup
        servers remain passive or awaiting to become a backup server. When a live server crashes or
        is brought down in the correct mode, the backup server currently in passive mode will become
        live and another backup server will become passive. If a live server restarts after a
        failover then it will have priority and be the next server to become live when the current
        live server goes down, if the current live server is configured to allow automatic failback
        then it will detect the live server coming back up and automatically stop.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ha.mode"/>39.1.1. HA modes</h3></div></div></div><p>HornetQ supports two different strategies for backing up a server <span class="emphasis"><em>shared
            store</em></span> and <span class="emphasis"><em>replication</em></span>.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Only persistent message data will survive failover. Any non persistent message
              data will not be available after failover.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ha.mode.replicated"/>39.1.2. Data Replication</h3></div></div></div><p>Replication is supported since version 2.3.</p><p>When using replication, the live and the backup servers do not share the same
                data directories, all data synchronization is done through network traffic. Therefore all (persistent)
                   data traffic received by the live server will be duplicated to the backup.
                </p><div align="center"><img src="images/ha-replicated-store.png" align="middle"/></div><p>Notice that upon start-up the backup server will first need to synchronize all
                existing data from the live server, before becoming capable of replacing the live
                server should it fail. So unlike the shared store case, a replicating backup will
                not be a fully operational backup right after start, but only after it finishes
                synchronizing the data. The time it will take for this to happen will depend on the
                amount of data to be synchronized and the connection speed.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2>Synchronization occurs in parallel with current network traffic so this won't cause any blocking on
               current clients.</div><p>Replication will create a copy of the data at the backup. One issue to be aware
               of is: in case of a successful fail-over, the backup's data will be newer than
               the one at the live's storage. If you configure your live server to perform a <a class="xref" href="#ha.allow-fail-back" title="39.1.4. Failing Back to live Server">Section 39.1.4, “Failing Back to live Server”</a> when restarted, it will synchronize
               its data with the backup's. If both servers are shutdown, the administrator will have
               to determine which one has the lastest data.</p><p>The replicating live and backup pair must be part of a cluster.  The Cluster
                Connection also defines how backup servers will find the remote live servers to pair
                with.  Refer to <a class="xref" href="#clusters" title="Chapter 38. Clusters">Chapter 38, <i>Clusters</i></a> for details on how this is done, and how
                to configure a cluster connection. Notice that:
</p><div class="itemizedlist"><ul><li>Both live and backup servers must be part of the same cluster.  Notice that even a simple live/backup replicating pair will require a cluster configuration.</li><li>their cluster user and password must match</li></ul></div><p>
</p><p>Within a cluster, there are two ways that a backup server will locate a live server to replicate from, these are:</p><div class="itemizedlist"><ul><li><p><code class="literal">specifying a node group</code>. You can specify a group of live servers that a backup
                      server can connect to. This is done by configuring <code class="literal">backup-group-name</code> in the main
                      <code class="literal">hornetq-configuration.xml</code>. A Backup server will only connect to a live server that
                         shares the same node group name</p></li><li><p><code class="literal">connecting to any live</code>. Simply put not configuring <code class="literal">backup-group-name</code>
                      will allow a backup server to connect to any live server</p></li></ul></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2>A <code class="literal">backup-group-name</code> example: suppose you have 5 live servers and 6 backup servers:
                <div class="itemizedlist"><ul><li><code class="literal">live1</code>, <code class="literal">live2</code>, <code class="literal">live3</code>: with <code class="literal">backup-group-name=fish</code></li><li><code class="literal">live4</code>, <code class="literal">live5</code>: with <code class="literal">backup-group-name=bird</code></li><li><code class="literal">backup1</code>, <code class="literal">backup2</code>, <code class="literal">backup3</code>, <code class="literal">backup4</code>: with <code class="literal">backup-group-name=fish</code></li><li><code class="literal">backup5</code>, <code class="literal">backup6</code>: with <code class="literal">backup-group-name=bird</code></li></ul></div><p>After joining the cluster the backups with <code class="literal">backup-group-name=fish</code> will search for live servers with <code class="literal">backup-group-name=fish</code> to pair with. Since there is one backup too many, the <code class="literal">fish</code> will remain with one spare backup.</p><p>The 2 backups with <code class="literal">backup-group-name=bird</code> (<code class="literal">backup5</code> and <code class="literal">backup6</code>) will pair with live servers <code class="literal">live4</code> and <code class="literal">live5</code>.
</p></div><p>The backup will search for any live server that it is configured to connect to. It then tries to
                   replicate with each live server in turn until it finds a live server that has no current backup configured.
                If no live server is available it will wait until the cluster topology changes and repeats the process.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2>This is an important distinction from a shared-store backup, as in that case if
               the backup starts and does not find its live server, the server will just activate
               and start to serve client requests. In the replication case, the backup just keeps
               waiting for a live server to pair with. Notice that in replication the backup server
               does not know whether any data it might have is up to date, so it really cannot
               decide to activate automatically. To activate a replicating backup server using the data
               it has, the administrator must change its configuration to make a live server of it,
               that change <code class="literal">backup=true</code> to <code class="literal">backup=false</code>.</div><p>Much like in the shared-store case, when the live server stops or crashes,
                its replicating backup will become active and take over its duties. Specifically,
                the backup will become active when it loses connection to its live server. This can
                be problematic because this can also happen because of a temporary network
                problem. In order to address this issue, the backup will try to determine whether it
                still can connect to the other servers in the cluster. If it can connect to more
                than half the servers, it will become active, if more than half the servers also
                disappeared with the live, the backup will wait and try reconnecting with the live.
                This avoids a split brain situation.
                </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e11506"/>39.1.2.1. Configuration</h4></div></div></div><p>To configure the live and backup servers to be a replicating pair, configure
                both servers' <code class="literal">hornetq-configuration.xml</code> to have:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;!-- FOR BOTH LIVE AND BACKUP SERVERS' --&gt;
&lt;shared-store&gt;false&lt;/shared-store&gt;
.
.
&lt;cluster-connections&gt;
   &lt;cluster-connection name="my-cluster"&gt;
      ...
   &lt;/cluster-connection&gt;
&lt;/cluster-connections&gt;
</pre><p>The backup server must also be configured as a backup.</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;backup&gt;true&lt;/backup&gt;
</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ha.mode.shared"/>39.1.3. Shared Store</h3></div></div></div><p>When using a shared store, both live and backup servers share the
                        <span class="emphasis"><em>same</em></span> entire data directory using a shared file system.
                    This means the paging directory, journal directory, large messages and binding
                    journal.</p><p>When failover occurs and a backup server takes over, it will load the
                    persistent storage from the shared file system and clients can connect to
                    it.</p><p>This style of high availability differs from data replication in that it
                    requires a shared file system which is accessible by both the live and backup
                    nodes. Typically this will be some kind of high performance Storage Area Network
                    (SAN). We do not recommend you use Network Attached Storage (NAS), e.g. NFS
                    mounts to store any shared journal (NFS is slow).</p><p>The advantage of shared-store high availability is that no replication occurs
                    between the live and backup nodes, this means it does not suffer any performance
                    penalties due to the overhead of replication during normal operation.</p><p>The disadvantage of shared store replication is that it requires a shared file
                    system, and when the backup server activates it needs to load the journal from
                    the shared store which can take some time depending on the amount of data in the
                    store.</p><p>If you require the highest performance during normal operation, have access to
                    a fast SAN, and can live with a slightly slower failover (depending on amount of
                    data), we recommend shared store high availability</p><div align="center"><img src="images/ha-shared-store.png" align="middle"/></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ha/mode.shared.configuration"/>39.1.3.1. Configuration</h4></div></div></div><p>To configure the live and backup servers to share their store, configure
                        all <code class="literal">hornetq-configuration.xml</code>:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;shared-store&gt;true&lt;/shared-store&gt;
                </pre><p>Additionally, each backup server must be flagged explicitly as a
                        backup:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;backup&gt;true&lt;/backup&gt;</pre><p>In order for live - backup groups to operate properly with a shared store,
                        both servers must have configured the location of journal directory to point
                        to the <span class="emphasis"><em>same shared location</em></span> (as explained in <a class="xref" href="#configuring.message.journal" title="15.3. Configuring the message journal">Section 15.3, “Configuring the message journal”</a>)</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>todo write something about GFS</p></div><p>Also each node, live and backups, will need to have a cluster connection defined even if not
                        part of a cluster. The Cluster Connection info defines how backup servers announce there presence
                        to its live server or any other nodes in the cluster. Refer to <a class="xref" href="#clusters" title="Chapter 38. Clusters">Chapter 38, <i>Clusters</i></a> for details
                        on how this is done.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ha.allow-fail-back"/>39.1.4. Failing Back to live Server</h3></div></div></div><p>After a live server has failed and a backup taken has taken over its duties, you may want to
                    restart the live server and have clients fail back.</p><p>In case of "shared disk", simply restart the original live
                    server and kill the new live server. You can do this by killing the process itself or just waiting for the server to crash naturally.</p><p>In case of a replicating live server that has been replaced by a remote backup you will need to also set <a class="link" href="#hq.check-for-live-server">check-for-live-server</a>. This option is necessary because a starting server cannot know whether there is a (remote) server running in its place, so with this option set, the server will check the cluster for another server using its node-ID and if it finds one it will try initiate a fail-back. This option only applies to live servers that are restarting, it is ignored by backup servers.</p><p>
                    It is also possible to cause failover to occur on normal server shutdown, to enable
                    this set the following property to true in the <code class="literal">hornetq-configuration.xml</code>
                    configuration file like so:
                </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;failover-on-shutdown&gt;true&lt;/failover-on-shutdown&gt;</pre><p>
                    By default this is set to false, if by some chance you have set this to false but still
                    want to stop the server normally and cause failover then you can do this by using the management
                    API as explained at <a class="xref" href="#management.core.server" title="30.1.1.1. Core Server Management">Section 30.1.1.1, “Core Server Management”</a>
                </p><p>
                    You can also force the running live server to shutdown when the old live server comes back up allowing
                    the original live server to take over automatically by setting the following property in the
                <code class="literal">hornetq-configuration.xml</code> configuration file as follows:
                </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;allow-failback&gt;true&lt;/allow-failback&gt;</pre><p><a id="hq.check-for-live-server"/>
                    In replication HA mode you need to set an extra property <code class="literal">check-for-live-server</code>
                    to <code class="literal">true</code>. If set to true, during start-up a live server will first search the cluster for another server using its nodeID. If it finds one, it will contact this server and try to "fail-back". Since this is a remote replication scenario, the "starting live" will have to synchronize its data with the server running with its ID, once they are in sync, it will request the other server (which it assumes it is a back that has assumed its duties) to shutdown for it to take over. This is necessary because otherwise the live server has no means to know whether there was a fail-over or not, and if there was if the server that took its duties is still running or not. To configure this option at your <code class="literal">hornetq-configuration.xml</code> configuration file as follows:
                </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;check-for-live-server&gt;true&lt;/check-for-live-server&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="failover"/>39.2. Failover Modes</h2></div></div></div><p>HornetQ defines two types of client failover:</p><div class="itemizedlist"><ul><li><p>Automatic client failover</p></li><li><p>Application-level client failover</p></li></ul></div><p>HornetQ also provides 100% transparent automatic reattachment of connections to the
            same server (e.g. in case of transient network problems). This is similar to failover,
            except it is reconnecting to the same server and is discussed in <a class="xref" href="#client-reconnection" title="Chapter 34. Client Reconnection and Session Reattachment">Chapter 34, <i>Client Reconnection and Session Reattachment</i></a></p><p>During failover, if the client has consumers on any non persistent or temporary
            queues, those queues will be automatically recreated during failover on the backup node,
            since the backup node will not have any knowledge of non persistent queues.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="ha.automatic.failover"/>39.2.1. Automatic Client Failover</h3></div></div></div><p>HornetQ clients can be configured to receive knowledge of all live and backup servers, so
                that in event of connection failure at the client - live server connection, the
                client will detect this and reconnect to the backup server. The backup server will
                then automatically recreate any sessions and consumers that existed on each
                connection before failover, thus saving the user from having to hand-code manual
                reconnection logic.</p><p>HornetQ clients detect connection failure when it has not received packets from
                the server within the time given by <code class="literal">client-failure-check-period</code>
                as explained in section <a class="xref" href="#connection-ttl" title="Chapter 17. Detecting Dead Connections">Chapter 17, <i>Detecting Dead Connections</i></a>. If the client does not
                receive data in good time, it will assume the connection has failed and attempt
                failover. Also if the socket is closed by the OS, usually if the server process is
                killed rather than the machine itself crashing, then the client will failover straight away.
                </p><p>HornetQ clients can be configured to discover the list of live-backup server groups in a
                number of different ways. They can be configured explicitly or probably the most
                common way of doing this is to use <span class="emphasis"><em>server discovery</em></span> for the
                client to automatically discover the list. For full details on how to configure
                server discovery, please see <a class="xref" href="#clusters" title="Chapter 38. Clusters">Chapter 38, <i>Clusters</i></a>.
                Alternatively, the clients can explicitly connect to a specific server and download
                the current servers and backups see <a class="xref" href="#clusters" title="Chapter 38. Clusters">Chapter 38, <i>Clusters</i></a>.</p><p>To enable automatic client failover, the client must be configured to allow
                non-zero reconnection attempts (as explained in <a class="xref" href="#client-reconnection" title="Chapter 34. Client Reconnection and Session Reattachment">Chapter 34, <i>Client Reconnection and Session Reattachment</i></a>).</p><p>By default failover will only occur after at least one connection has been made to
                the live server. In other words, by default, failover will not occur if the client
                fails to make an initial connection to the live server - in this case it will simply
                retry connecting to the live server according to the reconnect-attempts property and
                fail after this number of attempts.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e11654"/>39.2.1.1. Failing over on the Initial Connection</h4></div></div></div><p>
                    Since the client does not learn about the full topology until after the first
                    connection is made there is a window where it does not know about the backup. If a failure happens at
                    this point the client can only try reconnecting to the original live server. To configure
                    how many attempts the client will make you can set the property <code class="literal">initialConnectAttempts</code>
                    on the <code class="literal">ClientSessionFactoryImpl</code> or <code class="literal">HornetQConnectionFactory</code> or
                    <code class="literal">initial-connect-attempts</code> in xml. The default for this is <code class="literal">0</code>, that
                    is try only once. Once the number of attempts has been made an exception will be thrown.
                </p></div><p>For examples of automatic failover with transacted and non-transacted JMS
                sessions, please see <a class="xref" href="#examples.transaction-failover" title="11.1.81. Transaction Failover">Section 11.1.81, “Transaction Failover”</a> and <a class="xref" href="#examples.non-transaction-failover" title="11.1.47. Non-Transaction Failover With Server Data Replication">Section 11.1.47, “Non-Transaction Failover With Server Data Replication”</a>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ha.automatic.failover.noteonreplication"/>39.2.1.2. A Note on Server Replication</h4></div></div></div><p>HornetQ does not replicate full server state between live and backup servers.
                    When the new session is automatically recreated on the backup it won't have any
                    knowledge of messages already sent or acknowledged in that session. Any
                    in-flight sends or acknowledgements at the time of failover might also be
                    lost.</p><p>By replicating full server state, theoretically we could provide a 100%
                    transparent seamless failover, which would avoid any lost messages or
                    acknowledgements, however this comes at a great cost: replicating the full
                    server state (including the queues, session, etc.). This would require
                    replication of the entire server state machine; every operation on the live
                    server would have to replicated on the replica server(s) in the exact same
                    global order to ensure a consistent replica state. This is extremely hard to do
                    in a performant and scalable way, especially when one considers that multiple
                    threads are changing the live server state concurrently.</p><p>It is possible to provide full state machine replication using techniques such
                    as <span class="italic">virtual synchrony</span>, but this does not scale
                    well and effectively serializes all operations to a single thread, dramatically
                    reducing concurrency.</p><p>Other techniques for multi-threaded active replication exist such as
                    replicating lock states or replicating thread scheduling but this is very hard
                    to achieve at a Java level.</p><p>Consequently it has decided it was not worth massively reducing performance
                    and concurrency for the sake of 100% transparent failover. Even without 100%
                    transparent failover, it is simple to guarantee <span class="italic">once and
                        only once</span> delivery, even in the case of failure, by using a
                    combination of duplicate detection and retrying of transactions. However this is
                    not 100% transparent to the client code.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ha.automatic.failover.blockingcalls"/>39.2.1.3. Handling Blocking Calls During Failover</h4></div></div></div><p>If the client code is in a blocking call to the server, waiting for a response
                    to continue its execution, when failover occurs, the new session will not have
                    any knowledge of the call that was in progress. This call might otherwise hang
                    for ever, waiting for a response that will never come.</p><p>To prevent this, HornetQ will unblock any blocking calls that were in progress
                    at the time of failover by making them throw a <code class="literal">javax.jms.JMSException</code> (if using JMS), or a <code class="literal">HornetQException</code> with error code <code class="literal">HornetQException.UNBLOCKED</code>. It is up to the client code to catch
                    this exception and retry any operations if desired.</p><p>If the method being unblocked is a call to commit(), or prepare(), then the
                    transaction will be automatically rolled back and HornetQ will throw a <code class="literal">javax.jms.TransactionRolledBackException</code> (if using JMS), or a
                        <code class="literal">HornetQException</code> with error code <code class="literal">HornetQException.TRANSACTION_ROLLED_BACK</code> if using the core
                    API.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ha.automatic.failover.transactions"/>39.2.1.4. Handling Failover With Transactions</h4></div></div></div><p>If the session is transactional and messages have already been sent or
                    acknowledged in the current transaction, then the server cannot be sure that
                    messages sent or acknowledgements have not been lost during the failover.</p><p>Consequently the transaction will be marked as rollback-only, and any
                    subsequent attempt to commit it will throw a <code class="literal">javax.jms.TransactionRolledBackException</code> (if using JMS), or a
                        <code class="literal">HornetQException</code> with error code <code class="literal">HornetQException.TRANSACTION_ROLLED_BACK</code> if using the core
                    API.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>2 phase commit</h2><p>
                     The caveat to this rule is when XA is used either via JMS or through the core API.
                     If 2 phase commit is used and prepare has already been called then rolling back could
                     cause a <code class="literal">HeuristicMixedException</code>. Because of this the commit will throw
                     a <code class="literal">XAException.XA_RETRY</code> exception. This informs the Transaction Manager
                     that it should retry the commit at some later point in time, a side effect of this is
                     that any non persistent messages will be lost. To avoid this use persistent
                     messages when using XA. With acknowledgements this is not an issue since they are
                     flushed to the server before prepare gets called.
                  </p></div><p>It is up to the user to catch the exception, and perform any client side local
                    rollback code as necessary. There is no need to manually rollback the session -
                    it is already rolled back. The user can then just retry the transactional
                    operations again on the same session.</p><p>HornetQ ships with a fully functioning example demonstrating how to do this,
                    please see <a class="xref" href="#examples.transaction-failover" title="11.1.81. Transaction Failover">Section 11.1.81, “Transaction Failover”</a></p><p>If failover occurs when a commit call is being executed, the server, as
                    previously described, will unblock the call to prevent a hang, since no response
                    will come back. In this case it is not easy for the client to determine whether
                    the transaction commit was actually processed on the live server before failure
                    occurred.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>
                     If XA is being used either via JMS or through the core API then an <code class="literal">XAException.XA_RETRY</code>
                     is thrown. This is to inform Transaction Managers that a retry should occur at some point. At
                     some later point in time the Transaction Manager will retry the commit. If the original
                     commit has not occurred then it will still exist and be committed, if it does not exist
                     then it is assumed to have been committed although the transaction manager may log a warning.
                  </p></div><p>To remedy this, the client can simply enable duplicate detection (<a class="xref" href="#duplicate-detection" title="Chapter 37. Duplicate Message Detection">Chapter 37, <i>Duplicate Message Detection</i></a>) in the transaction, and retry the
                    transaction operations again after the call is unblocked. If the transaction had
                    indeed been committed on the live server successfully before failover, then when
                    the transaction is retried, duplicate detection will ensure that any durable
                    messages resent in the transaction will be ignored on the server to prevent them
                    getting sent more than once.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>By catching the rollback exceptions and retrying, catching unblocked calls
                        and enabling duplicate detection, once and only once delivery guarantees for
                        messages can be provided in the case of failure, guaranteeing 100% no loss
                        or duplication of messages.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="ha.automatic.failover.nontransactional"/>39.2.1.5. Handling Failover With Non Transactional Sessions</h4></div></div></div><p>If the session is non transactional, messages or acknowledgements can be lost
                    in the event of failover.</p><p>If you wish to provide <span class="italic">once and only once</span>
                    delivery guarantees for non transacted sessions too, enabled duplicate
                    detection, and catch unblock exceptions as described in <a class="xref" href="#ha.automatic.failover.blockingcalls" title="39.2.1.3. Handling Blocking Calls During Failover">Section 39.2.1.3, “Handling Blocking Calls During Failover”</a></p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e11784"/>39.2.2. Getting Notified of Connection Failure</h3></div></div></div><p>JMS provides a standard mechanism for getting notified asynchronously of
                connection failure: <code class="literal">java.jms.ExceptionListener</code>. Please consult
                the JMS javadoc or any good JMS tutorial for more information on how to use
                this.</p><p>The HornetQ core API also provides a similar feature in the form of the class
                    <code class="literal">org.hornet.core.client.SessionFailureListener</code></p><p>Any ExceptionListener or SessionFailureListener instance will always be called by
                HornetQ on event of connection failure, <span class="bold"><strong>irrespective</strong></span> of whether the connection was successfully failed over,
                reconnected or reattached, however you can find out if reconnect or reattach has happened
            by either the <code class="literal">failedOver</code> flag passed in on the <code class="literal">connectionFailed</code>
               on <code class="literal">SessionfailureListener</code> or by inspecting the error code on the
               <code class="literal">javax.jms.JMSException</code> which will be one of the following:</p><div class="table"><a id="d0e11813"/><p class="title"><b>Table 39.1. JMSException error codes</b></p><div class="table-contents"><table summary="JMSException error codes" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>error code</th><th>Description</th></tr></thead><tbody><tr><td>FAILOVER</td><td>
                          Failover has occurred and we have successfully reattached or reconnected.
                       </td></tr><tr><td>DISCONNECT</td><td>
                          No failover has occurred and we are disconnected.
                       </td></tr></tbody></table></div></div><br class="table-break"/></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e11836"/>39.2.3. Application-Level Failover</h3></div></div></div><p>In some cases you may not want automatic client failover, and prefer to handle any
                connection failure yourself, and code your own manually reconnection logic in your
                own failure handler. We define this as <span class="emphasis"><em>application-level</em></span>
                failover, since the failover is handled at the user application level.</p><p>To implement application-level failover, if you're using JMS then you need to set
                an <code class="literal">ExceptionListener</code> class on the JMS connection. The <code class="literal">ExceptionListener</code> will be called by HornetQ in the event that
                connection failure is detected. In your <code class="literal">ExceptionListener</code>, you
                would close your old JMS connections, potentially look up new connection factory
                instances from JNDI and creating new connections. In this case you may well be using
                    <a class="ulink" href="http://www.jboss.org/community/wiki/JBossHAJNDIImpl">HA-JNDI</a>
                to ensure that the new connection factory is looked up from a different
                server.</p><p>For a working example of application-level failover, please see <a class="xref" href="#application-level-failover" title="11.1.3. Application-Layer Failover">Section 11.1.3, “Application-Layer Failover”</a>.</p><p>If you are using the core API, then the procedure is very similar: you would set a
                    <code class="literal">FailureListener</code> on the core <code class="literal">ClientSession</code>
                instances.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="libaio"/>Chapter 40. Libaio Native Libraries</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e11917">40.1. Compiling the native libraries</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e11922">40.1.1. Install requirements</a></span></dt><dt><span class="section"><a href="#d0e11972">40.1.2. Invoking the compilation</a></span></dt></dl></dd></dl></div><p>HornetQ distributes a native library, used as a bridge between HornetQ and Linux
        libaio.</p><p><code class="literal">libaio</code> is a library, developed as part of the Linux kernel project.
        With <code class="literal">libaio</code> we submit writes to the operating system where they are
        processed asynchronously. Some time later the OS will call our code back when they have been
        processed.</p><p>We use this in our high performance journal if configured to do so, please see <a class="xref" href="#persistence" title="Chapter 15. Persistence">Chapter 15, <i>Persistence</i></a>.</p><p>These are the native libraries distributed by HornetQ:</p><div class="itemizedlist"><ul><li><p>libHornetQAIO32.so - x86 32 bits</p></li><li><p>libHornetQAIO64.so - x86 64 bits</p></li></ul></div><p>When using libaio, HornetQ will always try loading these files as long as they are on the
            <a class="link" href="#using-server.library.path" title="6.4. Library Path">library path</a>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e11917"/>40.1. Compiling the native libraries</h2></div></div></div><p>In the case that you are using Linux on a platform other than x86_32 or x86_64
            (for example Itanium 64 bits or IBM Power) you may need to compile the native library, since we
            do not distribute binaries for those platforms with the release.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e11922"/>40.1.1. Install requirements</h3></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>At the moment the native layer is only available on Linux. If you are in a
                    platform other than Linux the native compilation will not work</p></div><p>The native library uses <a class="ulink" href="http://en.wikipedia.org/wiki/Autoconf">autoconf</a> what makes the compilation process easy, however you need to
                install extra packages as a requirement for compilation:</p><div class="itemizedlist"><ul><li><p>gcc - C Compiler</p></li><li><p>gcc-c++ or g++ - Extension to gcc with support for C++</p></li><li><p>autoconf - Tool for automating native build process</p></li><li><p>make - Plain old make</p></li><li><p>automake - Tool for automating make generation</p></li><li><p>libtool - Tool for link editing native libraries</p></li><li><p>libaio - library to disk asynchronous IO kernel functions</p></li><li><p>libaio-dev - Compilation support for libaio</p></li><li><p>A full JDK installed with the environment variable JAVA_HOME set to its
                        location</p></li></ul></div><p>To perform this installation on RHEL or Fedora, you can simply type this at a
                command line:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">sudo yum install automake libtool autoconf gcc-c++ gcc libaio libaio-devel make</pre><p>Or on Debian systems:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">sudo apt-get install automake libtool autoconf gcc-g++ gcc libaio libaio-dev make</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>You could find a slight variation of the package names depending on the
                    version and Linux distribution. (for example gcc-c++ on Fedora versus g++ on
                    Debian systems)</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e11972"/>40.1.2. Invoking the compilation</h3></div></div></div><p>In the distribution, in the <code class="literal">native-src</code> directory, execute the
                shell script <code class="literal">bootstrap</code>. This script will invoke <code class="literal">automake</code> and <code class="literal">make</code> what will create all the make
                files and the native library.</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">someUser@someBox:/messaging-distribution/native-src$ ./bootstrap 
checking for a BSD-compatible install... /usr/bin/install -c
checking whether build environment is sane... yes
checking for a thread-safe mkdir -p... /bin/mkdir -p

...

configure: creating ./config.status
config.status: creating Makefile
config.status: creating ./src/Makefile
config.status: creating config.h
config.status: config.h is unchanged
config.status: executing depfiles commands
config.status: executing libtool commands

...</pre><p>The produced library will be at <code class="literal">./native-src/src/.libs/libHornetQAIO.so</code>. Simply move that file over
                    <code class="literal">bin</code> on the distribution or the place you have chosen on the
                    <a class="link" href="#using-server.library.path" title="6.4. Library Path">library path</a>.</p><p>If you want to perform changes on the HornetQ libaio code, you could just call
                make directly at the <code class="literal">native-src</code> directory.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="thread-pooling"/>Chapter 41. Thread management</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e12031">41.1. Server-Side Thread Management</a></span></dt><dd><dl><dt><span class="section"><a href="#server.scheduled.thread.pool">41.1.1. Server Scheduled Thread Pool</a></span></dt><dt><span class="section"><a href="#d0e12077">41.1.2. General Purpose Server Thread Pool</a></span></dt><dt><span class="section"><a href="#d0e12119">41.1.3. Expiry Reaper Thread</a></span></dt><dt><span class="section"><a href="#d0e12128">41.1.4. Asynchronous IO</a></span></dt></dl></dd><dt><span class="section"><a href="#thread-pooling.client.side">41.2. Client-Side Thread Management</a></span></dt></dl></div><p>This chapter describes how HornetQ uses and pools threads and how you can manage
        them.</p><p>First we'll discuss how threads are managed and used on the server side, then we'll look
        at the client side.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e12031"/>41.1. Server-Side Thread Management</h2></div></div></div><p>Each HornetQ Server maintains a single thread pool for general use, and a scheduled
            thread pool for scheduled use. A Java scheduled thread pool cannot be configured to use
            a standard thread pool, otherwise we could use a single thread pool for both scheduled
            and non scheduled activity.</p><p>A separate thread pool is also used to service connections. HornetQ can use "old"
            (blocking) IO or "new" (non-blocking) IO also called NIO.  Both of these options use
            a separate thread pool, but each of them behaves uniquely.</p><p>Since old IO requires a thread per connection its thread pool is unbounded. The thread
            pool is created via <code class="literal">
            java.util.concurrent.Executors.newCachedThreadPool(ThreadFactory)</code>.  As the
            JavaDoc for this method states:
            “<span class="quote">Creates a thread pool that creates new threads as needed, but will reuse previously
            constructed threads when they are available, and uses the provided ThreadFactory to create
            new threads when needed.</span>”
            Threads from this pool which are idle for more than 60 seconds will time out and be
            removed.  If old IO connections were serviced from the standard pool the pool would
            easily get exhausted if too many connections were made, resulting in the server "hanging"
            since it has no remaining threads to do anything else. However, even an unbounded thread
            pool can run into trouble if it becomes too large. If you require the server to handle
            many concurrent connections you should use NIO, not old IO.</p><p>When using new IO (NIO), HornetQ will, by default, cap its thread pool at three times
            the number of cores (or hyper-threads) as reported by <code class="literal">
            Runtime.getRuntime().availableProcessors()</code> for processing incoming packets.
            To override this value, you can set the number of threads by specifying the parameter
            <code class="literal">nio-remoting-threads</code> in the transport configuration. See the
            <a class="xref" href="#configuring-transports" title="Chapter 16. Configuring the Transport">Chapter 16, <i>Configuring the Transport</i></a> for more information on this.</p><p>There are also a small number of other places where threads are used directly, we'll
            discuss each in turn.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="server.scheduled.thread.pool"/>41.1.1. Server Scheduled Thread Pool</h3></div></div></div><p>The server scheduled thread pool is used for most activities on the server side
                that require running periodically or with delays. It maps internally to a <code class="literal">java.util.concurrent.ScheduledThreadPoolExecutor</code> instance.</p><p>The maximum number of thread used by this pool is configure in <code class="literal">hornetq-configuration.xml</code> with the <code class="literal">scheduled-thread-pool-max-size</code> parameter. The default value is
                    <code class="literal">5</code> threads. A small number of threads is usually sufficient
                for this pool.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e12077"/>41.1.2. General Purpose Server Thread Pool</h3></div></div></div><p>This general purpose thread pool is used for most asynchronous actions on the
                server side. It maps internally to a <code class="literal">java.util.concurrent.ThreadPoolExecutor</code> instance.</p><p>The maximum number of thread used by this pool is configure in <code class="literal">hornetq-configuration.xml</code> with the <code class="literal">thread-pool-max-size</code> parameter.</p><p>If a value of <code class="literal">-1</code> is used this signifies that the thread pool
                has no upper bound and new threads will be created on demand if there are not enough
                threads available to satisfy a request. If activity later subsides then threads are
                timed-out and closed.</p><p>If a value of <code class="literal">n</code> where <code class="literal">n</code>is a positive integer
                greater than zero is used this signifies that the thread pool is bounded. If more
                requests come in and there are no free threads in the pool and the pool is full then
                requests will block until a thread becomes available. It is recommended that a
                bounded thread pool is used with caution since it can lead to dead-lock situations
                if the upper bound is chosen to be too low.</p><p>The default value for <code class="literal">thread-pool-max-size</code> is <code class="literal">30</code>.</p><p>See the <a class="ulink" href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ThreadPoolExecutor.htm">J2SE javadoc</a> for more information on unbounded (cached), and bounded
                (fixed) thread pools.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e12119"/>41.1.3. Expiry Reaper Thread</h3></div></div></div><p>A single thread is also used on the server side to scan for expired messages in
                queues. We cannot use either of the thread pools for this since this thread needs to
                run at its own configurable priority.</p><p>For more information on configuring the reaper, please see <a class="xref" href="#message-expiry" title="Chapter 22. Message Expiry">Chapter 22, <i>Message Expiry</i></a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e12128"/>41.1.4. Asynchronous IO</h3></div></div></div><p>Asynchronous IO has a thread pool for receiving and dispatching events out of the
                native layer. You will find it on a thread dump with the prefix
                HornetQ-AIO-poller-pool. HornetQ uses one thread per opened file on the journal
                (there is usually one).</p><p>There is also a single thread used to invoke writes on libaio. We do that to avoid
                context switching on libaio that would cause performance issues. You will find this
                thread on a thread dump with the prefix HornetQ-AIO-writer-pool.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="thread-pooling.client.side"/>41.2. Client-Side Thread Management</h2></div></div></div><p>On the client side, HornetQ maintains a single static scheduled thread pool and a
            single static general thread pool for use by all clients using the same classloader in
            that JVM instance.</p><p>The static scheduled thread pool has a maximum size of <code class="literal">5</code> threads,
            and the general purpose thread pool has an unbounded maximum size.</p><p>If required HornetQ can also be configured so that each <code class="literal">ClientSessionFactory</code> instance does not use these static pools but instead
            maintains its own scheduled and general purpose pool. Any sessions created from that
                <code class="literal">ClientSessionFactory</code> will use those pools instead.</p><p>To configure a <code class="literal">ClientSessionFactory</code> instance to use its own pools,
            simply use the appropriate setter methods immediately after creation, for
            example:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
ServerLocator locator = HornetQClient.createServerLocatorWithoutHA(...)
ClientSessionFactory myFactory = locator.createClientSessionFactory();
myFactory.setUseGlobalPools(false);
myFactory.setScheduledThreadPoolMaxSize(10);
myFactory.setThreadPoolMaxSize(-1);   </pre><p>If you're using the JMS API, you can set the same parameters on the
            ClientSessionFactory and use it to create the <code class="literal">ConnectionFactory</code>
            instance, for example:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
ConnectionFactory myConnectionFactory = HornetQJMSClient.createConnectionFactory(myFactory);</pre><p>If you're using JNDI to instantiate <code class="literal">HornetQConnectionFactory</code>
            instances, you can also set these parameters in the <code class="literal">hornetq-jms.xml</code>
            file where you describe your connection factory, for example:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;connection-factory name="ConnectionFactory"&gt;
   &lt;connectors&gt;
      &lt;connector-ref connector-name="netty"/&gt;
   &lt;/connectors&gt;
   &lt;entries&gt;
      &lt;entry name="ConnectionFactory"/&gt;
      &lt;entry name="XAConnectionFactory"/&gt;
   &lt;/entries&gt;
   &lt;use-global-pools&gt;false&lt;/use-global-pools&gt;
   &lt;scheduled-thread-pool-max-size&gt;10&lt;/scheduled-thread-pool-max-size&gt;
   &lt;thread-pool-max-size&gt;-1&lt;/thread-pool-max-size&gt;
&lt;/connection-factory&gt;</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="logging"/>Chapter 42. Logging</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e12252">42.1. Logging in a client or with an Embedded server</a></span></dt><dt><span class="section"><a href="#d0e12290">42.2. Logging With The JBoss Application Server</a></span></dt></dl></div><p>HornetQ uses the JBoss Logging framework to do its logging and is configurable via the <code class="literal">logging.properties</code>
       file found in the configuration directories. This is configured by Default to log to both the console and to a file.</p><p>There are 6 loggers available which are as follows:</p><div class="table"><a id="d0e12204"/><p class="title"><b>Table 42.1. Global Configuration Properties</b></p><div class="table-contents"><table summary="Global Configuration Properties" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Logger</th><th>Logger Description</th></tr></thead><tbody><tr><td>org.jboss.logging</td><td>Logs any calls not handled by the HornetQ loggers</td></tr><tr><td>org.hornetq.core.server</td><td>Logs the core server</td></tr><tr><td>org.hornetq.utils</td><td>Logs utility calls</td></tr><tr><td>org.hornetq.journal</td><td>Logs Journal calls</td></tr><tr><td>org.hornetq.jms</td><td>Logs JMS calls</td></tr><tr><td>org.hornetq.integration.bootstrap</td><td>Logs bootstrap calls</td></tr></tbody></table><p>you can configure the levels on these loggers independently in the appropriate <code class="literal">logging.properties</code>
        file</p></div></div><br class="table-break"/><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e12252"/>42.1. Logging in a client or with an Embedded server</h2></div></div></div><p>
         Firstly, if you want to enable logging on the client side you need to include the jboss logging jars in your library.
         If you are using the distribution make sure the jnp-client.jar is included or if you are using maven add the following
         dependencies.
         </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;dependency&gt;
&lt;groupId&gt;org.jboss.naming&lt;/groupId&gt;
&lt;artifactId&gt;jnp-client&lt;/artifactId&gt;
&lt;version&gt;5.0.5.Final&lt;/version&gt;
   &lt;exclusions&gt;
      &lt;exclusion&gt;
         &lt;groupId&gt;org.jboss.logging&lt;/groupId&gt;
         &lt;artifactId&gt;jboss-logging-spi&lt;/artifactId&gt;
      &lt;/exclusion&gt;
   &lt;/exclusions&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.jboss.logmanager&lt;/groupId&gt;
   &lt;artifactId&gt;jboss-logmanager&lt;/artifactId&gt;
   &lt;version&gt;1.3.1.Final&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.hornetq&lt;/groupId&gt;
   &lt;artifactId&gt;hornetq-core-client&lt;/artifactId&gt;
   &lt;version&gt;2.3.0.Final&lt;/version&gt;
&lt;/dependency&gt;</pre><p>
         The first dependency <code class="literal">jnp-client</code> is not actually needed for logging, however this is needed for
         using JNDI and imports a previous version JBoss logging which needs to be excluded
      </p><p>
         There are 2 properties you need to set when starting your java program, the first is to set the Log Manager to use
         the JBoss Log Manager, this is done by setting the <code class="literal">-Djava.util.logging.manager</code> property i.e.
         <code class="literal">-Djava.util.logging.manager=org.jboss.logmanager.LogManager</code>
      </p><p>
         The second is to set the location of the logging.properties file to use, this is done via the <code class="literal">-Dlogging.configuration</code>
         for instance <code class="literal">-Dlogging.configuration=file:///home/user/projects/myProject/logging.properties</code>.
         </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2>The value for this needs to be valid URL</div><p>
      </p><p>
         The following is a typical <code class="literal">logging.properties for a client</code>
         </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
# Root logger option
loggers=org.jboss.logging,org.hornetq.core.server,org.hornetq.utils,org.hornetq.journal,org.hornetq.jms,org.hornetq.ra

# Root logger level
logger.level=INFO
# HornetQ logger levels
logger.org.hornetq.core.server.level=INFO
logger.org.hornetq.utils.level=INFO
logger.org.hornetq.jms.level=DEBUG

# Root logger handlers
logger.handlers=FILE,CONSOLE

# Console handler configuration
handler.CONSOLE=org.jboss.logmanager.handlers.ConsoleHandler
handler.CONSOLE.properties=autoFlush
handler.CONSOLE.level=FINE
handler.CONSOLE.autoFlush=true
handler.CONSOLE.formatter=PATTERN

# File handler configuration
handler.FILE=org.jboss.logmanager.handlers.FileHandler
handler.FILE.level=FINE
handler.FILE.properties=autoFlush,fileName
handler.FILE.autoFlush=true
handler.FILE.fileName=hornetq.log
handler.FILE.formatter=PATTERN

# Formatter pattern configuration
formatter.PATTERN=org.jboss.logmanager.formatters.PatternFormatter
formatter.PATTERN.properties=pattern
formatter.PATTERN.pattern=%d{HH:mm:ss,SSS} %-5p [%c] %s%E%n</pre><p>
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e12290"/>42.2. Logging With The JBoss Application Server</h2></div></div></div><p>When HornetQ is deployed within the JBoss Application Server version 7.x or above then
            it will still use JBoss Logging, refer to the AS7 documentation on how to configure AS7 logging.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="rest"/>Chapter 43. REST Interface</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e12321">43.1. Goals of REST Interface</a></span></dt><dt><span class="section"><a href="#install">43.2. Installation and Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e12353">43.2.1. Installing Within Pre-configured Environment</a></span></dt><dt><span class="section"><a href="#d0e12381">43.2.2. Bootstrapping HornetQ Along with REST</a></span></dt><dt><span class="section"><a href="#configuration">43.2.3. REST Configuration</a></span></dt></dl></dd><dt><span class="section"><a href="#basics">43.3. HornetQ REST Interface Basics</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e12474">43.3.1. Queue and Topic Resources</a></span></dt><dt><span class="section"><a href="#d0e12504">43.3.2. Queue Resource Response Headers</a></span></dt><dt><span class="section"><a href="#d0e12545">43.3.3. Topic Resource Response Headers</a></span></dt></dl></dd><dt><span class="section"><a href="#posting-messages">43.4. Posting Messages</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e12670">43.4.1. Duplicate Detection</a></span></dt><dt><span class="section"><a href="#d0e12791">43.4.2. Persistent Messages</a></span></dt><dt><span class="section"><a href="#d0e12810">43.4.3. TTL, Expiration and Priority</a></span></dt></dl></dd><dt><span class="section"><a href="#message-pull">43.5. Consuming Messages via Pull</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e12900">43.5.1. Auto-Acknowledge</a></span></dt><dt><span class="section"><a href="#d0e13030">43.5.2. Manual Acknowledgement</a></span></dt><dt><span class="section"><a href="#d0e13218">43.5.3. Blocking Pulls with Accept-Wait</a></span></dt><dt><span class="section"><a href="#d0e13230">43.5.4. Clean Up Your Consumers!</a></span></dt></dl></dd><dt><span class="section"><a href="#message-push">43.6. Pushing Messages</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e13246">43.6.1. The Queue Push Subscription XML</a></span></dt><dt><span class="section"><a href="#d0e13328">43.6.2. The Topic Push Subscription XML</a></span></dt><dt><span class="section"><a href="#d0e13338">43.6.3. Creating a Push Subscription at Runtime</a></span></dt><dt><span class="section"><a href="#d0e13371">43.6.4. Creating a Push Subscription by Hand</a></span></dt><dt><span class="section"><a href="#d0e13384">43.6.5. Pushing to Authenticated Servers</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e13397">43.7. Creating Destinations</a></span></dt><dt><span class="section"><a href="#d0e13410">43.8. Securing the HornetQ REST Interface</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e13413">43.8.1. Within JBoss Application server</a></span></dt><dt><span class="section"><a href="#d0e13418">43.8.2. Security in other environments</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e13476">43.9. Mixing JMS and REST</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e13481">43.9.1. JMS Producers - REST Consumers</a></span></dt><dt><span class="section"><a href="#d0e13490">43.9.2. REST Producers - JMS Consumers</a></span></dt></dl></dd></dl></div><p>The HornetQ REST interface allows you to leverage the reliability
        and scalability features of HornetQ over a simple REST/HTTP interface.
        Messages are produced and consumed by sending and receiving simple HTTP
        messages that contain the content you want to push around. For instance,
        here's a simple example of posting an order to an order processing queue
        express as an HTTP message:
    </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
POST /queue/orders/create HTTP/1.1
Host: example.com
Content-Type: application/xml

&lt;order&gt;
   &lt;name&gt;Bill&lt;/name&gt;
   &lt;item&gt;iPhone 4&lt;/item&gt;
   &lt;cost&gt;$199.99&lt;/cost&gt;
&lt;/order&gt;</pre><p>As you can see, we're just posting some arbitrary XML
        document to a URL. When the XML is received on the server is it processed
        within HornetQ as a JMS message and distributed through core HornetQ.
        Simple and easy. Consuming messages from a queue or topic looks very
        similar. We'll discuss the entire interface in detail later in this
        docbook.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e12321"/>43.1. Goals of REST Interface</h2></div></div></div><p>Why would you want to use HornetQ's REST interface? What are the
            goals of the REST interface?
        </p><div class="itemizedlist"><ul><li><p>Easily usable by machine-based (code) clients.</p></li><li><p>Zero client footprint. We want HornetQ to be usable by any
                    client/programming language that has an adequate HTTP client
                    library. You shouldn't have to download, install, and configure a
                    special library to interact with HornetQ.
                </p></li><li><p>Lightweight interoperability. The HTTP protocol is strong
                    enough to be our message exchange protocol. Since interactions are
                    RESTful the HTTP uniform interface provides all the interoperability
                    you need to communicate between different languages, platforms, and
                    even messaging implementations that choose to implement the same
                    RESTful interface as HornetQ (i.e. the
                    <a class="ulink" href="http://rest-star.org">REST-*</a> effort.)
                </p></li><li><p>No envelope (e.g. SOAP) or feed (e.g. Atom) format
                    requirements. You shouldn't have to learn, use, or parse a specific
                    XML document format in order to send and receive messages through
                    HornetQ's REST interface.
                </p></li><li><p>Leverage the reliability, scalability, and clustering features
                    of HornetQ on the back end without sacrificing the simplicity of a
                    REST interface.
                </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="install"/>43.2. Installation and Configuration</h2></div></div></div><p>HornetQ's REST interface is installed as a Web archive (WAR). It
            depends on the
            <a class="ulink" href="http://jboss.org/resteasy">RESTEasy</a>
            project and can currently only run within a servlet container. Installing
            the HornetQ REST interface is a little bit different depending whether
            HornetQ is already installed and configured for your environment (e.g.
            you're deploying within JBoss AS 7) or you want the HornetQ REST
            WAR to startup and manage the HornetQ server (e.g. you're deploying
            within something like Apache Tomcat).
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e12353"/>43.2.1. Installing Within Pre-configured Environment</h3></div></div></div><p>This section should be used when you want to use the HornetQ REST
                interface in an environment that already has HornetQ installed and
                running, e.g. JBoss AS 7. You must create a Web archive
                (.WAR) file with the following web.xml settings:
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;web-app&gt;
   &lt;listener&gt;
      &lt;listener-class&gt;
         org.jboss.resteasy.plugins.server.servlet.ResteasyBootstrap
      &lt;/listener-class&gt;
   &lt;/listener&gt;

   &lt;listener&gt;
      &lt;listener-class&gt;
         org.hornetq.rest.integration.RestMessagingBootstrapListener
      &lt;/listener-class&gt;
   &lt;/listener&gt;

   &lt;filter&gt;
      &lt;filter-name&gt;Rest-Messaging&lt;/filter-name&gt;
      &lt;filter-class&gt;
         org.jboss.resteasy.plugins.server.servlet.FilterDispatcher
      &lt;/filter-class&gt;
   &lt;/filter&gt;

   &lt;filter-mapping&gt;
      &lt;filter-name&gt;Rest-Messaging&lt;/filter-name&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
   &lt;/filter-mapping&gt;
&lt;/web-app&gt;</pre><p>Within your WEB-INF/lib directory you must have the
                hornetq-rest.jar file. If RESTEasy is not installed within your
                environment, you must add the RESTEasy jar files within the lib
                directory as well. Here's a sample Maven pom.xml that can build your WAR
                for this case.
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt;

   &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
   &lt;groupId&gt;org.somebody&lt;/groupId&gt;
   &lt;artifactId&gt;myapp&lt;/artifactId&gt;
   &lt;packaging&gt;war&lt;/packaging&gt;
   &lt;name&gt;My App&lt;/name&gt;
   &lt;version&gt;0.1-SNAPSHOT&lt;/version&gt;
   &lt;repositories&gt;
      &lt;repository&gt;
         &lt;id&gt;jboss&lt;/id&gt;
         &lt;url&gt;http://repository.jboss.org/nexus/content/groups/public/&lt;/url&gt;
      &lt;/repository&gt;
   &lt;/repositories&gt;

   &lt;build&gt;
      &lt;plugins&gt;
         &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
               &lt;source&gt;1.6&lt;/source&gt;
               &lt;target&gt;1.6&lt;/target&gt;
            &lt;/configuration&gt;
         &lt;/plugin&gt;
      &lt;/plugins&gt;
   &lt;/build&gt;

   &lt;dependencies&gt;
      &lt;dependency&gt;
         &lt;groupId&gt;org.hornetq.rest&lt;/groupId&gt;
         &lt;artifactId&gt;hornetq-rest&lt;/artifactId&gt;
         &lt;version&gt;2.3.0-SNAPSHOT&lt;/version&gt;
      &lt;/dependency&gt;
   &lt;/dependencies&gt;
&lt;/project&gt;</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>JBoss AS 7 loads classes differently than previous versions.
                    To work properly in AS 7 the WAR will need this in its MANIFEST.MF:
                </p><pre xmlns="" class="">Dependencies: org.hornetq, org.jboss.netty</pre><p>You can add this to the<code class="literal">&lt;plugins&gt;</code>
                    section of the pom.xml to create this entry automatically:
                </p><pre xmlns="" class="">
&lt;plugin&gt;
   &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
   &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
   &lt;configuration&gt;
      &lt;archive&gt;
         &lt;manifestEntries&gt;
            &lt;Dependencies&gt;org.hornetq, org.jboss.netty&lt;/Dependencies&gt;
         &lt;/manifestEntries&gt;
      &lt;/archive&gt;
   &lt;/configuration&gt;
&lt;/plugin&gt;</pre></div><p>
                It is worth noting that when deploying a WAR in a Java EE application server
                like AS7 the URL for the resulting application will include the name of the
                WAR by default.  For example, if you've constructed a WAR as described above
                named "hornetq-rest.war" then clients will access it at, e.g.
                http://localhost:8080/hornetq-rest/[queues|topics].  We'll see more about
                this later.
            </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>
                    It is possible to put the WAR file at the "root context" of AS7, but
                    that is beyond the scope of this documentation.
                </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e12381"/>43.2.2. Bootstrapping HornetQ Along with REST</h3></div></div></div><p>You can bootstrap HornetQ within your WAR as well. To do this, you
                must have the HornetQ core and JMS jars along with Netty, Resteasy, and
                the HornetQ REST jar within your WEB-INF/lib. You must also have a
                hornetq-configuration.xml, hornetq-jms.xml, and hornetq-users.xml config
                files within WEB-INF/classes. The examples that come with the HornetQ
                REST distribution show how to do this. You must also add an additional
                listener to your web.xml file. Here's an example:
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;web-app&gt;
   &lt;listener&gt;
      &lt;listener-class&gt;
         org.jboss.resteasy.plugins.server.servlet.ResteasyBootstrap
      &lt;/listener-class&gt;
   &lt;/listener&gt;

   &lt;listener&gt;
      &lt;listener-class&gt;
         org.hornetq.rest.integration.HornetqBootstrapListener
      &lt;/listener-class&gt;
   &lt;/listener&gt;

   &lt;listener&gt;
      &lt;listener-class&gt;
         org.hornetq.rest.integration.RestMessagingBootstrapListener
      &lt;/listener-class&gt;
   &lt;/listener&gt;

   &lt;filter&gt;
      &lt;filter-name&gt;Rest-Messaging&lt;/filter-name&gt;
      &lt;filter-class&gt;
         org.jboss.resteasy.plugins.server.servlet.FilterDispatcher
      &lt;/filter-class&gt;
   &lt;/filter&gt;

   &lt;filter-mapping&gt;
      &lt;filter-name&gt;Rest-Messaging&lt;/filter-name&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
   &lt;/filter-mapping&gt;
&lt;/web-app&gt;</pre><p>Here's a Maven pom.xml file for creating a WAR for this
                environment. Make sure your hornetq configuration files are within the
                src/main/resources directory so that they are stuffed within the WAR's
                WEB-INF/classes directory!
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt;

   &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
   &lt;groupId&gt;org.somebody&lt;/groupId&gt;
   &lt;artifactId&gt;myapp&lt;/artifactId&gt;
   &lt;packaging&gt;war&lt;/packaging&gt;
   &lt;name&gt;My App&lt;/name&gt;
   &lt;version&gt;0.1-SNAPSHOT&lt;/version&gt;
   &lt;repositories&gt;
      &lt;repository&gt;
         &lt;id&gt;jboss&lt;/id&gt;
         &lt;url&gt;http://repository.jboss.org/nexus/content/groups/public/&lt;/url&gt;
      &lt;/repository&gt;
   &lt;/repositories&gt;
   &lt;build&gt;
      &lt;plugins&gt;
         &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
               &lt;source&gt;1.6&lt;/source&gt;
               &lt;target&gt;1.6&lt;/target&gt;
            &lt;/configuration&gt;
         &lt;/plugin&gt;
      &lt;/plugins&gt;
   &lt;/build&gt;
   &lt;dependencies&gt;
      &lt;dependency&gt;
         &lt;groupId&gt;org.hornetq&lt;/groupId&gt;
         &lt;artifactId&gt;hornetq-core&lt;/artifactId&gt;
         &lt;version&gt;2.3.0-SNAPSHOT&lt;/version&gt;
      &lt;/dependency&gt;
      &lt;dependency&gt;
         &lt;groupId&gt;io.netty&lt;/groupId&gt;
         &lt;artifactId&gt;netty&lt;/artifactId&gt;
         &lt;version&gt;3.4.5.Final&lt;/version&gt;
      &lt;/dependency&gt;
      &lt;dependency&gt;
         &lt;groupId&gt;org.hornetq&lt;/groupId&gt;
         &lt;artifactId&gt;hornetq-jms&lt;/artifactId&gt;
         &lt;version&gt;2.3.0-SNAPSHOT&lt;/version&gt;
      &lt;/dependency&gt;
      &lt;dependency&gt;
         &lt;groupId&gt;org.jboss.spec.javax.jms&lt;/groupId&gt;
         &lt;artifactId&gt;jboss-jms-api_2.0_spec&lt;/artifactId&gt;
         &lt;version&gt;1.0.0.Final&lt;/version&gt;
      &lt;/dependency&gt;
      &lt;dependency&gt;
         &lt;groupId&gt;org.hornetq.rest&lt;/groupId&gt;
         &lt;artifactId&gt;hornetq-rest&lt;/artifactId&gt;
         &lt;version&gt;2.3.0-SNAPSHOT&lt;/version&gt;
      &lt;/dependency&gt;
      &lt;dependency&gt;
         &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
         &lt;artifactId&gt;resteasy-jaxrs&lt;/artifactId&gt;
         &lt;version&gt;2.3.4.Final&lt;/version&gt;
      &lt;/dependency&gt;
      &lt;dependency&gt;
         &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
         &lt;artifactId&gt;resteasy-jaxb-provider&lt;/artifactId&gt;
         &lt;version&gt;2.3.4.Final&lt;/version&gt;
      &lt;/dependency&gt;
   &lt;/dependencies&gt;
&lt;/project&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="configuration"/>43.2.3. REST Configuration</h3></div></div></div><p>The HornetQ REST implementation does have some configuration
                options. These are configured via XML configuration file that must be in
                your WEB-INF/classes directory. You must set the web.xml context-param
                <code class="literal">rest.messaging.config.file</code> to specify the name of the
                configuration file. Below is the format of the XML configuration file
                and the default values for each.
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;rest-messaging&gt;
   &lt;server-in-vm-id&gt;0&lt;/server-in-vm-id&gt;
   &lt;use-link-headers&gt;false&lt;/use-link-headers&gt;
   &lt;default-durable-send&gt;false&lt;/default-durable-send&gt;
   &lt;dups-ok&gt;true&lt;/dups-ok&gt;
   &lt;topic-push-store-dir&gt;topic-push-store&lt;/topic-push-store-dir&gt;
   &lt;queue-push-store-dir&gt;queue-push-store&lt;/queue-push-store-dir&gt;
   &lt;producer-time-to-live&gt;0&lt;/producer-time-to-live&gt;
   &lt;producer-session-pool-size&gt;10&lt;/producer-session-pool-size&gt;
   &lt;session-timeout-task-interval&gt;1&lt;/session-timeout-task-interval&gt;
   &lt;consumer-session-timeout-seconds&gt;300&lt;/consumer-session-timeout-seconds&gt;
   &lt;consumer-window-size&gt;-1&lt;/consumer-window-size&gt;
&lt;/rest-messaging&gt;</pre><p>Let's give an explanation of each config option.</p><div class="itemizedlist"><ul><li><p><code class="literal">server-in-vm-id</code>. The HornetQ REST
                        impl uses the IN-VM transport to communicate with HornetQ.
                        It uses the default server id, which is "0".
                    </p></li><li><p><code class="literal">use-link-headers</code>. By default, all
                        links (URLs) are published using custom headers. You can
                        instead have the HornetQ REST implementation publish links
                        using the <a class="ulink" href="http://tools.ietf.org/html/draft-nottingham-http-link-header-10">
                            Link Header specification
                        </a> instead if you desire.
                    </p></li><li><p><code class="literal">default-durable-send</code>. Whether a posted
                        message should be persisted by default if the user does not
                        specify a durable query parameter.
                    </p></li><li><p><code class="literal">dups-ok</code>. If this is true, no duplicate
                        detection protocol will be enforced for message posting.
                    </p></li><li><p><code class="literal">topic-push-store-dir</code>. This must be
                        a relative or absolute file system path. This is a directory
                        where push registrations for topics are stored. See
                        <a class="link" href="#message-push" title="43.6. Pushing Messages">Pushing Messages</a>.
                    </p></li><li><p><code class="literal">queue-push-store-dir</code>. This must be
                        a relative or absolute file system path. This is a
                        directory where push registrations for queues are stored.
                        See <a class="link" href="#message-push" title="43.6. Pushing Messages">Pushing Messages</a>.
                    </p></li><li><p><code class="literal">producer-session-pool-size</code>. The REST
                        implementation pools HornetQ sessions for sending messages.
                        This is the size of the pool. That number of sessions will
                        be created at startup time.
                    </p></li><li><p><code class="literal">producer-time-to-live</code>. Default time
                        to live for posted messages. Default is no ttl.
                    </p></li><li><p><code class="literal">session-timeout-task-interval</code>. Pull
                        consumers and pull subscriptions can time out. This is
                        the interval the thread that checks for timed-out sessions
                        will run at. A value of 1 means it will run every 1 second.
                    </p></li><li><p><code class="literal">consumer-session-timeout-seconds</code>.
                        Timeout in seconds for pull consumers/subscriptions that
                        remain idle for that amount of time.
                    </p></li><li><p><code class="literal">consumer-window-size</code>. For consumers,
                        this config option is the same as the HornetQ one of the
                        same name. It will be used by sessions created by the
                        HornetQ REST implementation.
                    </p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="basics"/>43.3. HornetQ REST Interface Basics</h2></div></div></div><p>The HornetQ REST interface publishes a variety of REST resources to
            perform various tasks on a queue or topic. Only the top-level queue and
            topic URI schemes are published to the outside world. You must discover
            all over resources to interact with by looking for and traversing links.
            You'll find published links within custom response headers and embedded in
            published XML representations. Let's look at how this works.
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e12474"/>43.3.1. Queue and Topic Resources</h3></div></div></div><p>To interact with a queue or topic you do a HEAD or GET request on
                the following relative URI pattern:
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
/queues/{name}
/topics/{name}</pre><p>The base of the URI is the base URL of the WAR you deployed the
                HornetQ REST server within as defined in the
                <a class="link" href="#install" title="43.2. Installation and Configuration">Installation and Configuration</a>
                section of this document. Replace the <code class="literal">{name}</code>
                string within the above URI pattern with the name of the queue or
                topic you are interested in interacting with. For example if you
                have configured a JMS topic named "foo" within your
                <code class="literal">hornetq-jms.xml</code> file, the URI name should be
                "jms.topic.foo". If you have configured a JMS queue name "bar" within
                your <code class="literal">hornetq-jms.xml</code> file, the URI name should be
                "jms.queue.bar". Internally, HornetQ prepends the "jms.topic" or
                "jms.queue" strings to the name of the deployed destination. Next,
                perform your HEAD or GET request on this URI. Here's what a
                request/response would look like.
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
HEAD /queues/jms.queue.bar HTTP/1.1
Host: example.com

--- Response ---
HTTP/1.1 200 Ok
msg-create: http://example.com/queues/jms.queue.bar/create
msg-create-with-id: http://example.com/queues/jms.queue.bar/create/{id}
msg-pull-consumers: http://example.com/queues/jms.queue.bar/pull-consumers
msg-push-consumers: http://example.com/queues/jms.queue.bar/push-consumers</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>
                    You can use the "curl" utility to test this easily. Simply execute
                    a command like this:
                </p><pre xmlns="" class="">
curl --head http://example.com/queues/jms.queue.bar</pre></div><p>The HEAD or GET response contains a number of custom response
                headers that are URLs to additional REST resources that allow you to
                interact with the queue or topic in different ways. It is important not
                to rely on the scheme of the URLs returned within these headers as they
                are an implementation detail. Treat them as opaque and query for them
                each and every time you initially interact (at boot time) with the
                server. If you treat all URLs as opaque then you will be isolated from
                implementation changes as the HornetQ REST interface evolves over
                time.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e12504"/>43.3.2. Queue Resource Response Headers</h3></div></div></div><p>Below is a list of response headers you should expect when
                interacting with a Queue resource.
            </p><div class="itemizedlist"><ul><li><p><code class="literal">msg-create</code>. This is a URL you POST messages
                        to. The semantics of this link are described in
                        <a class="link" href="#posting-messages" title="43.4. Posting Messages">Posting Messages</a>.
                    </p></li><li><p><code class="literal">msg-create-with-id</code>. This is a URL
                        <span class="emphasis"><em>template</em></span> you can use to POST messages.
                        The semantics of this link are described in
                        <a class="link" href="#posting-messages" title="43.4. Posting Messages">Posting Messages</a>.
                    </p></li><li><p><code class="literal">msg-pull-consumers</code>. This is a URL for
                        creating consumers that will pull from a queue. The semantics
                        of this link are described in
                        <a class="link" href="#message-pull" title="43.5. Consuming Messages via Pull">Consuming Messages via Pull</a>.
                    </p></li><li><p><code class="literal">msg-push-consumers</code>. This is a URL for
                        registering other URLs you want the HornetQ REST server to
                        push messages to. The semantics of this link are described
                        in <a class="link" href="#message-push" title="43.6. Pushing Messages">Pushing Messages</a>.
                    </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e12545"/>43.3.3. Topic Resource Response Headers</h3></div></div></div><p>Below is a list of response headers you should expect when
                interacting with a Topic resource.
            </p><div class="itemizedlist"><ul><li><p><code class="literal">msg-create</code>. This is a URL you POST
                        messages to. The semantics of this link are described in
                        <a class="link" href="#posting-messages" title="43.4. Posting Messages">Posting Messages</a>.
                    </p></li><li><p><code class="literal">msg-create-with-id</code>. This is a URL
                        <span class="emphasis"><em>template</em></span> you can use to POST messages.
                        The semantics of this link are described in
                        <a class="link" href="#posting-messages" title="43.4. Posting Messages">Posting Messages</a>.
                    </p></li><li><p><code class="literal">msg-pull-subscriptions</code>. This is a
                        URL for creating subscribers that will pull from a topic.
                        The semantics of this link are described in
                        <a class="link" href="#message-pull" title="43.5. Consuming Messages via Pull">Consuming Messages via Pull</a>.
                    </p></li><li><p><code class="literal">msg-push-subscriptions</code>. This is a
                        URL for registering other URLs you want the HornetQ REST
                        server to push messages to. The semantics of this link
                        are described in <a class="link" href="#message-push" title="43.6. Pushing Messages">Pushing
                        Messages</a>.
                    </p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="posting-messages"/>43.4. Posting Messages</h2></div></div></div><p>This chapter discusses the protocol for posting messages to a queue
            or a topic. In <a class="link" href="#basics" title="43.3. HornetQ REST Interface Basics">HornetQ REST Interface Basics</a>,
            you saw that a queue or topic resource publishes variable custom headers
            that are links to other RESTful resources. The <code class="literal">msg-create</code>
            header is a URL you can post a message to. Messages are published to a queue
            or topic by sending a simple HTTP message to the URL published by the
            <code class="literal">msg-create</code> header. The HTTP message contains whatever
            content you want to publish to the HornetQ destination. Here's an example
            scenario:
        </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>You can also post messages to the URL template found in
                <code class="literal">msg-create-with-id</code>, but this is a more advanced
                use-case involving duplicate detection that we will discuss later in
                this section.
            </p></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>Obtain the starting <code class="literal">msg-create</code> header from
                    the queue or topic resource.
                </p><p>
                    </p><pre xmlns="" class="">
HEAD /queues/jms.queue.bar HTTP/1.1
Host: example.com

--- Response ---
HTTP/1.1 200 Ok
msg-create: http://example.com/queues/jms.queue.bar/create
msg-create-with-id: http://example.com/queues/jms.queue.bar/create/{id}</pre><p>
                </p></li><li><p>Do a POST to the URL contained in the <code class="literal">msg-create</code>
                    header.
                </p><pre xmlns="" class="">
POST /queues/jms.queue.bar/create
Host: example.com
Content-Type: application/xml

&lt;order&gt;
   &lt;name&gt;Bill&lt;/name&gt;
   &lt;item&gt;iPhone4&lt;/name&gt;
   &lt;cost&gt;$199.99&lt;/cost&gt;
&lt;/order&gt;

--- Response ---
HTTP/1.1 201 Created
msg-create-next: http://example.com/queues/jms.queue.bar/create</pre><div class="note"><h2>Note</h2><p>You can use the "curl" utility to test this easily. Simply execute
                        a command like this:
                    </p><pre xmlns="" class="">
curl --verbose --data "123" http://example.com/queues/jms.queue.bar/create</pre></div><p>A successful response will return a 201 response code. Also
                    notice that a <code class="literal">msg-create-next</code> response header
                    is sent as well. You must use this URL to POST your next message.
                </p></li><li><p>POST your next message to the queue using the URL returned in
                    the <code class="literal">msg-create-next</code> header.
                </p><pre xmlns="" class="">
POST /queues/jms.queue.bar/create
Host: example.com
Content-Type: application/xml

&lt;order&gt;
   &lt;name&gt;Monica&lt;/name&gt;
   &lt;item&gt;iPad&lt;/item&gt;
   &lt;cost&gt;$499.99&lt;/cost&gt;
&lt;/order&gt;

--- Response --
HTTP/1.1 201 Created
msg-create-next: http://example.com/queues/jms.queue.bar/create</pre><p>Continue using the new <code class="literal">msg-create-next</code>
                    header returned with each response.
                </p></li></ol></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>It is <span class="emphasis"><em>VERY IMPORTANT</em></span> that you never re-use returned
                <code class="literal">msg-create-next</code> headers to post new messages. If the
                <code class="literal">dups-ok</code> configuration property is set to
                <code class="literal">false</code> on the server then this URL will be uniquely
                generated for each message and used for duplicate detection. If you lose
                the URL within the <code class="literal">msg-create-next</code> header, then just
                go back to the queue or topic resource to get the
                <code class="literal">msg-create</code> URL again.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e12670"/>43.4.1. Duplicate Detection</h3></div></div></div><p>Sometimes you might have network problems when posting new
                messages to a queue or topic. You may do a POST and never receive a
                response. Unfortunately, you don't know whether or not the server
                received the message and so a re-post of the message might cause
                duplicates to be posted to the queue or topic. By default, the HornetQ
                REST interface is configured to accept and post duplicate messages. You
                can change this by turning on duplicate message detection by setting the
                <code class="literal">dups-ok</code> config option to <code class="literal">false</code>
                as described in <a class="link" href="#basics" title="43.3. HornetQ REST Interface Basics">HornetQ REST Interface Basics</a>.
                When you do this, the initial POST to the <code class="literal">msg-create</code>
                URL will redirect you, using the standard HTTP 307 redirection mechanism
                to a unique URL to POST to. All other interactions remain the same as
                discussed earlier. Here's an example:
            </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>Obtain the starting <code class="literal">msg-create</code> header from
                        the queue or topic resource.
                    </p><p>
                        </p><pre xmlns="" class="">
HEAD /queues/jms.queue.bar HTTP/1.1
Host: example.com

--- Response ---
HTTP/1.1 200 Ok
msg-create: http://example.com/queues/jms.queue.bar/create
msg-create-with-id: http://example.com/queues/jms.queue.bar/create/{id}</pre><p>
                    </p></li><li><p>Do a POST to the URL contained in the <code class="literal">msg-create</code>
                        header.
                    </p><pre xmlns="" class="">
POST /queues/jms.queue.bar/create
Host: example.com
Content-Type: application/xml

&lt;order&gt;
   &lt;name&gt;Bill&lt;/name&gt;
   &lt;item&gt;iPhone4&lt;/name&gt;
   &lt;cost&gt;$199.99&lt;/cost&gt;
&lt;/order&gt;

--- Response ---
HTTP/1.1 307 Redirect
Location: http://example.com/queues/jms.queue.bar/create/13582001787372</pre><p>A successful response will return a 307 response code. This
                        is standard HTTP protocol. It is telling you that you must re-POST
                        to the URL contained within the <code class="literal">Location</code>
                        header.
                    </p></li><li><p>re-POST your message to the URL provided within the
                        <code class="literal">Location</code> header.
                    </p><pre xmlns="" class="">
POST /queues/jms.queue.bar/create/13582001787372
Host: example.com
Content-Type: application/xml

&lt;order&gt;
   &lt;name&gt;Bill&lt;/name&gt;
   &lt;item&gt;iPhone4&lt;/name&gt;
   &lt;cost&gt;$199.99&lt;/cost&gt;
&lt;/order&gt;

--- Response --
HTTP/1.1 201 Created
msg-create-next: http://example.com/queues/jms.queue.bar/create/13582001787373</pre><p>You should receive a 201 Created response. If there is a
                        network failure, just re-POST to the Location header. For new
                        messages, use the returned <code class="literal">msg-create-next</code>
                        header returned with each response.
                    </p></li><li><p>POST any new message to the returned
                        <code class="literal">msg-create-next</code> header.
                    </p><pre xmlns="" class="">
POST /queues/jms.queue.bar/create/13582001787373
Host: example.com
Content-Type: application/xml

&lt;order&gt;
   &lt;name&gt;Monica&lt;/name&gt;
   &lt;item&gt;iPad&lt;/name&gt;
   &lt;cost&gt;$499.99&lt;/cost&gt;
&lt;/order&gt;

--- Response --
HTTP/1.1 201 Created
msg-create-next: http://example.com/queues/jms.queue.bar/create/13582001787374</pre><p>If there ever is a network problem, just repost to the URL
                        provided in the <code class="literal">msg-create-next</code> header.
                    </p></li></ol></div><p>How can this work? As you can see, with each successful response,
                the HornetQ REST server returns a uniquely generated URL within the
                msg-create-next header. This URL is dedicated to the next new message
                you want to post. Behind the scenes, the code extracts an identify from
                the URL and uses HornetQ's duplicate detection mechanism by setting the
                <code class="literal">DUPLICATE_DETECTION_ID</code> property of the JMS message
                that is actually posted to the system.
            </p><p>If you happen to use the same ID more than once you'll see a message
                like this on the server:
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
WARN  [org.hornetq.core.server] (Thread-3 (HornetQ-remoting-threads-HornetQServerImpl::serverUUID=8d6be6f8-5e8b-11e2-80db-51bbde66f473-26319292-267207)) HQ112098: Duplicate message detected - message will not be routed. Message information:
ServerMessage[messageID=20,priority=4, bodySize=1500,expiration=0, durable=true, address=jms.queue.bar,properties=TypedProperties[{http_content$type=application/x-www-form-urlencoded, http_content$length=3, postedAsHttpMessage=true, _HQ_DUPL_ID=42}]]@12835058</pre><p>An alternative to this approach is to use the <code class="literal">msg-create-with-id</code>
                header. This is not an invokable URL, but a URL template. The idea is that
                the client provides the <code class="literal">DUPLICATE_DETECTION_ID</code> and creates
                its own <code class="literal">create-next</code> URL. The <code class="literal">msg-create-with-id</code>
                header looks like this (you've see it in previous examples, but we haven't used it):
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
msg-create-with-id: http://example.com/queues/jms.queue.bar/create/{id}</pre><p>You see that it is a regular URL appended with a <code class="literal">{id}</code>. This
                <code class="literal">{id}</code> is a pattern matching substring. A client would generate its
                <code class="literal">DUPLICATE_DETECTION_ID</code> and replace <code class="literal">{id}</code>
                with that generated id, then POST to the new URL. The URL the client creates
                works exactly like a <code class="literal">create-next</code> URL described earlier. The 
                response of this POST would also return a new <code class="literal">msg-create-next</code>
                header. The client can continue to generate its own DUPLICATE_DETECTION_ID, or 
                use the new URL returned via the <code class="literal">msg-create-nex</code>t header.
            </p><p>The advantage of this approach is that the client does not have to
                repost the message. It also only has to come up with a unique
                <code class="literal">DUPLICATE_DETECTION_ID</code> once.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e12791"/>43.4.2. Persistent Messages</h3></div></div></div><p>By default, posted messages are not durable and will not be
                persisted in HornetQ's journal. You can create durable messages by
                modifying the default configuration as expressed in Chapter 2 so that
                all messages are persisted when sent. Alternatively, you can set a URL
                query parameter called <code class="literal">durable</code> to true when you post
                your messages to the URLs returned in the <code class="literal">msg-create</code>,
                <code class="literal">msg-create-with-id</code>, or <code class="literal">msg-create-next</code>
                headers. here's an example of that.
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
POST /queues/jms.queue.bar/create?durable=true
Host: example.com
Content-Type: application/xml

&lt;order&gt;
   &lt;name&gt;Bill&lt;/name&gt;
   &lt;item&gt;iPhone4&lt;/item&gt;
   &lt;cost&gt;$199.99&lt;/cost&gt;
&lt;/order&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e12810"/>43.4.3. TTL, Expiration and Priority</h3></div></div></div><p>You can set the time to live, expiration, and/or the priority of
                the message in the queue or topic by setting an additional query
                parameter. The <code class="literal">expiration</code> query parameter is an long
                specify the time in milliseconds since epoch (a long date). The
                <code class="literal">ttl</code> query parameter is a time in milliseconds you
                want the message active. The <code class="literal">priority</code> is another
                query parameter with an integer value between 0 and 9 expressing the
                priority of the message. i.e.:
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
POST /queues/jms.queue.bar/create?expiration=30000&amp;priority=3
Host: example.com
Content-Type: application/xml

&lt;order&gt;
   &lt;name&gt;Bill&lt;/name&gt;
   &lt;item&gt;iPhone4&lt;/item&gt;
   &lt;cost&gt;$199.99&lt;/cost&gt;
&lt;/order&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="message-pull"/>43.5. Consuming Messages via Pull</h2></div></div></div><p>There are two different ways to consume messages from a topic or
            queue. You can wait and have the messaging server push them to you, or you
            can continuously poll the server yourself to see if messages are
            available. This chapter discusses the latter. Consuming messages via a
            pull works almost identically for queues and topics with some minor, but
            important caveats. To start consuming you must create a consumer resource
            on the server that is dedicated to your client. Now, this pretty much
            breaks the stateless principle of REST, but after much prototyping, this
            is the best way to work most effectively with HornetQ through a REST
            interface.
        </p><p>You create consumer resources by doing a simple POST to the URL
            published by the <code class="literal">msg-pull-consumers</code>
            response header if you are interacting with a queue, the
            <code class="literal">msg-pull-subscribers</code> response header if you're
            interacting with a topic. These headers are provided by the main queue or
            topic resource discussed in <a class="link" href="#basics" title="43.3. HornetQ REST Interface Basics">HornetQ REST Interface
            Basics</a>. Doing an empty POST to one of these
            URLs will create a consumer resource that follows an auto-acknowledge
            protocol and, if you are interacting with a topic, creates a temporarily 
            subscription to the topic. If you want to use the acknowledgement protocol
            and/or create a durable subscription (topics only), then you must use the
            form parameters (<code class="literal">application/x-www-form-urlencoded</code>)
            described below.
        </p><div class="itemizedlist"><ul><li><p><code class="literal">autoAck</code>. A value of <code class="literal">true</code>
                    or <code class="literal">false</code> can be given. This defaults to
                    <code class="literal">true</code> if you do not pass this parameter.
                </p></li><li><p><code class="literal">durable</code>. A value of <code class="literal">true</code>
                    or <code class="literal">false</code> can be given. This defaults to
                    <code class="literal">false</code> if you do not pass this parameter.
                    Only available on topics. This specifies whether you want a
                    durable subscription or not. A durable subscription persists
                    through server restart.
                </p></li><li><p><code class="literal">name</code>. This is the name of the durable
                    subscription. If you do not provide this parameter, the name
                    will be automatically generated by the server. Only usable
                    on topics.
                </p></li><li><p><code class="literal">selector</code>. This is an optional JMS selector
                    string. The HornetQ REST interface adds HTTP headers to the
                    JMS message for REST produced messages. HTTP headers are
                    prefixed with "http_" and every '-' character is converted
                    to a '$'.
                </p></li><li><p><code class="literal">idle-timeout</code>. For a topic subscription,
                    idle time in milliseconds in which the consumer connections
                    will be closed if idle.
                </p></li><li><p><code class="literal">delete-when-idle</code>. Boolean value, If
                    true, a topic subscription will be deleted (even if it is
                    durable) when an the idle timeout is reached.
                </p></li></ul></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>If you have multiple pull-consumers active at the same time
                on the same destination be aware that unless the
                <code class="literal">consumer-window-size</code> is 0 then one consumer
                might buffer messages while the other consumer gets none.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e12900"/>43.5.1. Auto-Acknowledge</h3></div></div></div><p>This section focuses on the auto-acknowledge protocol for
                consuming messages via a pull. Here's a list of the response
                headers and URLs you'll be interested in.
            </p><div class="itemizedlist"><ul><li><p><code class="literal">msg-pull-consumers</code>. The URL of
                        a factory resource for creating queue consumer
                        resources. You will pull from these created resources.
                    </p></li><li><p><code class="literal">msg-pull-subscriptions</code>. The URL
                        of a factory resource for creating topic subscription
                        resources. You will pull from the created resources.
                    </p></li><li><p><code class="literal">msg-consume-next</code>. The URL you
                        will pull the next message from. This is returned
                        with every response.
                    </p></li><li><p><code class="literal">msg-consumer</code>. This is a URL
                        pointing back to the consumer or subscription
                        resource created for the client.
                    </p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e12926"/>43.5.1.1. Creating an Auto-Ack Consumer or Subscription</h4></div></div></div><p>Here is an example of creating an auto-acknowledged
                    queue pull consumer.
                </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>Find the pull-consumers URL by doing a HEAD or
                            GET request to the base queue resource.
                        </p><pre xmlns="" class="">
HEAD /queues/jms.queue.bar HTTP/1.1
Host: example.com

--- Response ---
HTTP/1.1 200 Ok
msg-create: http://example.com/queues/jms.queue.bar/create
msg-pull-consumers: http://example.com/queues/jms.queue.bar/pull-consumers
msg-push-consumers: http://example.com/queues/jms.queue.bar/push-consumers</pre></li><li><p>Next do an empty POST to the URL returned in the
                            <code class="literal">msg-pull-consumers</code>
                            header.
                        </p><pre xmlns="" class="">
POST /queues/jms.queue.bar/pull-consumers HTTP/1.1
Host: example.com

--- response ---
HTTP/1.1 201 Created
Location: http://example.com/queues/jms.queue.bar/pull-consumers/auto-ack/333
msg-consume-next: http://example.com/queues/jms.queue.bar/pull-consumers/auto-ack/333/consume-next-1</pre><p>The
                            <code class="literal">Location</code>
                            header points to the JMS
                            consumer resource that was created on the server. It is good to
                            remember this URL, although, as you'll see later, it is
                            transmitted with each response just to remind you.
                        </p></li></ol></div><p>Creating an auto-acknowledged consumer for a topic is pretty
                    much the same. Here's an example of creating a durable
                    auto-acknowledged topic pull subscription.
                </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>Find the
                            <code class="literal">pull-subscriptions</code>
                            URL by doing
                            a HEAD or GET request to the base topic resource
                        </p><pre xmlns="" class="">
HEAD /topics/jms.topic.bar HTTP/1.1
Host: example.com

--- Response ---
HTTP/1.1 200 Ok
msg-create: http://example.com/topics/jms.topic.foo/create
msg-pull-subscriptions: http://example.com/topics/jms.topic.foo/pull-subscriptions
msg-push-subscriptions: http://example.com/topics/jms.topic.foo/push-subscriptions</pre></li><li><p>Next do a POST to the URL returned in the
                            <code class="literal">msg-pull-subscriptions</code>
                            header passing in a <code class="literal">true</code>
                            value for the <code class="literal">durable</code>
                            form parameter.
                        </p><pre xmlns="" class="">
POST /topics/jms.topic.foo/pull-subscriptions HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded

durable=true

--- Response ---
HTTP/1.1 201 Created
Location: http://example.com/topics/jms.topic.foo/pull-subscriptions/auto-ack/222
msg-consume-next:
http://example.com/topics/jms.topic.foo/pull-subscriptions/auto-ack/222/consume-next-1</pre><p>The
                            <code class="literal">Location</code>
                            header points to the JMS
                            subscription resource that was created on the server. It is good
                            to remember this URL, although, as you'll see later, it is
                            transmitted with each response just to remind you.
                        </p></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e12980"/>43.5.1.2. Consuming Messages</h4></div></div></div><p>After you have created a consumer resource, you are ready to
                    start pulling messages from the server. Notice that when you created
                    the consumer for either the queue or topic, the response contained a
                    <code class="literal">msg-consume-next</code> response header. POST to the URL
                    contained within this header to consume the next message in the queue
                    or topic subscription. A successful POST causes the server to extract
                    a message from the queue or topic subscription, acknowledge it, and
                    return it to the consuming client. If there are no messages in the
                    queue or topic subscription, a 503 (Service Unavailable) HTTP code is
                    returned.
                </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>For both successful and unsuccessful posts to the
                        msg-consume-next URL, the response will contain a new
                        msg-consume-next header. You must ALWAYS use this new URL returned
                        within the new msg-consume-next header to consume new
                        messages.
                    </p></div><p>Here's an example of pulling multiple messages from the consumer
                    resource.
                </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>Do a POST on the msg-consume-next URL that was returned with
                            the consumer or subscription resource discussed earlier.
                        </p><pre xmlns="" class="">
POST /queues/jms.queue.bar/pull-consumers/consume-next-1
Host: example.com

--- Response ---
HTTP/1.1 200 Ok
Content-Type: application/xml
msg-consume-next: http://example.com/queues/jms.queue.bar/pull-consumers/333/consume-next-2
msg-consumer: http://example.com/queues/jms.queue.bar/pull-consumers/333

&lt;order&gt;...&lt;/order&gt;</pre><p>The POST returns the message consumed from the queue. It
                            also returns a new msg-consume-next link. Use this new link to get
                            the next message. Notice also a msg-consumer response header is
                            returned. This is a URL that points back to the consumer or
                            subscription resource. You will need that to clean up your
                            connection after you are finished using the queue or topic.
                        </p></li><li><p>The POST returns the message consumed from the queue. It
                            also returns a new msg-consume-next link. Use this new link to get
                            the next message.
                        </p><pre xmlns="" class="">
POST /queues/jms.queue.bar/pull-consumers/consume-next-2
Host: example.com

--- Response ---
Http/1.1 503 Service Unavailable
Retry-After: 5
msg-consume-next: http://example.com/queues/jms.queue.bar/pull-consumers/333/consume-next-2</pre><p>In this case, there are no messages in the queue, so we get
                            a 503 response back. As per the HTTP 1.1 spec, a 503 response may
                            return a Retry-After head specifying the time in seconds that you
                            should retry a post. Also notice, that another new
                            msg-consume-next URL is present. Although it probably is the same
                            URL you used last post, get in the habit of using URLs returned in
                            response headers as future versions of HornetQ REST might be
                            redirecting you or adding additional data to the URL after
                            timeouts like this.
                        </p></li><li><p>POST to the URL within the last
                            <code class="literal">msg-consume-next</code>
                            to get the next
                            message.
                        </p><pre xmlns="" class="">
POST /queues/jms.queue.bar/pull-consumers/consume-next-2
Host: example.com

--- Response ---
HTTP/1.1 200 Ok
Content-Type: application/xml
msg-consume-next: http://example.com/queues/jms.queue.bar/pull-consumers/333/consume-next-3

&lt;order&gt;...&lt;/order&gt;</pre></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e13016"/>43.5.1.3. Recovering From Network Failures</h4></div></div></div><p>If you experience a network failure and do not know if your post
                    to a msg-consume-next URL was successful or not, just re-do your POST.
                    A POST to a msg-consume-next URL is idempotent, meaning that it will
                    return the same result if you execute on any one msg-consume-next URL
                    more than once. Behind the scenes, the consumer resource caches the
                    last consumed message so that if there is a message failure and you do
                    a re-post, the cached last message will be returned (along with a new
                    msg-consume-next URL). This is the reason why the protocol always
                    requires you to use the next new msg-consume-next URL returned with
                    each response. Information about what state the client is in is
                    embedded within the actual URL.
                </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e13021"/>43.5.1.4. Recovering From Client or Server Crashes</h4></div></div></div><p>If the server crashes and you do a POST to the msg-consume-next
                    URL, the server will return a 412 (Preconditions Failed) response
                    code. This is telling you that the URL you are using is out of sync
                    with the server. The response will contain a new msg-consume-next
                    header to invoke on.
                </p><p>If the client crashes there are multiple ways you can recover.
                    If you have remembered the last msg-consume-next link, you can just
                    re-POST to it. If you have remembered the consumer resource URL, you
                    can do a GET or HEAD request to obtain a new msg-consume-next URL. If
                    you have created a topic subscription using the name parameter
                    discussed earlier, you can re-create the consumer. Re-creation will
                    return a msg-consume-next URL you can use. If you cannot do any of
                    these things, you will have to create a new consumer.
                </p><p>The problem with the auto-acknowledge protocol is that if the
                    client or server crashes, it is possible for you to skip messages. The
                    scenario would happen if the server crashes after auto-acknowledging a
                    message and before the client receives the message. If you want more
                    reliable messaging, then you must use the acknowledgement
                    protocol.
                </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13030"/>43.5.2. Manual Acknowledgement</h3></div></div></div><p>The manual acknowledgement protocol is similar to the auto-ack
                protocol except there is an additional round trip to the server to tell
                it that you have received the message and that the server can internally
                ack the message. Here is a list of the response headers you will be
                interested in.
            </p><div class="itemizedlist"><ul><li><p><code class="literal">msg-pull-consumers</code>. The URL of a factory resource for creating queue
                        consumer
                        resources. You will pull from these created resources
                    </p></li><li><p><code class="literal">msg-pull-subscriptions</code>. The URL of a factory resource for creating topic
                        subscription resources. You will pull from the created
                        resources.
                    </p></li><li><p><code class="literal">msg-acknowledge-next</code>. URL used to obtain the next message in the queue or
                        topic
                        subscription. It does not acknowledge the message though.
                    </p></li><li><p><code class="literal">msg-acknowledgement</code>. URL used to acknowledge a message.
                    </p></li><li><p><code class="literal">msg-consumer</code>. This is a URL pointing back to the consumer or subscription
                        resource created for the client.
                    </p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e13061"/>43.5.2.1. Creating manually-acknowledged consumers or
                    subscriptions
                </h4></div></div></div><p>Here is an example of creating an auto-acknowledged queue pull
                    consumer.
                </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>Find the pull-consumers URL by doing a HEAD or GET request
                            to the base queue resource.
                        </p><pre xmlns="" class="">
HEAD /queues/jms.queue.bar HTTP/1.1
Host: example.com

--- Response ---
HTTP/1.1 200 Ok
msg-create: http://example.com/queues/jms.queue.bar/create
msg-pull-consumers: http://example.com/queues/jms.queue.bar/pull-consumers
msg-push-consumers: http://example.com/queues/jms.queue.bar/push-consumers</pre></li><li><p>Next do a POST to the URL returned in the
                            <code class="literal">msg-pull-consumers</code>
                            header passing in a
                            <code class="literal">false</code>
                            value to the
                            <code class="literal">autoAck</code>
                            form parameter .
                        </p><pre xmlns="" class="">
POST /queues/jms.queue.bar/pull-consumers HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded

autoAck=false

--- response ---
HTTP/1.1 201 Created
Location: http://example.com/queues/jms.queue.bar/pull-consumers/acknowledged/333
msg-acknowledge-next: http://example.com/queues/jms.queue.bar/pull-consumers/acknowledged/333/acknowledge-next-1</pre><p>The
                            <code class="literal">Location</code>
                            header points to the JMS
                            consumer resource that was created on the server. It is good to
                            remember this URL, although, as you'll see later, it is
                            transmitted with each response just to remind you.
                        </p></li></ol></div><p>Creating an manually-acknowledged consumer for a topic is pretty
                    much the same. Here's an example of creating a durable
                    manually-acknowledged topic pull subscription.
                </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>Find the
                            <code class="literal">pull-subscriptions</code>
                            URL by doing
                            a HEAD or GET request to the base topic resource
                        </p><pre xmlns="" class="">
HEAD /topics/jms.topic.bar HTTP/1.1
Host: example.com

--- Response ---
HTTP/1.1 200 Ok
msg-create: http://example.com/topics/jms.topic.foo/create
msg-pull-subscriptions: http://example.com/topics/jms.topic.foo/pull-subscriptions
msg-push-subscriptions: http://example.com/topics/jms.topic.foo/push-subscriptions</pre></li><li><p>Next do a POST to the URL returned in the
                            <code class="literal">msg-pull-subscriptions</code>
                            header passing in a <code class="literal">true</code>
                            value for the <code class="literal">durable</code>
                            form parameter and a <code class="literal">false</code>
                            value to the <code class="literal">autoAck</code>
                            form parameter.
                        </p><pre xmlns="" class="">
POST /topics/jms.topic.foo/pull-subscriptions HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded

durable=true&amp;autoAck=false

--- Response ---
HTTP/1.1 201 Created
Location: http://example.com/topics/jms.topic.foo/pull-subscriptions/acknowledged/222
msg-acknowledge-next:
http://example.com/topics/jms.topic.foo/pull-subscriptions/acknowledged/222/consume-next-1</pre><p>The
                            <code class="literal">Location</code> header points to the JMS
                            subscription resource that was created on the server. It is good
                            to remember this URL, although, as you'll see later, it is
                            transmitted with each response just to remind you.
                        </p></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e13127"/>43.5.2.2. Consuming and Acknowledging a Message</h4></div></div></div><p>After you have created a consumer resource, you are ready to
                    start pulling messages from the server. Notice that when you created
                    the consumer for either the queue or topic, the response contained a
                    <code class="literal">msg-acknowledge-next</code> response header. POST to the
                    URL contained within this header to consume the next message in the
                    queue or topic subscription. If there are no messages in the queue or
                    topic subscription, a 503 (Service Unavailable) HTTP code is returned.
                    A successful POST causes the server to extract a message from the
                    queue or topic subscription and return it to the consuming client. It
                    does not acknowledge the message though. The response will contain the
                    <code class="literal">acknowledgement</code>
                    header which you will use to
                    acknowledge the message.
                </p><p>Here's an example of pulling multiple messages from the consumer
                    resource.
                </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>Do a POST on the msg-acknowledge-next URL that was returned
                            with the consumer or subscription resource discussed
                            earlier.
                        </p><pre xmlns="" class="">
POST /queues/jms.queue.bar/pull-consumers/consume-next-1
Host: example.com

--- Response ---
HTTP/1.1 200 Ok
Content-Type: application/xml
msg-acknowledgement:
http://example.com/queues/jms.queue.bar/pull-consumers/333/acknowledgement/2
msg-consumer: http://example.com/queues/jms.queue.bar/pull-consumers/333

&lt;order&gt;...&lt;/order&gt;</pre><p>The POST returns the message consumed from the queue. It
                            also returns a<code class="literal">msg-acknowledgemen</code>t link. You
                            will use this new link to acknowledge the message. Notice also a
                            <code class="literal">msg-consumer</code> response header is returned. This
                            is a URL that points back to the consumer or subscription
                            resource. You will need that to clean up your connection after you
                            are finished using the queue or topic.
                        </p></li><li><p>Acknowledge or unacknowledge the message by doing a POST to
                            the URL contained in the <code class="literal">msg-acknowledgement</code>
                            header. You must pass an <code class="literal">acknowledge</code>
                            form parameter set to <code class="literal">true</code>
                            or <code class="literal">false</code> depending on whether you want to
                            acknowledge or unacknowledge the message on the server.
                        </p><pre xmlns="" class="">
POST /queues/jms.queue.bar/pull-consumers/acknowledgement/2
Host: example.com
Content-Type: application/x-www-form-urlencoded

acknowledge=true

--- Response ---
Http/1.1 200 Ok
msg-acknowledge-next:
http://example.com/queues/jms.queue.bar/pull-consumers/333/acknowledge-next-2</pre><p>Whether you acknowledge or unacknowledge the message, the
                            response will contain a new msg-acknowledge-next header that you
                            must use to obtain the next message.
                        </p></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e13173"/>43.5.2.3. Recovering From Network Failures</h4></div></div></div><p>If you experience a network failure and do not know if your post
                    to a
                    <code class="literal">msg-acknowledge-next</code>
                    or
                    <code class="literal">msg-acknowledgement</code> URL was successful or not, just
                    re-do your POST. A POST to one of these URLs is idempotent, meaning
                    that it will return the same result if you re-post. Behind the scenes,
                    the consumer resource keeps track of its current state. If the last
                    action was a call to<code class="literal">msg-acknowledge-next</code>, it will
                    have the last message cached, so that if a re-post is done, it will
                    return the message again. Same goes with re-posting to
                    <code class="literal">msg-acknowledgement</code>. The server remembers its last
                    state and will return the same results. If you look at the URLs you'll
                    see that they contain information about the expected current state of
                    the server. This is how the server knows what the client is
                    expecting.
                </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e13190"/>43.5.2.4. Recovering From Client or Server Crashes</h4></div></div></div><p>If the server crashes and while you are doing a POST to the
                    <code class="literal">msg-acknowledge-next</code> URL, just re-post. Everything
                    should reconnect all right. On the other hand, if the server crashes
                    while you are doing a POST to<code class="literal">msg-acknowledgement</code>,
                    the server will return a 412 (Preconditions Failed) response code.
                    This is telling you that the URL you are using is out of sync with the
                    server and the message you are acknowledging was probably re-enqueued.
                    The response will contain a new <code class="literal">msg-acknowledge-next</code>
                    header to invoke on.
                </p><p>As long as you have "bookmarked" the consumer resource URL
                    (returned from <code class="literal">Location</code> header on a create, or the
                    <code class="literal">msg-consumer</code> header), you can recover from client
                    crashes by doing a GET or HEAD request on the consumer resource to
                    obtain what state you are in. If the consumer resource is expecting
                    you to acknowledge a message, it will return a
                    <code class="literal">msg-acknowledgement</code> header in the response. If the
                    consumer resource is expecting you to pull for the next message, the
                    <code class="literal">msg-acknowledge-next</code> header will be in the
                    response. With manual acknowledgement you are pretty much guaranteed
                    to avoid skipped messages. For topic subscriptions that were created
                    with a name parameter, you do not have to "bookmark" the returned URL.
                    Instead, you can re-create the consumer resource with the same exact
                    name. The response will contain the same information as if you did a
                    GET or HEAD request on the consumer resource.
                </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13218"/>43.5.3. Blocking Pulls with Accept-Wait</h3></div></div></div><p>Unless your queue or topic has a high rate of message flowing
                though it, if you use the pull protocol, you're going to be receiving a
                lot of 503 responses as you continuously pull the server for new
                messages. To alleviate this problem, the HornetQ REST interface provides
                the <code class="literal">Accept-Wait</code> header. This is a generic HTTP
                request header that is a hint to the server for how long the client is
                willing to wait for a response from the server. The value of this header
                is the time in seconds the client is willing to block for. You would
                send this request header with your pull requests. Here's an
                example:
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
POST /queues/jms.queue.bar/pull-consumers/consume-next-2
Host: example.com
Accept-Wait: 30

--- Response ---
HTTP/1.1 200 Ok
Content-Type: application/xml
msg-consume-next: http://example.com/queues/jms.queue.bar/pull-consumers/333/consume-next-3

&lt;order&gt;...&lt;/order&gt;</pre><p>In this example, we're posting to a msg-consume-next URL and
                telling the server that we would be willing to block for 30
                seconds.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13230"/>43.5.4. Clean Up Your Consumers!</h3></div></div></div><p>When the client is done with its consumer or topic subscription it
                should do an HTTP DELETE call on the consumer URL passed back from the
                Location header or the msg-consumer response header. The server will
                time out a consumer with the value of
                <code class="literal">consumer-session-timeout-seconds</code> configured from
                <a class="link" href="#configuration" title="43.2.3. REST Configuration">REST configuration</a>, so you
                don't have to clean up if you don't want to, but if you are a good kid,
                you will clean up your messes. A consumer timeout for durable
                subscriptions will not delete the underlying durable JMS subscription
                though, only the server-side consumer resource (and underlying JMS
                session).
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="message-push"/>43.6. Pushing Messages</h2></div></div></div><p>You can configure the HornetQ REST server to push messages to a
            registered URL either remotely through the REST interface, or by creating
            a pre-configured XML file for the HornetQ REST server to load at boot
            time.
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13246"/>43.6.1. The Queue Push Subscription XML</h3></div></div></div><p>Creating a push consumer for a queue first involves creating a
                very simple XML document. This document tells the server if the push
                subscription should survive server reboots (is it durable). It must
                provide a URL to ship the forwarded message to. Finally, you have to
                provide authentication information if the final endpoint requires
                authentication. Here's a simple example:
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;push-registration&gt;
   &lt;durable&gt;false&lt;/durable&gt;
   &lt;selector&gt;&lt;![CDATA[
   SomeAttribute &gt; 1
   ]]&gt;
   &lt;/selector&gt;
   &lt;link rel="push" href="http://somewhere.com" type="application/json" method="PUT"/&gt;
   &lt;maxRetries&gt;5&lt;/maxRetries&gt;
   &lt;retryWaitMillis&gt;1000&lt;/retryWaitMillis&gt;
   &lt;disableOnFailure&gt;true&lt;/disableOnFailure&gt;
&lt;/push-registration&gt;</pre><p>The <code class="literal">durable</code> element specifies whether the
                registration should be saved to disk so that if there is a server
                restart, the push subscription will still work. This element is not
                required. If left out it defaults to<code class="literal">false</code>. If
                durable is set to true, an XML file for the push subscription will be
                created within the directory specified by the
                <code class="literal">queue-push-store-dir</code> config variable defined in
                Chapter 2 (<code class="literal">topic-push-store-dir</code> for topics).
            </p><p>The <code class="literal">selector</code> element is optional and defines a
                JMS message selector. You should enclose it within CDATA blocks as some
                of the selector characters are illegal XML.
            </p><p>The <code class="literal">maxRetries</code> element specifies how many times
                a the server will try to push a message to a URL if there is a
                connection failure.
            </p><p>The <code class="literal">retryWaitMillis</code> element specifies how long
                to wait before performing a retry.
            </p><p>The
                <code class="literal">disableOnFailure</code> element, if set to true,
                will disable the registration if all retries have failed. It will not
                disable the connection on non-connection-failure issues (like a bad
                request for instance). In these cases, the dead letter queue logic of
                HornetQ will take over.
            </p><p>The <code class="literal">link</code> element specifies the basis of the
                interaction. The <code class="literal">href</code> attribute contains the URL you
                want to interact with. It is the only required attribute. The
                <code class="literal">type</code> attribute specifies the content-type of what the
                push URL is expecting. The <code class="literal">method</code> attribute defines
                what HTTP method the server will use when it sends the message to the
                server. If it is not provided it defaults to POST. The
                <code class="literal">rel</code> attribute is very important and the value of it
                triggers different behavior. Here's the values a rel attribute can
                have:
            </p><div class="itemizedlist"><ul><li><p><code class="literal">destination</code>. The href URL is assumed to be a queue or topic resource of
                        another HornetQ REST server. The push registration will initially
                        do a HEAD request to this URL to obtain a msg-create-with-id
                        header. It will use this header to push new messages to the
                        HornetQ REST endpoint reliably. Here's an example:
                    </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;push-registration&gt;
   &lt;link rel="destination" href="http://somewhere.com/queues/jms.queue.foo"/&gt;
&lt;/push-registration&gt;</pre></li><li><p><code class="literal">template</code>. In this case, the server is expecting the link element's
                        href attribute to be a URL expression. The URL expression must
                        have one and only one URL parameter within it. The server will use
                        a unique value to create the endpoint URL. Here's an
                        example:
                    </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;push-registration&gt;
   &lt;link rel="template" href="http://somewhere.com/resources/{id}/messages" method="PUT"/&gt;
&lt;/push-registration&gt;</pre><p>In this example, the {id} sub-string is the one and only one
                        URL parameter.
                    </p></li><li><p><code class="literal">user defined</code>. If the rel attributes is not destination or template (or is
                        empty or missing), then the server will send an HTTP message to
                        the href URL using the HTTP method defined in the method
                        attribute. Here's an example:
                    </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;push-registration&gt;
   &lt;link href="http://somewhere.com" type="application/json" method="PUT"/&gt;
&lt;/push-registration&gt;</pre></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13328"/>43.6.2. The Topic Push Subscription XML</h3></div></div></div><p>The push XML for a topic is the same except the root element is
                push-topic-registration. (Also remember the <code class="literal">selector</code>
                element is optional). The rest of the document is the same. Here's an
                example of a template registration:
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;push-topic-registration&gt;
   &lt;durable&gt;true&lt;/durable&gt;
   &lt;selector&gt;&lt;![CDATA[
   SomeAttribute &gt; 1
   ]]&gt;
   &lt;/selector&gt;
   &lt;link rel="template" href="http://somewhere.com/resources/{id}/messages" method="POST"/&gt;
&lt;/push-topic registration&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13338"/>43.6.3. Creating a Push Subscription at Runtime</h3></div></div></div><p>Creating a push subscription at runtime involves getting the
                factory resource URL from the msg-push-consumers header, if the
                destination is a queue, or msg-push-subscriptions header, if the
                destination is a topic. Here's an example of creating a push
                registration for a queue:
            </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>First do a HEAD request to the queue resource:</p><pre xmlns="" class="">
HEAD /queues/jms.queue.bar HTTP/1.1
Host: example.com

--- Response ---
HTTP/1.1 200 Ok
msg-create: http://example.com/queues/jms.queue.bar/create
msg-pull-consumers: http://example.com/queues/jms.queue.bar/pull-consumers
msg-push-consumers: http://example.com/queues/jms.queue.bar/push-consumers</pre></li><li><p>Next POST your subscription XML to the URL returned from
                        msg-push-consumers header
                    </p><pre xmlns="" class="">
POST /queues/jms.queue.bar/push-consumers
Host: example.com
Content-Type: application/xml

&lt;push-registration&gt;
   &lt;link rel="destination" href="http://somewhere.com/queues/jms.queue.foo"/&gt;
&lt;/push-registration&gt;

--- Response ---
HTTP/1.1 201 Created
Location: http://example.com/queues/jms.queue.bar/push-consumers/1-333-1212</pre><p>The Location header contains the URL for the created resource.
                        If you want to unregister this, then do a HTTP DELETE on this
                        URL.
                    </p></li></ol></div><p>Here's an example of creating a push registration for a
                topic:
            </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>First do a HEAD request to the topic resource:</p><pre xmlns="" class="">
HEAD /topics/jms.topic.bar HTTP/1.1
Host: example.com

--- Response ---
HTTP/1.1 200 Ok
msg-create: http://example.com/topics/jms.topic.bar/create
msg-pull-subscriptions: http://example.com/topics/jms.topic.bar/pull-subscriptions
msg-push-subscriptions: http://example.com/topics/jms.topic.bar/push-subscriptions</pre></li><li><p>Next POST your subscription XML to the URL returned from
                        msg-push-subscriptions header
                    </p><pre xmlns="" class="">
POST /topics/jms.topic.bar/push-subscriptions
Host: example.com
Content-Type: application/xml

&lt;push-registration&gt;
   &lt;link rel="template" href="http://somewhere.com/resources/{id}"/&gt;
&lt;/push-registration&gt;

--- Response ---
HTTP/1.1 201 Created
Location: http://example.com/topics/jms.topic.bar/push-subscriptions/1-333-1212</pre><p>The Location header contains the URL for the created resource.
                        If you want to unregister this, then do a HTTP DELETE on this
                        URL.
                    </p></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13371"/>43.6.4. Creating a Push Subscription by Hand</h3></div></div></div><p>You can create a push XML file yourself if you do not want to go
                through the REST interface to create a push subscription. There is some
                additional information you need to provide though. First, in the root
                element, you must define a unique id attribute. You must also define a
                destination element to specify the queue you should register a consumer
                with. For a topic, the destination element is the name of the
                subscription that will be created. For a topic, you must also specify the
                topic name within the topic element.
            </p><p>Here's an example of a hand-created queue registration. This file
                must go in the directory specified by the queue-push-store-dir config
                variable defined in Chapter 2:
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;push-registration id="111"&gt;
   &lt;destination&gt;jms.queue.bar&lt;/destination&gt;
   &lt;durable&gt;true&lt;/durable&gt;
   &lt;link rel="template" href="http://somewhere.com/resources/{id}/messages" method="PUT"/&gt;
&lt;/push-registration&gt;</pre><p>Here's an example of a hand-created topic registration. This file
                must go in the directory specified by the topic-push-store-dir config
                variable defined in Chapter 2:
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;push-topic-registration id="112"&gt;
   &lt;destination&gt;my-subscription-1&lt;/destination
   &lt;durable&gt;true&lt;/durable&gt;
   &lt;link rel="template" href="http://somewhere.com/resources/{id}/messages" method="PUT"/&gt;
   &lt;topic&gt;jms.topic.foo&lt;/topic&gt;
&lt;/push-topic-registration&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13384"/>43.6.5. Pushing to Authenticated Servers</h3></div></div></div><p>Push subscriptions only support BASIC and DIGEST authentication
                out of the box. Here is an example of adding BASIC
                authentication:
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;push-topic-registration&gt;
   &lt;durable&gt;true&lt;/durable&gt;
   &lt;link rel="template" href="http://somewhere.com/resources/{id}/messages" method="POST"/&gt;
   &lt;authentication&gt;
      &lt;basic-auth&gt;
         &lt;username&gt;guest&lt;/username&gt;
         &lt;password&gt;geheim&lt;/password&gt;
      &lt;/basic-auth&gt;
   &lt;/authentication&gt;
&lt;/push-topic registration&gt;</pre><p>For DIGEST, just replace basic-auth with digest-auth.</p><p>For other authentication mechanisms, you can register headers you
                want transmitted with each request. Use the header element with the name
                attribute representing the name of the header. Here's what custom
                headers might look like:
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;push-topic-registration&gt;
   &lt;durable&gt;true&lt;/durable&gt;
   &lt;link rel="template" href="http://somewhere.com/resources/{id}/messages" method="POST"/&gt;
   &lt;header name="secret-header"&gt;jfdiwe3321&lt;/header&gt;
&lt;/push-topic registration&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e13397"/>43.7. Creating Destinations</h2></div></div></div><p>You can create a durable queue or topic through the REST interface.
            Currently you cannot create a temporary queue or topic. To create a queue
            you do a POST to the relative URL /queues with an XML representation of
            the queue. The XML syntax is the same queue syntax that you would specify
            in hornetq-jms.xml if you were creating a queue there. For example:
        </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
POST /queues
Host: example.com
Content-Type: application/hornetq.jms.queue+xml

&lt;queue name="testQueue"&gt;
   &lt;durable&gt;true&lt;/durable&gt;
&lt;/queue&gt;

--- Response ---
HTTP/1.1 201 Created
Location: http://example.com/queues/jms.queue.testQueue</pre><p>Notice that the Content-Type is application/hornetq.jms.queue+xml.</p><p>Here's what creating a topic would look like:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
POST /topics
Host: example.com
Content-Type: application/hornetq.jms.topic+xml

&lt;topic name="testTopic"&gt;
&lt;/topic&gt;

--- Response ---
HTTP/1.1 201 Created
Location: http://example.com/topics/jms.topic.testTopic</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e13410"/>43.8. Securing the HornetQ REST Interface</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13413"/>43.8.1. Within JBoss Application server</h3></div></div></div><p>Securing the HornetQ REST interface is very simple with the JBoss
                Application Server. You turn on authentication for all URLs within your
                WAR's web.xml, and let the user Principal to propagate to HornetQ. This
                only works if you are using the JBossSecurityManager with HornetQ. See
                the HornetQ documentation for more details.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13418"/>43.8.2. Security in other environments</h3></div></div></div><p>To secure the HornetQ REST interface in other environments you
                must role your own security by specifying security constraints with your
                web.xml for every path of every queue and topic you have deployed. Here
                is a list of URI patterns:
            </p><div class="table"><a id="d0e13423"/><p class="title"><b>Table 43.1. </b></p><div class="table-contents"><table border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>/queues</td><td>secure the POST operation to secure queue creation</td></tr><tr><td>/queues/{queue-name}</td><td>secure the GET HEAD operation to getting information about the queue.</td></tr><tr><td>/queues/{queue-name}/create/*</td><td>secure this URL pattern for producing messages.</td></tr><tr><td>/queues/{queue-name}/pull-consumers/*</td><td>secure this URL pattern for pulling messages.</td></tr><tr><td>/queues/{queue-name}/push-consumers/*</td><td>secure this URL pattern for pushing messages.</td></tr><tr><td>/topics</td><td>secure the POST operation to secure topic creation</td></tr><tr><td>/topics/{topic-name}</td><td>secure the GET HEAD operation to getting information about the topic.</td></tr><tr><td>/topics/{topic-name}/create/*</td><td>secure this URL pattern for producing messages.</td></tr><tr><td>/topics/{topic-name}/pull-subscriptions/*</td><td>secure this URL pattern for pulling messages.</td></tr><tr><td>/topics/{topic-name}/push-subscriptions/*</td><td>secure this URL pattern for pushing messages.</td></tr></tbody></table></div></div><br class="table-break"/></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e13476"/>43.9. Mixing JMS and REST</h2></div></div></div><p>The HornetQ REST interface supports mixing JMS and REST producers
            and consumers. You can send an ObjectMessage through a JMS Producer, and
            have a REST client consume it. You can have a REST client POST a message
            to a topic and have a JMS Consumer receive it. Some simple transformations
            are supported if you have the correct RESTEasy providers installed.
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13481"/>43.9.1. JMS Producers - REST Consumers</h3></div></div></div><p>If you have a JMS producer, the HornetQ REST interface only
                supports ObjectMessage type. If the JMS producer is aware that there may
                be REST consumers, it should set a JMS property to specify what
                Content-Type the Java object should be translated into by REST clients.
                The HornetQ REST server will use RESTEasy content handlers
                (MessageBodyReader/Writers) to transform the Java object to the type
                desired. Here's an example of a JMS producer setting the content type of
                the message.
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
ObjectMessage message = session.createObjectMessage();
message.setStringProperty(org.hornetq.rest.HttpHeaderProperty.CONTENT_TYPE, "application/xml");</pre><p>If the JMS producer does not set the content-type, then this
                information must be obtained from the REST consumer. If it is a pull
                consumer, then the REST client should send an Accept header with the
                desired media types it wants to convert the Java object into. If the
                REST client is a push registration, then the type attribute of the link
                element of the push registration should be set to the desired
                type.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13490"/>43.9.2. REST Producers - JMS Consumers</h3></div></div></div><p>If you have a REST client producing messages and a JMS consumer,
                HornetQ REST has a simple helper class for you to transform the HTTP
                body to a Java object. Here's some example code:
            </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
public void onMessage(Message message)
{
   MyType obj = org.hornetq.rest.Jms.getEntity(message, MyType.class);
}</pre><p>The way the <code class="literal">getEntity()</code> method works is that if
                the message is an ObjectMessage, it will try to extract the desired type
                from it like any other JMS message. If a REST producer sent the message,
                then the method uses RESTEasy to convert the HTTP body to the Java
                object you want. See the Javadoc of this class for more helper
                methods.
            </p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="embedding-hornetq"/>Chapter 44. Embedding HornetQ</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e13535">44.1. Simple Config File Embedding</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e13540">44.1.1. Core API Only</a></span></dt><dt><span class="section"><a href="#simple.embedded.jms">44.1.2. JMS API</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e13588">44.2. POJO instantiation - Embedding Programmatically</a></span></dt><dt><span class="section"><a href="#d0e13629">44.3. Dependency Frameworks</a></span></dt></dl></div><p>HornetQ is designed as set of simple Plain Old Java Objects (POJOs).
  This means HornetQ can be instantiated and run in any dependency injection
  framework such as JBoss Microcontainer, Spring or Google Guice. It also
  means that if you have an application that could use messaging functionality
  internally, then it can <span class="emphasis"><em>directly instantiate</em></span> HornetQ
  clients and servers in its own application code to perform that
  functionality. We call this <span class="emphasis"><em>embedding</em></span> HornetQ.</p><p>Examples of applications that might want to do this include any
  application that needs very high performance, transactional, persistent
  messaging but doesn't want the hassle of writing it all from scratch.</p><p>Embedding HornetQ can be done in very few easy steps. Instantiate the
  configuration object, instantiate the server, start it, and you have a
  HornetQ running in your virtual machine. It's as simple and easy as
  that.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e13535"/>44.1. Simple Config File Embedding</h2></div></div></div><p>The simplest way to embed HornetQ is to use the embedded wrapper
    classes and configure HornetQ through its configuration files. There are
    two different helper classes for this depending on whether your using the
    HornetQ Core API or JMS.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e13540"/>44.1.1. Core API Only</h3></div></div></div><p>For instantiating a core HornetQ Server only, the steps are pretty
      simple. The example requires that you have defined a configuration file
      <code class="literal">hornetq-configuration.xml</code> in your
      classpath:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
import org.hornetq.core.server.embedded.EmbeddedHornetQ;

...

EmbeddedHornetQ embedded = new EmbeddedHornetQ();
embedded.start();

ClientSessionFactory nettyFactory =  HornetQClient.createClientSessionFactory(
                                        new TransportConfiguration(
                                           InVMConnectorFactory.class.getName()));

ClientSession session = factory.createSession();

session.createQueue("example", "example", true);

ClientProducer producer = session.createProducer("example");

ClientMessage message = session.createMessage(true);

message.getBody().writeString("Hello");

producer.send(message);

session.start();

ClientConsumer consumer = session.createConsumer("example");

ClientMessage msgReceived = consumer.receive();

System.out.println("message = " + msgReceived.getBody().readString());

session.close();</pre><p>The <code class="literal">EmbeddedHornetQ</code> class has a
      few additional setter methods that allow you to specify a different
      config file name as well as other properties. See the javadocs for this
      class for more details.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="simple.embedded.jms"/>44.1.2. JMS API</h3></div></div></div><p>JMS embedding is simple as well. This example requires that you
      have defined the config files
      <code class="literal">hornetq-configuration.xml</code>,
      <code class="literal">hornetq-jms.xml</code>, and a
      <code class="literal">hornetq-users.xml</code> if you have security enabled. Let's
      also assume that a queue and connection factory has been defined in the
      <code class="literal">hornetq-jms.xml</code> config file.</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
import org.hornetq.jms.server.embedded.EmbeddedJMS;

...

EmbeddedJMS jms = new EmbeddedJMS();
jms.start();

// This assumes we have configured hornetq-jms.xml with the appropriate config information
ConnectionFactory connectionFactory = jms.lookup("ConnectionFactory");
Destination destination = jms.lookup("/example/queue");

... regular JMS code ...</pre><p>By default, the <code class="literal">EmbeddedJMS</code>
      class will store component entries defined within your
      <code class="literal">hornetq-jms.xml</code> file in an internal concurrent hash
      map. The <code class="literal">EmbeddedJMS.lookup()</code> method returns
      components stored in this map. If you want to use JNDI, call the
      <code class="literal">EmbeddedJMS.setContext()</code> method with the root JNDI
      context you want your components bound into. See the javadocs for this
      class for more details on other config options.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e13588"/>44.2. POJO instantiation - Embedding Programmatically</h2></div></div></div><p>You can follow this step-by-step guide to programmatically embed the
    core, non-JMS HornetQ Server instance:</p><p>Create the configuration object - this contains configuration
    information for a HornetQ instance. The setter methods of this class allow
    you to programmatically set configuration options as describe in the <a class="xref" href="#server.configuration" title="50.1. Server Configuration">Section 50.1, “Server Configuration”</a> section.</p><p>The acceptors are configured through
    <code class="literal">ConfigurationImpl</code>. Just add the
    <code class="literal">NettyAcceptorFactory</code> on the transports the same way you
    would through the main configuration file.</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
import org.hornetq.core.config.Configuration;
import org.hornetq.core.config.impl.ConfigurationImpl;

...

Configuration config = new ConfigurationImpl();
HashSet&lt;TransportConfiguration&gt; transports = new HashSet&lt;TransportConfiguration&gt;();
      
transports.add(new TransportConfiguration(NettyAcceptorFactory.class.getName()));
transports.add(new TransportConfiguration(InVMAcceptorFactory.class.getName()));

config.setAcceptorConfigurations(transports);</pre><p>You need to instantiate an instance of
    <code class="literal">org.hornetq.api.core.server.embedded.EmbeddedHornetQ</code>
    and add the configuration object to it.</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
import org.hornetq.api.core.server.HornetQ;
import org.hornetq.core.server.embedded.EmbeddedHornetQ;

...

EmbeddedHornetQ server = new EmbeddedHornetQ();
server.setConfiguration(config);

server.start();</pre><p>You also have the option of instantiating
    <code class="literal">HornetQServerImpl</code> directly:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
HornetQServer server = new HornetQServerImpl(config);
server.start();</pre><p>For JMS POJO instantiation, you work with the EmbeddedJMS class
    instead as described earlier. First you define the configuration
    programmatically for your ConnectionFactory and Destination objects, then
    set the JmsConfiguration property of the EmbeddedJMS class. Here is an
    example of this:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
// Step 1. Create HornetQ core configuration, and set the properties accordingly
Configuration configuration = new ConfigurationImpl();
configuration.setPersistenceEnabled(false);
configuration.setSecurityEnabled(false);
configuration.getAcceptorConfigurations().add(new TransportConfiguration(NettyAcceptorFactory.class.getName()));

// Step 2. Create the JMS configuration
JMSConfiguration jmsConfig = new JMSConfigurationImpl();

// Step 3. Configure the JMS ConnectionFactory
TransportConfiguration connectorConfig = new TransportConfiguration(NettyConnectorFactory.class.getName());
ConnectionFactoryConfiguration cfConfig = new ConnectionFactoryConfigurationImpl("cf", connectorConfig, "/cf");
jmsConfig.getConnectionFactoryConfigurations().add(cfConfig);

// Step 4. Configure the JMS Queue
JMSQueueConfiguration queueConfig = new JMSQueueConfigurationImpl("queue1", null, false, "/queue/queue1");
jmsConfig.getQueueConfigurations().add(queueConfig);

// Step 5. Start the JMS Server using the HornetQ core server and the JMS configuration
EmbeddedJMS jmsServer = new EmbeddedJMS();
jmsServer.setConfiguration(configuration);
jmsServer.setJmsConfiguration(jmsConfig);
jmsServer.start();</pre><p>Please see <a class="xref" href="#examples.embedded.jms" title="11.1.22. Embedded">Section 11.1.22, “Embedded”</a> for an example which
    shows how to setup and run HornetQ embedded with JMS.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e13629"/>44.3. Dependency Frameworks</h2></div></div></div><p>You may also choose to use a dependency injection framework such as
    <span class="trademark">JBoss Micro Container</span>™ or <span class="trademark">Spring
    Framework</span>™. See <a class="xref" href="#spring.integration" title="Chapter 45. Spring Integration">Chapter 45, <i>Spring Integration</i></a> for more
    details on Spring and HornetQ, but here's how you would do things with the
    JBoss Micro Container.</p><p>HornetQ standalone uses JBoss Micro Container as the injection
    framework. <code class="literal">HornetQBootstrapServer</code> and
    <code class="literal">hornetq-beans.xml</code> which are part of the HornetQ
    distribution provide a very complete implementation of what's needed to
    bootstrap the server using JBoss Micro Container.</p><p>When using JBoss Micro Container, you need to provide an XML file
    declaring the <code class="literal">HornetQServer</code> and
    <code class="literal">Configuration</code> object, you can also inject a security
    manager and a MBean server if you want, but those are optional.</p><p>A very basic XML Bean declaration for the JBoss Micro Container
    would be:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;deployment xmlns="urn:jboss:bean-deployer:2.0"&gt;
   &lt;!-- The core configuration --&gt;
   &lt;bean name="Configuration" 
         class="org.hornetq.core.config.impl.FileConfiguration"&gt;
   &lt;/bean&gt;

     &lt;!-- The core server --&gt;
   &lt;bean name="HornetQServer" 
         class="org.hornetq.core.server.impl.HornetQServerImpl"&gt;
      &lt;constructor&gt;
         &lt;parameter&gt;
            &lt;inject bean="Configuration"/&gt;
         &lt;/parameter&gt;
      &lt;/constructor&gt;
   &lt;/bean&gt;
&lt;/deployment&gt;</pre><p><code class="literal">HornetQBootstrapServer</code> provides an easy
    encapsulation of JBoss Micro Container.</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
HornetQBootstrapServer bootStrap = new HornetQBootstrapServer(new String[] {"hornetq-beans.xml"});
bootStrap.run();</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="spring.integration"/>Chapter 45. Spring Integration</h2></div></div></div><p>HornetQ provides a simple bootstrap class,
  <code class="literal">org.hornetq.integration.spring.SpringJmsBootstrap</code>, for
  integration with Spring. To use it, you configure HornetQ as you always
  would, through its various configuration files like
  <code class="literal">hornetq-configuration.xml</code>,
  <code class="literal">hornetq-jms.xml</code>, and
  <code class="literal">hornetq-users.xml</code>. The Spring helper class starts the
  HornetQ server and adds any factories or destinations configured within
  <code class="literal">hornetq-jms.xml</code> directly into the namespace of the Spring
  context. Let's take this <code class="literal">hornetq-jms.xml</code> file for
  instance: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;configuration xmlns="urn:hornetq"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="urn:hornetq /schema/hornetq-jms.xsd"&gt;
   &lt;!--the connection factory used by the example--&gt;
   &lt;connection-factory name="ConnectionFactory"&gt;
      &lt;connectors&gt;
         &lt;connector-ref connector-name="in-vm"/&gt;
      &lt;/connectors&gt;
      &lt;entries&gt;
         &lt;entry name="ConnectionFactory"/&gt;
      &lt;/entries&gt;
   &lt;/connection-factory&gt;

   &lt;!--the queue used by the example--&gt;
   &lt;queue name="exampleQueue"&gt;
      &lt;entry name="/queue/exampleQueue"/&gt;
   &lt;/queue&gt;
&lt;/configuration&gt;</pre><p>Here we've specified a
  <code class="literal">javax.jms.ConnectionFactory</code> we want bound to a
  <code class="literal">ConnectionFactory</code> entry as well as a queue destination
  bound to a <code class="literal">/queue/exampleQueue</code> entry. Using the
  <code class="literal">SpringJmsBootStrap</code> bean will automatically populate the
  Spring context with references to those beans so that you can use them.
  Below is an example Spring JMS bean file taking advantage of this
  feature:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;

   &lt;bean id="EmbeddedJms" class="org.hornetq.integration.spring.SpringJmsBootstrap" init-method="start"/&gt;

   &lt;bean id="listener" class="org.hornetq.tests.integration.spring.ExampleListener"/&gt;
    
   &lt;bean id="listenerContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;
      &lt;property name="connectionFactory" ref="ConnectionFactory"/&gt;
      &lt;property name="destination" ref="/queue/exampleQueue"/&gt;
      &lt;property name="messageListener" ref="listener"/&gt;
   &lt;/bean&gt;
&lt;/beans&gt;</pre><p>As you can see, the
  <code class="literal">listenerContainer</code> bean references the components defined
  in the <code class="literal">hornetq-jms.xml</code> file. The
  <code class="literal">SpringJmsBootstrap</code> class extends the EmbeddedJMS class
  talked about in <a class="xref" href="#simple.embedded.jms" title="44.1.2. JMS API">Section 44.1.2, “JMS API”</a> and the same defaults and
  configuration options apply. Also notice that an
  <code class="literal">init-method</code> must be declared with a start value so that
  the bean's lifecycle is executed. See the javadocs for more details on other
  properties of the bean class.</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="aerogear-integration"/>Chapter 46. AeroGear Integration</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e13765">46.1. Configuring an AeroGear Connector Service</a></span></dt><dt><span class="section"><a href="#d0e13847">46.2. How to send a message for AeroGear</a></span></dt></dl></div><p>AeroGears push technology provides support for different push notification technologies like Google Cloud Messaging,
        Apple's APNs or Mozilla's SimplePush. HornetQ allows you to configure a Connector Service that will consume messages
    from a queue and forward them to an AeroGear push server and subsequently sent as notifications to mobile devices.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e13765"/>46.1. Configuring an AeroGear Connector Service</h2></div></div></div><p>AeroGear Connector services are configured in the connector-services configuration:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
    &lt;connector-service name="aerogear-connector"&gt;
    &lt;factory-class&gt;org.hornetq.integration.aerogear.AeroGearConnectorServiceFactory&lt;/factory-class&gt;
    &lt;param key="endpoint" value="endpoint"/&gt;
    &lt;param key="queue" value="jms.queue.aerogearQueue"/&gt;
    &lt;param key="application-id" value="an applicationid"/&gt;
    &lt;param key="master-secret" value="a mastersecret"/&gt;
    &lt;/connector-service&gt;
    &lt;address-setting match="jms.queue.lastValueQueue"&gt;
    &lt;last-value-queue&gt;true&lt;/last-value-queue&gt;
    &lt;/address-setting&gt;
    </pre><p>Shown are the required params for the connector service and are:</p><div class="itemizedlist"><ul><li><p><code class="literal">endpoint</code>. The endpoint or URL of you AeroGear application.</p></li><li><p><code class="literal">queue</code>. The name of the queue to consume from.</p></li><li><p><code class="literal">application-id</code>. The application id of your mobile application in AeroGear.</p></li><li><p><code class="literal">master-secret</code>. The secret of your mobile application in AeroGear.</p></li></ul></div><p>As well as these required paramaters there are the following optional parameters</p><div class="itemizedlist"><ul><li><p><code class="literal">ttl</code>. The time to live for the message once AeroGear receives it.</p></li><li><p><code class="literal">badge</code>. The badge the mobile app should use for the notification.</p></li><li><p><code class="literal">sound</code>. The sound the mobile app should use for the notification.</p></li><li><p><code class="literal">filter</code>. A message filter(selector) to use on the connector.</p></li><li><p><code class="literal">retry-interval</code>. If an error occurs on send, how long before we try again to connect.</p></li><li><p><code class="literal">retry-attempts</code>. How many times we should try to reconnect after an error.</p></li><li><p><code class="literal">variants</code>. A comma separated list of variants that should get the message.</p></li><li><p><code class="literal">aliases</code>. A list of aliases that should get the message.</p></li><li><p><code class="literal">device-types</code>. A list of device types that should get the messag.</p></li></ul></div><p>More in depth explanations of the AeroGear related parameters can be found in the <a class="ulink" href="http://aerogear.org/push/">AeroGear Push docs</a></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e13847"/>46.2. How to send a message for AeroGear</h2></div></div></div><p>To send a message intended for AeroGear simply send a JMS Message and set the appropriate headers, like so</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
    Message message = session.createMessage();

    message.setStringProperty("AEROGEAR_ALERT", "Hello this is a notification from HornetQ");

    producer.send(message);
        </pre><p>The 'AEROGEAR_ALERT' property will be the alert sent to the mobile device.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>If the message does not contain this property then it will be simply ignored and left on the queue</p></div><p>Its also possible to override any of the other AeroGear parameters by simply setting them on the message,
        for instance if you wanted to set ttl of a message you would:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
    message.setIntProperty("AEROGEAR_TTL", 1234);
        </pre><p>or if you wanted to set the list of variants you would use:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
    message.setStringProperty("AEROGEAR_VARIANTS", "variant1,variant2,variant3");
        </pre><p>Again refer to the AeroGear documentation for a more in depth view on how to use these settings</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="intercepting-operations"/>Chapter 47. Intercepting Operations</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e13894">47.1. Implementing The Interceptors</a></span></dt><dt><span class="section"><a href="#d0e13919">47.2. Configuring The Interceptors</a></span></dt><dt><span class="section"><a href="#d0e13933">47.3. Interceptors on the Client Side</a></span></dt><dt><span class="section"><a href="#d0e13984">47.4. Example</a></span></dt></dl></div><p>HornetQ supports <span class="emphasis"><em>interceptors</em></span> to intercept packets entering
       and exiting the server. Incoming and outgoing interceptors are be called for any packet
       entering or exiting the server respectively. This allows custom code to be executed,
       e.g. for auditing packets, filtering or other reasons. Interceptors can change the
       packets they intercept. This makes interceptors powerful, but also potentially
       dangerous.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e13894"/>47.1. Implementing The Interceptors</h2></div></div></div><p>An interceptor must implement the <code class="literal">Interceptor interface</code>:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
package org.hornetq.api.core.interceptor;

public interface Interceptor
{   
   boolean intercept(Packet packet, RemotingConnection connection) throws HornetQException;
}</pre><p>The returned boolean value is important:</p><div class="itemizedlist"><ul><li><p>if <code class="literal">true</code> is returned, the process continues normally</p></li><li><p>if <code class="literal">false</code> is returned, the process is aborted, no other interceptors
                will be called and the packet will not be processed further by the server.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e13919"/>47.2. Configuring The Interceptors</h2></div></div></div><p>Both incoming and outgoing interceptors are configured in
          <code class="literal">hornetq-configuration.xml</code>:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;remoting-incoming-interceptors&gt;
   &lt;class-name&gt;org.hornetq.jms.example.LoginInterceptor&lt;/class-name&gt;
   &lt;class-name&gt;org.hornetq.jms.example.AdditionalPropertyInterceptor&lt;/class-name&gt;
&lt;/remoting-incoming-interceptors&gt;</pre><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;remoting-outgoing-interceptors&gt;
   &lt;class-name&gt;org.hornetq.jms.example.LogoutInterceptor&lt;/class-name&gt;
   &lt;class-name&gt;org.hornetq.jms.example.AdditionalPropertyInterceptor&lt;/class-name&gt;
&lt;/remoting-outgoing-interceptors&gt;</pre><p>The interceptors classes (and their dependencies) must be added to the server classpath
         to be properly instantiated and called.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e13933"/>47.3. Interceptors on the Client Side</h2></div></div></div><p>The interceptors can also be run on the client side to intercept packets either sent by the
         client to the server or by the server to the client. This is done by adding the interceptor to
         the <code class="code">ServerLocator</code> with the <code class="code">addIncomingInterceptor(Interceptor)</code> or
         <code class="code">addOutgoingInterceptor(Interceptor)</code> methods.</p><p>As noted above, if an interceptor returns <code class="literal">false</code> then the sending of the
         packet is aborted which means that no other interceptors are be called and the packet is not
         be processed further by the client. Typically this process happens transparently to the client
         (i.e. it has no idea if a packet was aborted or not). However, in the case of an outgoing packet
         that is sent in a <code class="literal">blocking</code> fashion a <code class="literal">HornetQException</code> will
         be thrown to the caller. The exception is thrown because blocking sends provide reliability and
         it is considered an error for them not to succeed. <code class="literal">Blocking</code> sends occurs when,
         for example, an application invokes <code class="literal">setBlockOnNonDurableSend(true)</code> or
         <code class="literal">setBlockOnDurableSend(true)</code> on its <code class="literal">ServerLocator</code> or if an
         application is using a JMS connection factory retrieved from JNDI that has either
         <code class="literal">block-on-durable-send</code> or <code class="literal">block-on-non-durable-send</code>
         set to <code class="literal">true</code>. Blocking is also used for packets dealing with transactions (e.g.
         commit, roll-back, etc.). The <code class="literal">HornetQException</code> thrown will contain the name
         of the interceptor that returned false.</p><p>As on the server, the client interceptor classes (and their dependencies) must be added to the classpath
         to be properly instantiated and invoked.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e13984"/>47.4. Example</h2></div></div></div><p>See <a class="xref" href="#examples.interceptor" title="11.1.28. Interceptor">Section 11.1.28, “Interceptor”</a> for an example which
         shows how to use interceptors to add properties to a message on the server.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="interoperability"/>Chapter 48. Interoperability</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#stomp">48.1. Stomp</a></span></dt><dd><dl><dt><span class="section"><a href="#stomp.native">48.1.1. Native Stomp support</a></span></dt><dt><span class="section"><a href="#d0e14067">48.1.2. Mapping Stomp destinations to HornetQ addresses and queues</a></span></dt><dt><span class="section"><a href="#d0e14092">48.1.3. STOMP and connection-ttl</a></span></dt><dt><span class="section"><a href="#d0e14112">48.1.4. Stomp and JMS interoperability</a></span></dt><dt><span class="section"><a href="#stomp.websockets">48.1.5. Stomp Over Web Sockets</a></span></dt><dt><span class="section"><a href="#stompconnect">48.1.6. StompConnect</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e14312">48.2. REST</a></span></dt><dt><span class="section"><a href="#d0e14318">48.3. AMQP</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e14332">48.3.1. AMQP and security</a></span></dt><dt><span class="section"><a href="#d0e14337">48.3.2. AMQP Links</a></span></dt><dt><span class="section"><a href="#d0e14342">48.3.3. AMQP and destinations</a></span></dt><dt><span class="section"><a href="#d0e14350">48.3.4. AMQP and Coordinations - Handling Transactions</a></span></dt></dl></dd></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="stomp"/>48.1. Stomp</h2></div></div></div><p><a class="ulink" href="http://stomp.github.com/">Stomp</a> is a text-orientated wire protocol that allows
            Stomp clients to communicate with Stomp Brokers. HornetQ now supports Stomp 1.0, 1.1 and 1.2.</p><p>Stomp clients are available for
        several languages and platforms making it a good choice for interoperability.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="stomp.native"/>48.1.1. Native Stomp support</h3></div></div></div><p>HornetQ provides native support for Stomp. To be able to send and receive Stomp messages,
            you must configure a <code class="literal">NettyAcceptor</code> with a <code class="literal">protocols</code>
            parameter set to have <code class="literal">stomp</code>:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;acceptor name="stomp-acceptor"&gt;
   &lt;factory-class&gt;org.hornetq.core.remoting.impl.netty.NettyAcceptorFactory&lt;/factory-class&gt;
   &lt;param key="protocols"  value="STOMP"/&gt;
   &lt;param key="port"  value="61613"/&gt;
&lt;/acceptor&gt;</pre><p>With this configuration, HornetQ will accept Stomp connections on 
            the port <code class="literal">61613</code> (which is the default port of the Stomp brokers).</p><p>See the <code class="literal">stomp</code> example which shows how to configure a HornetQ server with Stomp.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e14046"/>48.1.1.1. Limitations</h4></div></div></div><p>Message acknowledgements are not transactional. The ACK frame can not be part of a transaction
              (it will be ignored if its <code class="literal">transaction</code> header is set).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e14054"/>48.1.1.2. Stomp 1.1/1.2 Notes</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="d0e14057"/>48.1.1.2.1. Virtual Hosting</h5></div></div></div><p>HornetQ currently doesn't support virtual hosting, which means the 'host' header 
                in CONNECT fram will be ignored.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="d0e14062"/>48.1.1.2.2. Heart-beating</h5></div></div></div><p>HornetQ specifies a minimum value for both client and server heart-beat intervals. 
                The minimum interval for both client and server heartbeats is 500 milliseconds. That means if 
                a client sends a CONNECT frame with heartbeat values lower than 500, the server will defaults 
                the value to 500 milliseconds regardless the values of the 'heart-beat' header in the frame.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e14067"/>48.1.2. Mapping Stomp destinations to HornetQ addresses and queues</h3></div></div></div><p>Stomp clients deals with <span class="emphasis"><em>destinations</em></span> when sending messages and subscribing.
            Destination names are simply strings which are mapped to some form of destination on the 
            server - how the server translates these is left to the server implementation.</p><p>In HornetQ, these destinations are mapped to <span class="emphasis"><em>addresses</em></span> and <span class="emphasis"><em>queues</em></span>.
            When a Stomp client sends a message (using a <code class="literal">SEND</code> frame), the specified destination is mapped
            to an address.
            When a Stomp client subscribes (or unsubscribes) for a destination (using a <code class="literal">SUBSCRIBE</code>
            or <code class="literal">UNSUBSCRIBE</code> frame), the destination is mapped to a HornetQ queue.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e14092"/>48.1.3. STOMP and connection-ttl</h3></div></div></div><p>Well behaved STOMP clients will always send a DISCONNECT frame before closing their connections. In this case the server
          will clear up any server side resources such as sessions and consumers synchronously. However if STOMP clients exit without
        sending a DISCONNECT frame or if they crash the server will have no way of knowing immediately whether the client is still alive
        or not. STOMP connections therefore default to a connection-ttl value of 1 minute (see chapter on <a class="link" href="#connection-ttl" title="Chapter 17. Detecting Dead Connections">connection-ttl</a> for more information. This value can be overridden using connection-ttl-override.
        </p><p>If you need a specific connection-ttl for your stomp connections without affecting the connection-ttl-override setting, you
        can configure your stomp acceptor with the "connection-ttl" property, which is used to set the ttl for connections that are 
        created from that acceptor. For example:
        </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;acceptor name="stomp-acceptor"&gt;
   &lt;factory-class&gt;org.hornetq.core.remoting.impl.netty.NettyAcceptorFactory&lt;/factory-class&gt;
   &lt;param key="protocols"  value="STOMP"/&gt;
   &lt;param key="port"  value="61613"/&gt;
   &lt;param key="connection-ttl"  value="20000"/&gt;
&lt;/acceptor&gt;</pre><p>The above configuration will make sure that any stomp connection that is created from that acceptor will have its 
        connection-ttl set to 20 seconds.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Please note that the STOMP protocol version 1.0 does not contain any heartbeat frame. It is therefore the user's 
        responsibility to make sure data is sent within connection-ttl or the server will assume the client is dead and clean up server 
        side resources. With <code class="literal">Stomp 1.1</code> users can use heart-beats to maintain the life cycle of stomp 
        connections.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e14112"/>48.1.4. Stomp and JMS interoperability</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e14115"/>48.1.4.1. Using JMS destinations</h4></div></div></div><p>As explained in <a class="xref" href="#jms-core-mapping" title="Chapter 9. Mapping JMS Concepts to the Core API">Chapter 9, <i>Mapping JMS Concepts to the Core API</i></a>, JMS destinations are also mapped to HornetQ addresses and queues.
              If you want to use Stomp to send messages to JMS destinations, the Stomp destinations must follow the same convention:</p><div class="itemizedlist"><ul><li><p>send or subscribe to a JMS <span class="emphasis"><em>Queue</em></span> by prepending the queue name by <code class="literal">jms.queue.</code>.</p><p>For example, to send a message to the <code class="literal">orders</code> JMS Queue, the Stomp client must send the frame:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
SEND
destination:jms.queue.orders

hello queue orders
^@</pre></li><li><p>send or subscribe to a JMS <span class="emphasis"><em>Topic</em></span> by prepending the topic name by <code class="literal">jms.topic.</code>.</p><p>For example to subscribe to the <code class="literal">stocks</code> JMS Topic, the Stomp client must send the frame:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
SUBSCRIBE
destination:jms.topic.stocks

^@</pre></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e14155"/>48.1.4.2. Sending and consuming Stomp message from JMS or HornetQ Core API</h4></div></div></div><p>Stomp is mainly a text-orientated protocol. To make it simpler to interoperate with JMS and HornetQ Core API, 
               our Stomp implementation checks for presence of the <code class="literal">content-length</code> header to decide how to map a Stomp message
               to a JMS Message or a Core message.
             </p><p>If the Stomp message does <span class="emphasis"><em>not</em></span> have a <code class="literal">content-length</code> header, it will be mapped to a JMS <span class="emphasis"><em>TextMessage</em></span>
               or a Core message with a <span class="emphasis"><em>single nullable SimpleString in the body buffer</em></span>.</p><p>Alternatively, if the Stomp message <span class="emphasis"><em>has</em></span> a <code class="literal">content-length</code> header, 
               it will be mapped to a JMS <span class="emphasis"><em>BytesMessage</em></span>
               or a Core message with a <span class="emphasis"><em>byte[] in the body buffer</em></span>.</p><p>The same logic applies when mapping a JMS message or a Core message to Stomp. A Stomp client can check the presence
                of the <code class="literal">content-length</code> header to determine the type of the message body (String or bytes).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e14196"/>48.1.4.3. Message IDs for Stomp messages</h4></div></div></div><p>When receiving Stomp messages via a JMS consumer or a QueueBrowser, the messages have
            no properties like JMSMessageID by default. However this may bring some inconvenience to 
            clients who wants an ID for their purpose. HornetQ Stomp provides a parameter to enable
            message ID on each incoming Stomp message. If you want each Stomp message to have a unique ID,
            just set the <code class="literal">stomp-enable-message-id</code> to true. For example:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;acceptor name="stomp-acceptor"&gt;
   &lt;factory-class&gt;org.hornetq.core.remoting.impl.netty.NettyAcceptorFactory&lt;/factory-class&gt;
   &lt;param key="protocols" value="STOMP"/&gt;
   &lt;param key="port" value="61613"/&gt;
   &lt;param key="stomp-enable-message-id" value="true"/&gt;
&lt;/acceptor&gt;</pre><p>When the server starts with the above setting, each stomp message sent through this
            acceptor will have an extra property added. The property key is <code class="literal">
            hq-message-id</code> and the value is a String representation of a long type internal
            message id prefixed with "<code class="literal">STOMP</code>", like:
</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
hq-message-id : STOMP12345</pre><p>
            If <code class="literal">stomp-enable-message-id</code> is not specified in the configuration, default
            is <code class="literal">false</code>. </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e14223"/>48.1.4.4. Handling of Large Messages with Stomp</h4></div></div></div><p>Stomp clients may send very large bodys of frames which can exceed the size of HornetQ 
            server's internal buffer, causing unexpected errors. To prevent this situation from happening,
            HornetQ provides a stomp configuration attribute <code class="literal">stomp-min-large-message-size</code>. 
            This attribute can be configured inside a stomp acceptor, as a parameter. For example: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
   &lt;acceptor name="stomp-acceptor"&gt;
   &lt;factory-class&gt;org.hornetq.core.remoting.impl.netty.NettyAcceptorFactory&lt;/factory-class&gt;
   &lt;param key="protocols" value="STOMP"/&gt;
   &lt;param key="port" value="61613"/&gt;
   &lt;param key="stomp-min-large-message-size" value="10240"/&gt;
&lt;/acceptor&gt;</pre><p>The type of this attribute is integer. When this attributed is configured, HornetQ server 
            will check the size of the body of each Stomp frame arrived from connections established with 
            this acceptor. If the size of the body is equal or greater than the value of 
            <code class="literal">stomp-min-large-message</code>, the message will be persisted as a large message.
            When a large message is delievered to a stomp consumer, the HorentQ server will automatically 
            handle the conversion from a large message to a normal message, before sending it to the client.</p><p>If a large message is compressed, the server will uncompressed it before sending it to
            stomp clients. The default value of <code class="literal">stomp-min-large-message-size</code> is the same
            as the default value of <a class="link" href="#large-messages.core.config" title="23.2.1. Using Core API">min-large-message-size</a>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="stomp.websockets"/>48.1.5. Stomp Over Web Sockets</h3></div></div></div><p>HornetQ also support Stomp over <a class="ulink" href="http://dev.w3.org/html5/websockets/">Web Sockets</a>. Modern web browser which support Web Sockets can send and receive
            Stomp messages from HornetQ.</p><p>To enable Stomp over Web Sockets, you must configure a <code class="literal">NettyAcceptor</code> with a <code class="literal">protocol</code>
            parameter set to <code class="literal">stomp_ws</code>:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;acceptor name="stomp-ws-acceptor"&gt;
   &lt;factory-class&gt;org.hornetq.core.remoting.impl.netty.NettyAcceptorFactory&lt;/factory-class&gt;
   &lt;param key="protocols" value="STOMP_WS"/&gt;
   &lt;param key="port" value="61614"/&gt;
&lt;/acceptor&gt;</pre><p>With this configuration, HornetQ will accept Stomp connections over Web Sockets on 
            the port <code class="literal">61614</code> with the URL path <code class="literal">/stomp</code>.
            Web browser can then connect to <code class="literal">ws://&lt;server&gt;:61614/stomp</code> using a Web Socket to send and receive Stomp
            messages.</p><p>A companion JavaScript library to ease client-side development is available from 
            <a class="ulink" href="http://github.com/jmesnil/stomp-websocket">GitHub</a> (please see
            its <a class="ulink" href="http://jmesnil.net/stomp-websocket/doc/">documentation</a> for a complete description).</p><p>The <code class="literal">stomp-websockets</code> example shows how to configure HornetQ server to have web browsers and Java
            applications exchanges messages on a JMS topic.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="stompconnect"/>48.1.6. StompConnect</h3></div></div></div><p><a class="ulink" href="http://stomp.codehaus.org/StompConnect">StompConnect</a> is a server that
            can act as a Stomp broker and proxy the Stomp protocol to the standard JMS API.
            Consequently, using StompConnect it is possible to turn HornetQ into a Stomp Broker and
            use any of the available stomp clients. These include clients written in C, C++, c# and
            .net etc.</p><p>To run StompConnect first start the HornetQ server and make sure that it is using
            JNDI.</p><p>Stomp requires the file <code class="literal">jndi.properties</code> to be available on the
            classpath. This should look something like:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
java.naming.factory.initial=org.jnp.interfaces.NamingContextFactory
java.naming.provider.url=jnp://localhost:1099
java.naming.factory.url.pkgs=org.jboss.naming:org.jnp.interfaces</pre><p>Make sure this file is in the classpath along with the StompConnect jar and the
            HornetQ jars and simply run <code class="literal">java org.codehaus.stomp.jms.Main</code>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e14312"/>48.2. REST</h2></div></div></div><p>Please see <a class="xref" href="#rest" title="Chapter 43. REST Interface">Chapter 43, <i>REST Interface</i></a></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e14318"/>48.3. AMQP</h2></div></div></div><p>HornetQ supports the <a class="ulink" href="https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=amqp">AMQP 1.0</a>
        specification. To enable AMQP you must configure a Netty Acceptor to receive AMQP clients, like so:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;acceptor name="stomp-acceptor"&gt;
&lt;factory-class&gt;org.hornetq.core.remoting.impl.netty.NettyAcceptorFactory&lt;/factory-class&gt;
&lt;param key="protocols"  value="AMQP"/&gt;
&lt;param key="port"  value="5672"/&gt;
&lt;/acceptor&gt;
        </pre><p>HornetQ will then accept AMQP 1.0 clients on port 5672 which is the default AMQP port.</p><p>There are 2 Stomp examples available see proton-j and proton-ruby which use the qpid Java and Ruby clients
        respectively</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e14332"/>48.3.1. AMQP and security</h3></div></div></div><p>The HornetQ Server accepts AMQP SASL Authentication and will use this to map onto the underlying session created
            for the connection so you can use the normal HornetQ security configuration.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e14337"/>48.3.2. AMQP Links</h3></div></div></div><p>An AMQP Link is a uni directional transport for messages between a source and a target, i.e. a client and the
        HornetQ Broker. A link will have an endpoint of which there are 2 kinds, a Sender and A Receiver. At the Broker a
            Sender will have its messages converted into a HornetQ Message and forwarded to its destination or target. A
        Receiver will map onto a HornetQ Server Consumer and convert HornetQ messages back into AMQP messages before being delivered.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e14342"/>48.3.3. AMQP and destinations</h3></div></div></div><p>If an AMQP Link is dynamic then a temporary queue will be created and either the remote source or remote
                target address will be set to the name of the temporary queue. If the Link is not dynamic then the the address
                of the remote target or source will used for the queue. If this does not exist then an exception will be sent</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>For the next version we will add a flag to aut create durable queue but for now you will have to add them via
                the configuration</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e14350"/>48.3.4. AMQP and Coordinations - Handling Transactions</h3></div></div></div><p>An AMQP links target can also be a Coordinator, the Coordinator is used to handle transactions. If a
            coordinator is used the the underlying HormetQ Server session will be transacted and will be either rolled back
                or committed via the coordinator.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>AMQP allows the use of multiple transactions per session, <code class="literal">amqp:multi-txns-per-ssn</code>,
                however in this version HornetQ will only support single transactions per session</p></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="perf-tuning"/>Chapter 49. Performance Tuning</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e14383">49.1. Tuning persistence</a></span></dt><dt><span class="section"><a href="#d0e14414">49.2. Tuning JMS</a></span></dt><dt><span class="section"><a href="#d0e14474">49.3. Other Tunings</a></span></dt><dt><span class="section"><a href="#d0e14579">49.4. Tuning Transport Settings</a></span></dt><dt><span class="section"><a href="#d0e14628">49.5. Tuning the VM</a></span></dt><dt><span class="section"><a href="#d0e14663">49.6. Avoiding Anti-Patterns</a></span></dt></dl></div><p>In this chapter we'll discuss how to tune HornetQ for optimum performance.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e14383"/>49.1. Tuning persistence</h2></div></div></div><div class="itemizedlist"><ul><li><p>Put the message journal on its own physical volume. If the disk is shared with
                    other processes e.g. transaction co-ordinator, database or other journals which
                    are also reading and writing from it, then this may greatly reduce performance
                    since the disk head may be skipping all over the place between the different
                    files. One of the advantages of an append only journal is that disk head
                    movement is minimised - this advantage is destroyed if the disk is shared. If
                    you're using paging or large messages make sure they're ideally put on separate
                    volumes too.</p></li><li><p>Minimum number of journal files. Set <code class="literal">journal-min-files</code> to a
                    number of files that would fit your average sustainable rate. If you see new
                    files being created on the journal data directory too often, i.e. lots of data
                    is being persisted, you need to increase the minimal number of files, this way
                    the journal would reuse more files instead of creating new data files.</p></li><li><p>Journal file size. The journal file size should be aligned to the capacity of
                    a cylinder on the disk. The default value 10MiB should be enough on most
                    systems.</p></li><li><p>Use AIO journal. If using Linux, try to keep your journal type as AIO. AIO
                    will scale better than Java NIO.</p></li><li><p>Tune <code class="literal">journal-buffer-timeout</code>. The timeout can be increased
                    to increase throughput at the expense of latency.</p></li><li><p>If you're running AIO you might be able to get some better performance by
                    increasing <code class="literal">journal-max-io</code>. DO NOT change this parameter if
                    you are running NIO.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e14414"/>49.2. Tuning JMS</h2></div></div></div><p>There are a few areas where some tweaks can be done if you are using the JMS
            API</p><div class="itemizedlist"><ul><li><p>Disable message id. Use the <code class="literal">setDisableMessageID()</code> method on
                    the <code class="literal">MessageProducer</code> class to disable message ids if you don't
                    need them. This decreases the size of the message and also avoids the overhead
                    of creating a unique ID.</p></li><li><p>Disable message timestamp. Use the <code class="literal">setDisableMessageTimeStamp()</code> method on the <code class="literal">MessageProducer</code> class to disable message timestamps if you don't
                    need them.</p></li><li><p>Avoid <code class="literal">ObjectMessage</code>. <code class="literal">ObjectMessage</code> is
                    convenient but it comes at a cost. The body of a <code class="literal">ObjectMessage</code> uses Java serialization to serialize it to bytes.
                    The Java serialized form of even small objects is very verbose so takes up a lot
                    of space on the wire, also Java serialization is slow compared to custom
                    marshalling techniques. Only use <code class="literal">ObjectMessage</code> if you really
                    can't use one of the other message types, i.e. if you really don't know the type
                    of the payload until run-time.</p></li><li><p>Avoid <code class="literal">AUTO_ACKNOWLEDGE</code>. <code class="literal">AUTO_ACKNOWLEDGE</code>
                    mode requires an acknowledgement to be sent from the server for each message
                    received on the client, this means more traffic on the network. If you can, use
                        <code class="literal">DUPS_OK_ACKNOWLEDGE</code> or use <code class="literal">CLIENT_ACKNOWLEDGE</code> or a transacted session and batch up many
                    acknowledgements with one acknowledge/commit. </p></li><li><p>Avoid durable messages. By default JMS messages are durable. If you don't
                    really need durable messages then set them to be non-durable. Durable messages
                    incur a lot more overhead in persisting them to storage.</p></li><li><p>Batch many sends or acknowledgements in a single transaction. HornetQ will
                    only require a network round trip on the commit, not on every send or
                    acknowledgement.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e14474"/>49.3. Other Tunings</h2></div></div></div><p>There are various other places in HornetQ where we can perform some tuning:</p><div class="itemizedlist"><ul><li><p>Use Asynchronous Send Acknowledgements. If you need to send durable messages
                    non transactionally and you need a guarantee that they have reached the server
                    by the time the call to send() returns, don't set durable messages to be sent
                    blocking, instead use asynchronous send acknowledgements to get your
                    acknowledgements of send back in a separate stream, see <a class="xref" href="#send-guarantees" title="Chapter 20. Guarantees of sends and commits">Chapter 20, <i>Guarantees of sends and commits</i></a> for more information on this.</p></li><li><p>Use pre-acknowledge mode. With pre-acknowledge mode, messages are acknowledged
                        <code class="literal">before</code> they are sent to the client. This reduces the
                    amount of acknowledgement traffic on the wire. For more information on this, see
                        <a class="xref" href="#pre-acknowledge" title="Chapter 29. Extra Acknowledge Modes">Chapter 29, <i>Extra Acknowledge Modes</i></a>.</p></li><li><p>Disable security. You may get a small performance boost by disabling security
                    by setting the <code class="literal">security-enabled</code> parameter to <code class="literal">false</code> in <code class="literal">hornetq-configuration.xml</code>.</p></li><li><p>Disable persistence. If you don't need message persistence, turn it off
                    altogether by setting <code class="literal">persistence-enabled</code> to false in
                        <code class="literal">hornetq-configuration.xml</code>.</p></li><li><p>Sync transactions lazily. Setting <code class="literal">journal-sync-transactional</code> to <code class="literal">false</code> in
                        <code class="literal">hornetq-configuration.xml</code> can give you better
                    transactional persistent performance at the expense of some possibility of loss
                    of transactions on failure. See <a class="xref" href="#send-guarantees" title="Chapter 20. Guarantees of sends and commits">Chapter 20, <i>Guarantees of sends and commits</i></a> for more
                    information.</p></li><li><p>Sync non transactional lazily. Setting <code class="literal">journal-sync-non-transactional</code> to <code class="literal">false</code> in
                        <code class="literal">hornetq-configuration.xml</code> can give you better
                    non-transactional persistent performance at the expense of some possibility of
                    loss of durable messages on failure. See <a class="xref" href="#send-guarantees" title="Chapter 20. Guarantees of sends and commits">Chapter 20, <i>Guarantees of sends and commits</i></a> for
                    more information.</p></li><li><p>Send messages non blocking. Setting <code class="literal">block-on-durable-send</code>
                    and <code class="literal">block-on-non-durable-send</code> to <code class="literal">false</code> in
                        <code class="literal">hornetq-jms.xml</code> (if you're using JMS and JNDI) or
                    directly on the ServerLocator. This means you don't have to wait a whole
                    network round trip for every message sent. See <a class="xref" href="#send-guarantees" title="Chapter 20. Guarantees of sends and commits">Chapter 20, <i>Guarantees of sends and commits</i></a>
                    for more information.</p></li><li><p>If you have very fast consumers, you can increase consumer-window-size. This
                    effectively disables consumer flow control.</p></li><li><p>Socket NIO vs Socket Old IO. By default HornetQ uses old (blocking) on the
                    server and the client side (see the chapter on configuring transports for more
                    information <a class="xref" href="#configuring-transports" title="Chapter 16. Configuring the Transport">Chapter 16, <i>Configuring the Transport</i></a>). NIO is much more scalable
                    but can give you some latency hit compared to old blocking IO. If you need to be
                    able to service many thousands of connections on the server, then you should
                    make sure you're using NIO on the server. However, if don't expect many
                    thousands of connections on the server you can keep the server acceptors using
                    old IO, and might get a small performance advantage.</p></li><li><p>Use the core API not JMS. Using the JMS API you will have slightly lower
                    performance than using the core API, since all JMS operations need to be
                    translated into core operations before the server can handle them. If using the
                    core API try to use methods that take <code class="literal">SimpleString</code> as much as
                    possible. <code class="literal">SimpleString</code>, unlike java.lang.String does not
                    require copying before it is written to the wire, so if you re-use <code class="literal">SimpleString</code> instances between calls then you can avoid some
                    unnecessary copying.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e14579"/>49.4. Tuning Transport Settings</h2></div></div></div><div class="itemizedlist"><ul><li><p>TCP buffer sizes. If you have a fast network and fast machines you may get a
                    performance boost by increasing the TCP send and receive buffer sizes. See the
                        <a class="xref" href="#configuring-transports" title="Chapter 16. Configuring the Transport">Chapter 16, <i>Configuring the Transport</i></a> for more information on this. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p> Note that some operating systems like later versions of Linux include TCP
                        auto-tuning and setting TCP buffer sizes manually can prevent auto-tune from
                        working and actually give you worse performance!</p></div></li><li><p>Increase limit on file handles on the server. If you expect a lot of
                    concurrent connections on your servers, or if clients are rapidly opening and
                    closing connections, you should make sure the user running the server has
                    permission to create sufficient file handles.</p><p>This varies from operating system to operating system. On Linux systems you
                    can increase the number of allowable open file handles in the file <code class="literal">/etc/security/limits.conf</code> e.g. add the lines
                    </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
serveruser     soft    nofile  20000
serveruser     hard    nofile  20000</pre><p>
                    This would allow up to 20000 file handles to be open by the user <code class="literal">serveruser</code>. </p></li><li><p>Use <code class="literal">batch-delay</code> and set <code class="literal">direct-deliver</code>
                    to false for the best throughput for very small messages. HornetQ comes with a
                    preconfigured connector/acceptor pair (<code class="literal">netty-throughput</code>) in
                        <code class="literal">hornetq-configuration.xml</code> and JMS connection factory
                        (<code class="literal">ThroughputConnectionFactory</code>) in <code class="literal">hornetq-jms.xml</code>which can be used to give the very best
                    throughput, especially for small messages. See the <a class="xref" href="#configuring-transports" title="Chapter 16. Configuring the Transport">Chapter 16, <i>Configuring the Transport</i></a> for more information on this.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e14628"/>49.5. Tuning the VM</h2></div></div></div><p>We highly recommend you use the latest Java JVM for the best performance. We test
            internally using the Sun JVM, so some of these tunings won't apply to JDKs from other
            providers (e.g. IBM or JRockit)</p><div class="itemizedlist"><ul><li><p>Garbage collection. For smooth server operation we recommend using a parallel
                    garbage collection algorithm, e.g. using the JVM argument <code class="literal">-XX:+UseParallelOldGC</code> on Sun JDKs.</p></li><li><p><a id="perf-tuning.memory"/>Memory settings. Give as much memory as you can to the server. HornetQ can run
                    in low memory by using paging (described in <a class="xref" href="#paging" title="Chapter 24. Paging">Chapter 24, <i>Paging</i></a>) but if it
                    can run with all queues in RAM this will improve performance. The amount of
                    memory you require will depend on the size and number of your queues and the
                    size and number of your messages. Use the JVM arguments <code class="literal">-Xms</code>
                    and <code class="literal">-Xmx</code> to set server available RAM. We recommend setting
                    them to the same high value.</p></li><li><p>Aggressive options. Different JVMs provide different sets of JVM tuning
                    parameters, for the Sun Hotspot JVM the full list of options is available <a class="ulink" href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">here</a>. We recommend at least using <code class="literal">-XX:+AggressiveOpts</code> and<code class="literal">
                        -XX:+UseFastAccessorMethods</code>. You may get some mileage with the
                    other tuning parameters depending on your OS platform and application usage
                    patterns.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e14663"/>49.6. Avoiding Anti-Patterns</h2></div></div></div><div class="itemizedlist"><ul><li><p>Re-use connections / sessions / consumers / producers. Probably the most
                    common messaging anti-pattern we see is users who create a new
                    connection/session/producer for every message they send or every message they
                    consume. This is a poor use of resources. These objects take time to create and
                    may involve several network round trips. Always re-use them.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Some popular libraries such as the Spring JMS Template are known to use
                        these anti-patterns. If you're using Spring JMS Template and you're getting
                        poor performance you know why. Don't blame HornetQ! The Spring JMS Template
                        can only safely be used in an app server which caches JMS sessions (e.g.
                        using JCA), and only then for sending messages. It cannot be safely be used
                        for synchronously consuming messages, even in an app server. </p></div></li><li><p>Avoid fat messages. Verbose formats such as XML take up a lot of space on the
                    wire and performance will suffer as result. Avoid XML in message bodies if you
                    can.</p></li><li><p>Don't create temporary queues for each request. This common anti-pattern
                    involves the temporary queue request-response pattern. With the temporary queue
                    request-response pattern a message is sent to a target and a reply-to header is
                    set with the address of a local temporary queue. When the recipient receives the
                    message they process it then send back a response to the address specified in
                    the reply-to. A common mistake made with this pattern is to create a new
                    temporary queue on each message sent. This will drastically reduce performance.
                    Instead the temporary queue should be re-used for many requests.</p></li><li><p>Don't use Message-Driven Beans for the sake of it. As soon as you start using
                    MDBs you are greatly increasing the codepath for each message received compared
                    to a straightforward message consumer, since a lot of extra application server
                    code is executed. Ask yourself do you really need MDBs? Can you accomplish the
                    same task using just a normal message consumer?</p></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-index"/>Chapter 50. Configuration Reference</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#server.configuration">50.1. Server Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e14707">50.1.1. hornetq-configuration.xml</a></span></dt><dt><span class="section"><a href="#d0e17285">50.1.2. hornetq-jms.xml</a></span></dt><dt><span class="section"><a href="#configuration.masked-password">50.1.3. Using Masked Passwords in Configuration Files</a></span></dt></dl></dd></dl></div><p>This section is a quick index for looking up configuration. Click on the element name to
        go to the specific chapter.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="server.configuration"/>50.1. Server Configuration</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e14707"/>50.1.1. hornetq-configuration.xml</h3></div></div></div><p>This is the main core server configuration file.</p><div class="table"><a id="d0e14712"/><p class="title"><b>Table 50.1. Server Configuration</b></p><div class="table-contents"><table summary="Server Configuration" border="1"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th>Element Name</th><th>Element Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td>
         <a class="link" href="#configuring-transports.acceptors" title="16.1. Understanding Acceptors">acceptors</a>
      </td><td>Sequence of &lt;acceptor/&gt;</td><td>a list of remoting acceptors to create</td><td> </td></tr><tr><td>
         <a class="link" href="#configuring-transports.acceptors" title="16.1. Understanding Acceptors">acceptors.acceptor</a>
      </td><td>Complex element</td><td> </td><td> </td></tr><tr><td>
         <a class="link" href="#configuring-transports.acceptors" title="16.1. Understanding Acceptors">acceptors.acceptor.name (attribute)</a>
      </td><td>xsd:string</td><td>Name of the acceptor</td><td> </td></tr><tr><td>
         <a class="link" href="#configuring-transports.acceptors" title="16.1. Understanding Acceptors">acceptors.acceptor.factory-class</a>
      </td><td>xsd:string</td><td>Name of the AcceptorFactory implementation</td><td> </td></tr><tr><td>
         <a class="link" href="#configuring-transports.acceptors" title="16.1. Understanding Acceptors">acceptors.acceptor.param</a>
      </td><td>Complex element</td><td>A key-value pair used to configure the acceptor. An acceptor can have many param</td><td> </td></tr><tr><td>
         <a class="link" href="#configuring-transports.acceptors" title="16.1. Understanding Acceptors">acceptors.acceptor.param.key (required attribute)</a>
      </td><td>xsd:string</td><td>Key of a configuration parameter</td><td> </td></tr><tr><td>
         <a class="link" href="#configuring-transports.acceptors" title="16.1. Understanding Acceptors">acceptors.acceptor.param.value (required attribute)</a>
      </td><td>xsd:string</td><td>Value of a configuration parameter</td><td> </td></tr><tr><td>
         <a class="link" href="#queue-attributes.address-settings" title="25.3. Configuring Queues Via Address Settings">address-settings</a>
      </td><td>Sequence of &lt;address-setting/&gt;</td><td>a list of address settings</td><td> </td></tr><tr><td>
         <a class="link" href="#queue-attributes.address-settings" title="25.3. Configuring Queues Via Address Settings">address-settings.address-setting</a>
      </td><td>Complex element</td><td> </td><td> </td></tr><tr><td>
         <a class="link" href="#queue-attributes.address-settings" title="25.3. Configuring Queues Via Address Settings">address-settings.address-setting.match (required attribute)</a>
      </td><td>xsd:string</td><td>XXX</td><td> </td></tr><tr><td>
         <a class="link" href="#undelivered-messages.configuring" title="21.2.1. Configuring Dead Letter Addresses">address-settings.address-setting.dead-letter-address</a>
      </td><td>xsd:string</td><td>the address to send dead messages to</td><td> </td></tr><tr><td>
         <a class="link" href="#message-expiry.configuring" title="22.2. Configuring Expiry Addresses">address-settings.address-setting.expiry-address</a>
      </td><td>xsd:string</td><td>the address to send expired messages to</td><td> </td></tr><tr><td>
         <a class="link" href="#queue-attributes.address-settings" title="25.3. Configuring Queues Via Address Settings">address-settings.address-setting.expiry-delay</a>
      </td><td>xsd:long</td><td>Overrides the expiration time for messages using the default value for expiration time. "-1" disables this setting.</td><td>-1</td></tr><tr><td>
         <a class="link" href="#undelivered-messages.delay" title="21.1.1. Configuring Delayed Redelivery">address-settings.address-setting.redelivery-delay</a>
      </td><td>xsd:long</td><td>the time (in ms) to wait before redelivering a cancelled message.</td><td>0</td></tr><tr><td>
         <a class="link" href="#queue-attributes.address-settings" title="25.3. Configuring Queues Via Address Settings">address-settings.address-setting.redelivery-delay-multiplier</a>
      </td><td>xsd:double</td><td>multipler to apply to the "redelivery-delay"</td><td> </td></tr><tr><td>
         <a class="link" href="#queue-attributes.address-settings" title="25.3. Configuring Queues Via Address Settings">address-settings.address-setting.max-redelivery-delay</a>
      </td><td>xsd:long</td><td>Maximum value for the redelivery-delay</td><td> </td></tr><tr><td>
         <a class="link" href="#undelivered-messages.configuring" title="21.2.1. Configuring Dead Letter Addresses">address-settings.address-setting.max-delivery-attempts</a>
      </td><td>xsd:int</td><td>how many times to attempt to deliver a message before sending to dead letter address</td><td>10</td></tr><tr><td>
         <a class="link" href="#paging" title="Chapter 24. Paging">address-settings.address-setting.max-size-bytes</a>
      </td><td>xsd:long</td><td>the maximum size (in bytes) to use in paging for an address (-1 means no limits)</td><td>-1</td></tr><tr><td>
         <a class="link" href="#paging" title="Chapter 24. Paging">address-settings.address-setting.page-size-bytes</a>
      </td><td>xsd:long</td><td>the page size (in bytes) to use for an address</td><td>10485760 (10 * 1024 * 1024)</td></tr><tr><td>
         <a class="link" href="#paging" title="Chapter 24. Paging">address-settings.address-setting.page-max-cache-size</a>
      </td><td>xsd:int</td><td>Number of paging files to cache in memory to avoid IO during paging navigation</td><td>5</td></tr><tr><td>
         <a class="link" href="#queue-attributes.address-settings" title="25.3. Configuring Queues Via Address Settings">address-settings.address-setting.address-full-policy</a>
      </td><td>DROP|FAIL|PAGE|BLOCK</td><td>what happens when an address where "max-size-bytes" is specified becomes full</td><td> </td></tr><tr><td>
         <a class="link" href="#queue-attributes.address-settings" title="25.3. Configuring Queues Via Address Settings">address-settings.address-setting.message-counter-history-day-limit</a>
      </td><td>xsd:int</td><td>how many days to keep message counter history for this address</td><td>0 (days)</td></tr><tr><td>
         <a class="link" href="#last-value-queues" title="Chapter 27. Last-Value Queues">address-settings.address-setting.last-value-queue</a>
      </td><td>xsd:boolean</td><td>whether to treat the queue as a last value queue</td><td>false</td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">address-settings.address-setting.redistribution-delay</a>
      </td><td>xsd:long</td><td>how long (in ms) to wait after the last consumer is closed on a queue before redistributing messages.</td><td>-1</td></tr><tr><td>
         <a class="link" href="#queue-attributes.address-settings" title="25.3. Configuring Queues Via Address Settings">address-settings.address-setting.send-to-dla-on-no-route</a>
      </td><td>xsd:boolean</td><td>if there are no queues matching this address, whether to forward message to DLA (if it exists for this address)</td><td> </td></tr><tr><td>
         <a class="link" href="#ha.allow-fail-back" title="39.1.4. Failing Back to live Server">allow-failback</a>
      </td><td>xsd:boolean</td><td>Whether a server will automatically stop when a another places a request to take over its place. The use case is when a regular server stops and its backup takes over its duties, later the main server restarts and requests the server (the former backup) to stop operating.</td><td>true</td></tr><tr><td>
         <a class="link" href="#connection-ttl.async-connection-execution" title="17.3. Configuring Asynchronous Connection Execution">async-connection-execution-enabled</a>
      </td><td>xsd:boolean</td><td>Should incoming packets on the server be handed off to a thread from the thread pool for processing or should they be handled on the remoting thread?</td><td>true</td></tr><tr><td>
         <a class="link" href="#ha" title="Chapter 39. High Availability and Failover">backup</a>
      </td><td>xsd:boolean</td><td>whether this server is a backup server</td><td>false</td></tr><tr><td>
         <a class="link" href="#">backup-group-name</a>
      </td><td>xsd:string</td><td>used for replication, if set, (remote) backup servers will only pair with live servers with matching backup-group-name</td><td> </td></tr><tr><td>
         <a class="link" href="#configuring.bindings.journal" title="15.1. Configuring the bindings journal">bindings-directory</a>
      </td><td>xsd:string</td><td>the directory to store the persisted bindings to</td><td>data/bindings</td></tr><tr><td>
         <a class="link" href="#core-bridges" title="Chapter 36. Core Bridges">bridges</a>
      </td><td>Sequence of &lt;bridge/&gt;</td><td>a list of bridges to create</td><td> </td></tr><tr><td>
         <a class="link" href="#core-bridges" title="Chapter 36. Core Bridges">bridges.bridge</a>
      </td><td>Complex element</td><td> </td><td> </td></tr><tr><td>
         <a class="link" href="#core-bridges" title="Chapter 36. Core Bridges">bridges.bridge.name (required attribute)</a>
      </td><td>xsd:ID</td><td>unique name for this bridge</td><td> </td></tr><tr><td>
         <a class="link" href="#core-bridges" title="Chapter 36. Core Bridges">bridges.bridge.queue-name</a>
      </td><td>xsd:IDREF</td><td>name of queue that this bridge consumes from</td><td> </td></tr><tr><td>
         <a class="link" href="#core-bridges" title="Chapter 36. Core Bridges">bridges.bridge.forwarding-address</a>
      </td><td>xsd:string</td><td>address to forward to. If omitted original address is used</td><td> </td></tr><tr><td>
         <a class="link" href="#core-bridges" title="Chapter 36. Core Bridges">bridges.bridge.ha</a>
      </td><td>xsd:boolean</td><td>whether this bridge supports fail-over</td><td>false</td></tr><tr><td>
         <a class="link" href="#core-bridges" title="Chapter 36. Core Bridges">bridges.bridge.filter</a>
      </td><td>Complex element</td><td> </td><td> </td></tr><tr><td>
         <a class="link" href="#core-bridges" title="Chapter 36. Core Bridges">bridges.bridge.filter.string (required attribute)</a>
      </td><td>xsd:string</td><td>optional core filter expression</td><td> </td></tr><tr><td>
         <a class="link" href="#core-bridges" title="Chapter 36. Core Bridges">bridges.bridge.transformer-class-name</a>
      </td><td>xsd:string</td><td>optional name of transformer class</td><td> </td></tr><tr><td>
         <a class="link" href="#core-bridges" title="Chapter 36. Core Bridges">bridges.bridge.min-large-message-size</a>
      </td><td>xsd:int</td><td>Any message larger than this size is considered a large message (to be sent in chunks)</td><td>102400 (bytes)</td></tr><tr><td>
         <a class="link" href="#connection-ttl" title="Chapter 17. Detecting Dead Connections">bridges.bridge.check-period</a>
      </td><td>xsd:long</td><td>The period (in milliseconds) a bridge's client will check if it failed to receive a ping from the server. -1 disables this check.</td><td>30000 (ms)</td></tr><tr><td>
         <a class="link" href="#connection-ttl" title="Chapter 17. Detecting Dead Connections">bridges.bridge.connection-ttl</a>
      </td><td>xsd:long</td><td>how long to keep a connection alive in the absence of any data arriving from the client. This should be greater than the ping period.</td><td>60000 (ms)</td></tr><tr><td>
         <a class="link" href="#core-bridges" title="Chapter 36. Core Bridges">bridges.bridge.retry-interval</a>
      </td><td>xsd:long</td><td>period (in ms) between successive retries</td><td>2000 (in milliseconds)</td></tr><tr><td>
         <a class="link" href="#core-bridges" title="Chapter 36. Core Bridges">bridges.bridge.retry-interval-multiplier</a>
      </td><td>xsd:double</td><td>multiplier to apply to successive retry intervals</td><td>1</td></tr><tr><td>
         <a class="link" href="#core-bridges" title="Chapter 36. Core Bridges">bridges.bridge.max-retry-interval</a>
      </td><td>xsd:long</td><td>Limit to the retry-interval growth (due to retry-interval-multiplier)</td><td>2000</td></tr><tr><td>
         <a class="link" href="#core-bridges" title="Chapter 36. Core Bridges">bridges.bridge.reconnect-attempts</a>
      </td><td>xsd:int</td><td>maximum number of retry attempts, -1 means 'no limits'</td><td>-1</td></tr><tr><td>
         <a class="link" href="#core-bridges" title="Chapter 36. Core Bridges">bridges.bridge.failover-on-server-shutdown</a>
      </td><td>xsd:boolean</td><td>should failover be prompted if target server is cleanly shutdown?</td><td>false</td></tr><tr><td>
         <a class="link" href="#core-bridges" title="Chapter 36. Core Bridges">bridges.bridge.use-duplicate-detection</a>
      </td><td>xsd:boolean</td><td>should duplicate detection headers be inserted in forwarded messages?</td><td>true</td></tr><tr><td>
         <a class="link" href="#core-bridges" title="Chapter 36. Core Bridges">bridges.bridge.confirmation-window-size</a>
      </td><td>xsd:int</td><td>Once the bridge has received this many bytes, it sends a confirmation</td><td>(bytes, 1024 * 1024)</td></tr><tr><td>
         <a class="link" href="#core-bridges" title="Chapter 36. Core Bridges">bridges.bridge.user</a>
      </td><td>xsd:string</td><td>username, if unspecified the cluster-user is used</td><td> </td></tr><tr><td>
         <a class="link" href="#core-bridges" title="Chapter 36. Core Bridges">bridges.bridge.password</a>
      </td><td>xsd:string</td><td>password, if unspecified the cluster-password is used</td><td> </td></tr><tr><td>
         <a class="link" href="#core-bridges" title="Chapter 36. Core Bridges">bridges.bridge.reconnect-attempts-same-node</a>
      </td><td>xsd:int</td><td>Upon reconnection this configures the number of time the same node on the topology will be retried before reseting the server locator and using the initial connectors</td><td>10 (int, 10)</td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">broadcast-groups</a>
      </td><td>Sequence of &lt;broadcast-group/&gt;</td><td>a list of broadcast groups to create</td><td> </td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">broadcast-groups.broadcast-group</a>
      </td><td>Complex element</td><td> </td><td> </td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">broadcast-groups.broadcast-group.name (required attribute)</a>
      </td><td>xsd:ID</td><td>a unique name for the broadcast group</td><td> </td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">broadcast-groups.broadcast-group.local-bind-address</a>
      </td><td>xsd:string</td><td>local bind address that the datagram socket is bound to</td><td>wildcard IP address chosen by the kernel</td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">broadcast-groups.broadcast-group.local-bind-port</a>
      </td><td>xsd:int</td><td>local port to which the datagram socket is bound to</td><td>-1 (anonymous port)</td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">broadcast-groups.broadcast-group.group-address</a>
      </td><td>xsd:string</td><td>multicast address to which the data will be broadcast</td><td> </td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">broadcast-groups.broadcast-group.group-port</a>
      </td><td>xsd:int</td><td>UDP port number used for broadcasting</td><td> </td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">broadcast-groups.broadcast-group.broadcast-period</a>
      </td><td>xsd:long</td><td>period in milliseconds between consecutive broadcasts</td><td>2000 (in milliseconds)</td></tr><tr><td>
         <a class="link" href="#clusters.jgroups-file">broadcast-groups.broadcast-group.jgroups-file</a>
      </td><td>xsd:string</td><td>Name of JGroups configuration file. If specified, the server uses JGroups for broadcasting.</td><td> </td></tr><tr><td>
         <a class="link" href="#clusters.jgroups-example">broadcast-groups.broadcast-group.jgroups-channel</a>
      </td><td>xsd:string</td><td>Name of JGroups Channel. If specified, the server uses the named channel for broadcasting.</td><td> </td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">broadcast-groups.broadcast-group.connector-ref</a>
      </td><td>xsd:string</td><td> </td><td> </td></tr><tr><td>
         <a class="link" href="#hq.check-for-live-server">check-for-live-server</a>
      </td><td>xsd:boolean</td><td>Whether to check the cluster for a (live) server using our own server ID when starting up. This option is only necessary for performing 'fail-back' on replicating servers. Strictly speaking this setting only applies to live servers and not to backups.</td><td>false</td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">cluster-connections</a>
      </td><td>Sequence of &lt;cluster-connection/&gt;</td><td>a list of cluster connections</td><td> </td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">cluster-connections.cluster-connection</a>
      </td><td>Complex element</td><td> </td><td> </td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">cluster-connections.cluster-connection.name (required attribute)</a>
      </td><td>xsd:ID</td><td>unique name for this cluster connection</td><td> </td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">cluster-connections.cluster-connection.address</a>
      </td><td>xsd:string</td><td>name of the address this cluster connection applies to</td><td> </td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">cluster-connections.cluster-connection.connector-ref</a>
      </td><td>xsd:string</td><td>Name of the connector reference to use.</td><td> </td></tr><tr><td>
         <a class="link" href="#connection-ttl" title="Chapter 17. Detecting Dead Connections">cluster-connections.cluster-connection.check-period</a>
      </td><td>xsd:long</td><td>The period (in milliseconds) used to check if the cluster connection has failed to receive pings from another server</td><td>30000 (ms)</td></tr><tr><td>
         <a class="link" href="#connection-ttl" title="Chapter 17. Detecting Dead Connections">cluster-connections.cluster-connection.connection-ttl</a>
      </td><td>xsd:long</td><td>how long to keep a connection alive in the absence of any data arriving from the client</td><td>60000 (ms)</td></tr><tr><td>
         <a class="link" href="#large-messages" title="Chapter 23. Large Messages">cluster-connections.cluster-connection.min-large-message-size</a>
      </td><td>xsd:int</td><td>Messages larger than this are considered large-messages</td><td>(bytes)</td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">cluster-connections.cluster-connection.call-timeout</a>
      </td><td>xsd:long</td><td>How long to wait for a reply</td><td>30000 (ms)</td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">cluster-connections.cluster-connection.retry-interval</a>
      </td><td>xsd:long</td><td>period (in ms) between successive retries</td><td>500</td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">cluster-connections.cluster-connection.retry-interval-multiplier</a>
      </td><td>xsd:double</td><td>multiplier to apply to the retry-interval</td><td>1</td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">cluster-connections.cluster-connection.max-retry-interval</a>
      </td><td>xsd:long</td><td>Maximum value for retry-interval</td><td>2000</td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">cluster-connections.cluster-connection.reconnect-attempts</a>
      </td><td>xsd:int</td><td>How many attempts should be made to reconnect after failure</td><td>-1</td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">cluster-connections.cluster-connection.use-duplicate-detection</a>
      </td><td>xsd:boolean</td><td>should duplicate detection headers be inserted in forwarded messages?</td><td>true</td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">cluster-connections.cluster-connection.forward-when-no-consumers</a>
      </td><td>xsd:boolean</td><td>should messages be load balanced if there are no matching consumers on target?</td><td>false</td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">cluster-connections.cluster-connection.max-hops</a>
      </td><td>xsd:int</td><td>maximum number of hops cluster topology is propagated</td><td>1</td></tr><tr><td>
         <a class="link" href="#client-reconnection" title="Chapter 34. Client Reconnection and Session Reattachment">cluster-connections.cluster-connection.confirmation-window-size</a>
      </td><td>xsd:int</td><td>The size (in bytes) of the window used for confirming data from the server connected to.</td><td>1048576</td></tr><tr><td>
         <a class="link" href="#clusters.cluster-connections" title="38.3.1. Configuring Cluster Connections">cluster-connections.cluster-connection.call-failover-timeout</a>
      </td><td>xsd:long</td><td>How long to wait for a reply if in the middle of a fail-over. -1 means wait forever.</td><td>-1 (ms)</td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">cluster-connections.cluster-connection.notification-interval</a>
      </td><td>xsd:long</td><td>how often the cluster connection will notify the cluster of its existence right after joining the cluster</td><td>1000 (ms)</td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">cluster-connections.cluster-connection.notification-attempts</a>
      </td><td>xsd:int</td><td>how many times this cluster connection will notify the cluster of its existence right after joining the cluster</td><td>2</td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">clustered</a>
      </td><td>xsd:boolean</td><td>DEPRECATED. This option is deprecated and its value will be ignored (HQ221038). A HornetQ server will be "clustered" when its configuration contain a cluster-configuration.</td><td>false</td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">cluster-password</a>
      </td><td>xsd:string</td><td>Cluster password. It applies to all cluster configurations.</td><td>CHANGE ME!!</td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">cluster-user</a>
      </td><td>xsd:string</td><td>Cluster username. It applies to all cluster configurations.</td><td>HORNETQ.CLUSTER.ADMIN.USER</td></tr><tr><td>
         <a class="link" href="#connection-ttl.override">connection-ttl-override</a>
      </td><td>xsd:long</td><td>if set, this will override how long (in ms) to keep a connection alive without receiving a ping. -1 disables this setting.</td><td>-1</td></tr><tr><td>
         <a class="link" href="#configuring-transports.connectors" title="16.2. Understanding Connectors">connectors</a>
      </td><td>Sequence of &lt;connector/&gt;</td><td>a list of remoting connectors configurations to create</td><td> </td></tr><tr><td>
         <a class="link" href="#configuring-transports.connectors" title="16.2. Understanding Connectors">connectors.connector</a>
      </td><td>Complex element</td><td> </td><td> </td></tr><tr><td>
         <a class="link" href="#configuring-transports.connectors" title="16.2. Understanding Connectors">connectors.connector.name (required attribute)</a>
      </td><td>xsd:ID</td><td>Name of the connector</td><td> </td></tr><tr><td>
         <a class="link" href="#configuring-transports.connectors" title="16.2. Understanding Connectors">connectors.connector.factory-class</a>
      </td><td>xsd:string</td><td>Name of the ConnectorFactory implementation</td><td> </td></tr><tr><td>
         <a class="link" href="#configuring-transports.connectors" title="16.2. Understanding Connectors">connectors.connector.param</a>
      </td><td>Complex element</td><td>A key-value pair used to configure the connector. A connector can have many param's</td><td> </td></tr><tr><td>
         <a class="link" href="#configuring-transports.connectors" title="16.2. Understanding Connectors">connectors.connector.param.key (required attribute)</a>
      </td><td>xsd:string</td><td>Key of a configuration parameter</td><td> </td></tr><tr><td>
         <a class="link" href="#configuring-transports.connectors" title="16.2. Understanding Connectors">connectors.connector.param.value (required attribute)</a>
      </td><td>xsd:string</td><td>Value of a configuration parameter</td><td> </td></tr><tr><td>
         <a class="link" href="#">connector-services</a>
      </td><td>Sequence of &lt;connector-service/&gt;</td><td> </td><td> </td></tr><tr><td>
         <a class="link" href="#">connector-services.connector-service</a>
      </td><td>Complex element</td><td> </td><td> </td></tr><tr><td>
         <a class="link" href="#">connector-services.connector-service.name (attribute)</a>
      </td><td>xsd:string</td><td>name of the connector service</td><td> </td></tr><tr><td>
         <a class="link" href="#">connector-services.connector-service.factory-class</a>
      </td><td>xsd:string</td><td>Name of the factory class of the ConnectorService</td><td> </td></tr><tr><td>
         <a class="link" href="#">connector-services.connector-service.param</a>
      </td><td>Complex element</td><td> </td><td> </td></tr><tr><td>
         <a class="link" href="#">connector-services.connector-service.param.key (required attribute)</a>
      </td><td>xsd:string</td><td>Key of a configuration parameter</td><td> </td></tr><tr><td>
         <a class="link" href="#">connector-services.connector-service.param.value (required attribute)</a>
      </td><td>xsd:string</td><td>Value of a configuration parameter</td><td> </td></tr><tr><td>
         <a class="link" href="#configuring.bindings.journal" title="15.1. Configuring the bindings journal">create-bindings-dir</a>
      </td><td>xsd:boolean</td><td>true means that the server will create the bindings directory on start up</td><td>true</td></tr><tr><td>
         <a class="link" href="#configuring.message.journal.create-journal-dir">create-journal-dir</a>
      </td><td>xsd:boolean</td><td>true means that the journal directory will be created</td><td>true</td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">discovery-groups</a>
      </td><td>Sequence of &lt;discovery-group/&gt;</td><td>a list of discovery groups to create</td><td> </td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">discovery-groups.discovery-group</a>
      </td><td>Complex element</td><td> </td><td> </td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">discovery-groups.discovery-group.name (required attribute)</a>
      </td><td>xsd:ID</td><td>a unique name for the discovery group</td><td> </td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">discovery-groups.discovery-group.group-address</a>
      </td><td>xsd:string</td><td>Multicast IP address of the group to listen on</td><td> </td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">discovery-groups.discovery-group.group-port</a>
      </td><td>xsd:int</td><td>UDP port number of the multi cast group</td><td> </td></tr><tr><td>
         <a class="link" href="#clusters.jgroups-file">discovery-groups.discovery-group.jgroups-file</a>
      </td><td>xsd:string</td><td>Name of a JGroups configuration file. If specified, the server uses JGroups for discovery.</td><td> </td></tr><tr><td>
         <a class="link" href="#clusters.jgroups-example">discovery-groups.discovery-group.jgroups-channel</a>
      </td><td>xsd:string</td><td>Name of a JGroups Channel. If specified, the server uses the named channel for discovery.</td><td> </td></tr><tr><td>
         <a class="link" href="#">discovery-groups.discovery-group.refresh-timeout</a>
      </td><td>xsd:int</td><td>Period the discovery group waits after receiving the last broadcast from a particular server before removing that servers connector pair entry from its list.</td><td>10000 (in milliseconds)</td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">discovery-groups.discovery-group.local-bind-address</a>
      </td><td>xsd:string</td><td>local bind address that the datagram socket is bound to</td><td>wildcard IP address chosen by the kernel</td></tr><tr><td>
         <a class="link" href="#clusters" title="Chapter 38. Clusters">discovery-groups.discovery-group.local-bind-port</a>
      </td><td>xsd:int</td><td>local port to which the datagram socket is bound to</td><td>-1 (anonymous port)</td></tr><tr><td>
         <a class="link" href="#">discovery-groups.discovery-group.initial-wait-timeout</a>
      </td><td>xsd:int</td><td>time to wait for an initial broadcast to give us at least one node in the cluster</td><td>10000 (milliseconds)</td></tr><tr><td>
         <a class="link" href="#diverts" title="Chapter 35. Diverting and Splitting Message Flows">diverts</a>
      </td><td>Sequence of &lt;divert/&gt;</td><td>a list of diverts to use</td><td> </td></tr><tr><td>
         <a class="link" href="#diverts" title="Chapter 35. Diverting and Splitting Message Flows">diverts.divert</a>
      </td><td>Complex element</td><td> </td><td> </td></tr><tr><td>
         <a class="link" href="#diverts" title="Chapter 35. Diverting and Splitting Message Flows">diverts.divert.name (required attribute)</a>
      </td><td>xsd:ID</td><td>a unique name for the divert</td><td> </td></tr><tr><td>
         <a class="link" href="#diverts" title="Chapter 35. Diverting and Splitting Message Flows">diverts.divert.transformer-class-name</a>
      </td><td>xsd:string</td><td>an optional class name of a transformer</td><td> </td></tr><tr><td>
         <a class="link" href="#diverts" title="Chapter 35. Diverting and Splitting Message Flows">diverts.divert.exclusive</a>
      </td><td>xsd:boolean</td><td>whether this is an exclusive divert</td><td>false</td></tr><tr><td>
         <a class="link" href="#diverts" title="Chapter 35. Diverting and Splitting Message Flows">diverts.divert.routing-name</a>
      </td><td>xsd:string</td><td>the routing name for the divert</td><td> </td></tr><tr><td>
         <a class="link" href="#diverts" title="Chapter 35. Diverting and Splitting Message Flows">diverts.divert.address</a>
      </td><td>xsd:string</td><td>the address this divert will divert from</td><td> </td></tr><tr><td>
         <a class="link" href="#diverts" title="Chapter 35. Diverting and Splitting Message Flows">diverts.divert.forwarding-address</a>
      </td><td>xsd:string</td><td>the forwarding address for the divert</td><td> </td></tr><tr><td>
         <a class="link" href="#diverts" title="Chapter 35. Diverting and Splitting Message Flows">diverts.divert.filter</a>
      </td><td>Complex element</td><td> </td><td> </td></tr><tr><td>
         <a class="link" href="#diverts" title="Chapter 35. Diverting and Splitting Message Flows">diverts.divert.filter.string (required attribute)</a>
      </td><td>xsd:string</td><td>optional core filter expression</td><td> </td></tr><tr><td>
         <a class="link" href="#ha.allow-fail-back" title="39.1.4. Failing Back to live Server">failback-delay</a>
      </td><td>xsd:long</td><td>delay to wait before fail-back occurs on (live's) restart</td><td>5000 (in milliseconds)</td></tr><tr><td>
         <a class="link" href="#ha.allow-fail-back" title="39.1.4. Failing Back to live Server">failover-on-shutdown</a>
      </td><td>xsd:boolean</td><td>Will this backup server come live on a normal server shutdown</td><td>false</td></tr><tr><td>
         <a class="link" href="#using-server.configuration" title="6.6. Configuration files">file-deployment-enabled</a>
      </td><td>xsd:boolean</td><td>true means that the server will load configuration from the configuration files</td><td>false</td></tr><tr><td>
         <a class="link" href="#message-grouping" title="Chapter 28. Message Grouping">grouping-handler</a>
      </td><td>Complex element</td><td>Message Group configuration</td><td> </td></tr><tr><td>
         <a class="link" href="#message-grouping" title="Chapter 28. Message Grouping">grouping-handler.name (required attribute)</a>
      </td><td>xsd:string</td><td>A name identifying this grouping-handler</td><td> </td></tr><tr><td>
         <a class="link" href="#message-grouping.type">grouping-handler.type</a>
      </td><td>LOCAL|REMOTE</td><td>Each cluster should choose 1 node to have a LOCAL grouping handler and all the other nodes should have REMOTE handlers</td><td> </td></tr><tr><td>
         <a class="link" href="#message-grouping.address">grouping-handler.address</a>
      </td><td>xsd:string</td><td>A reference to a cluster connection address</td><td> </td></tr><tr><td>
         <a class="link" href="#message-grouping" title="Chapter 28. Message Grouping">grouping-handler.timeout</a>
      </td><td>xsd:int</td><td>How long to wait for a decision</td><td>5000 (ms)</td></tr><tr><td>
         <a class="link" href="#message-grouping" title="Chapter 28. Message Grouping">grouping-handler.group-timeout</a>
      </td><td>xsd:int</td><td>How long a group binding will be used, -1 means for ever. Bindings are removed after this wait elapses. Only valid for LOCAL handlers</td><td>-1 (ms)</td></tr><tr><td>
         <a class="link" href="#message-grouping" title="Chapter 28. Message Grouping">grouping-handler.reaper-period</a>
      </td><td>xsd:long</td><td>How often the reaper will be run to check for timed out group bindings. Only valid for LOCAL handlers</td><td>30000 (ms)</td></tr><tr><td>
         <a class="link" href="#duplicate.id.cache" title="37.2. Configuring the Duplicate ID Cache">id-cache-size</a>
      </td><td>xsd:int</td><td>the size of the cache for pre-creating message ID's</td><td>20000</td></tr><tr><td>
         <a class="link" href="#management.jmx.configuration" title="30.2.1. Configuring JMX">jmx-domain</a>
      </td><td>xsd:string</td><td>the JMX domain used to registered HornetQ MBeans in the MBeanServer</td><td>org.hornetq</td></tr><tr><td>
         <a class="link" href="#management.jmx.configuration" title="30.2.1. Configuring JMX">jmx-management-enabled</a>
      </td><td>xsd:boolean</td><td>true means that the management API is available via JMX</td><td>true</td></tr><tr><td>
         <a class="link" href="#configuring.message.journal.journal-buffer-size">journal-buffer-size</a>
      </td><td>xsd:long</td><td>The size of the internal buffer on the journal in KiB.</td><td>501760 (490 KiB)</td></tr><tr><td>
         <a class="link" href="#configuring.message.journal.journal-buffer-timeout">journal-buffer-timeout</a>
      </td><td>xsd:long</td><td>The timeout (in nanoseconds) used to flush internal buffers on the journal. The exact default value depend on whether the journal is ASYNCIO or NIO.</td><td> </td></tr><tr><td>
         <a class="link" href="#configuring.message.journal.journal-compact-min-files">journal-compact-min-files</a>
      </td><td>xsd:int</td><td>The minimal number of data files before we can start compacting</td><td>10</td></tr><tr><td>
         <a class="link" href="#configuring.message.journal.journal-compact-percentage">journal-compact-percentage</a>
      </td><td>xsd:int</td><td>The percentage of live data on which we consider compacting the journal</td><td>30</td></tr><tr><td>
         <a class="link" href="#configuring.message.journal.journal-directory">journal-directory</a>
      </td><td>xsd:string</td><td>the directory to store the journal files in</td><td>data/journal</td></tr><tr><td>
         <a class="link" href="#configuring.message.journal.journal-file-size">journal-file-size</a>
      </td><td>xsd:int</td><td>the size (in bytes) of each journal file</td><td>10485760 (10 * 1024 * 1024 - 10 MiB)</td></tr><tr><td>
         <a class="link" href="#configuring.message.journal.journal-max-io">journal-max-io</a>
      </td><td>xsd:int</td><td>the maximum number of write requests that can be in the AIO queue at any one time. Default is 500 for AIO and 1 for NIO.</td><td> </td></tr><tr><td>
         <a class="link" href="#configuring.message.journal.journal-min-files">journal-min-files</a>
      </td><td>xsd:int</td><td>how many journal files to pre-create</td><td>2</td></tr><tr><td>
         <a class="link" href="#configuring.message.journal.journal-sync-non-transactional">journal-sync-non-transactional</a>
      </td><td>xsd:boolean</td><td>if true wait for non transaction data to be synced to the journal before returning response to client.</td><td>true</td></tr><tr><td>
         <a class="link" href="#configuring.message.journal.journal-sync-transactional">journal-sync-transactional</a>
      </td><td>xsd:boolean</td><td>if true wait for transaction data to be synchronized to the journal before returning response to client</td><td>true</td></tr><tr><td>
         <a class="link" href="#configuring.message.journal.journal-type">journal-type</a>
      </td><td>ASYNCIO|NIO</td><td>the type of journal to use</td><td>ASYNCIO</td></tr><tr><td>
         <a class="link" href="#large.message.configuring" title="23.1. Configuring the server">large-messages-directory</a>
      </td><td>xsd:string</td><td>the directory to store large messages</td><td>data/largemessages</td></tr><tr><td>
         <a class="link" href="#">log-delegate-factory-class-name</a>
      </td><td>xsd:string</td><td>XXX</td><td> </td></tr><tr><td>
         <a class="link" href="#">log-journal-write-rate</a>
      </td><td>xsd:boolean</td><td>Whether to log messages about the journal write rate</td><td>false</td></tr><tr><td>
         <a class="link" href="#management.core.configuration" title="30.3.1. Configuring Core Management">management-address</a>
      </td><td>xsd:string</td><td>the name of the management address to send management messages to. It is prefixed with "jms.queue" so that JMS clients can send messages to it.</td><td>jms.queue.hornetq.management</td></tr><tr><td>
         <a class="link" href="#management.notifications.core.configuration" title="30.5.2.1. Configuring The Core Management Notification Address">management-notification-address</a>
      </td><td>xsd:string</td><td>the name of the address that consumers bind to receive management notifications</td><td>hornetq.notifications</td></tr><tr><td>
         <a class="link" href="#configuration.masked-password" title="50.1.3. Using Masked Passwords in Configuration Files">mask-password</a>
      </td><td>xsd:boolean</td><td>This option controls whether passwords in server configuration need be masked. If set to "true" the passwords are masked.</td><td>false</td></tr><tr><td>
         <a class="link" href="#">max-saved-replicated-journals-size</a>
      </td><td>xsd:int</td><td>This specifies how many times a replicated backup server can restart after moving its files on start. Once there are this number of backup journal files the server will stop permanently after if fails back.</td><td>2</td></tr><tr><td>
         <a class="link" href="#perf-tuning.memory">memory-measure-interval</a>
      </td><td>xsd:long</td><td>frequency to sample JVM memory in ms (or -1 to disable memory sampling)</td><td>-1 (ms)</td></tr><tr><td>
         <a class="link" href="#perf-tuning.memory">memory-warning-threshold</a>
      </td><td>xsd:int</td><td>Percentage of available memory which will trigger a warning log</td><td>25</td></tr><tr><td>
         <a class="link" href="#configuring.message.counters" title="30.6.1. Configuring Message Counters">message-counter-enabled</a>
      </td><td>xsd:boolean</td><td>true means that message counters are enabled</td><td>false</td></tr><tr><td>
         <a class="link" href="#configuring.message.counters" title="30.6.1. Configuring Message Counters">message-counter-max-day-history</a>
      </td><td>xsd:int</td><td>how many days to keep message counter history</td><td>10 (days)</td></tr><tr><td>
         <a class="link" href="#configuring.message.counters" title="30.6.1. Configuring Message Counters">message-counter-sample-period</a>
      </td><td>xsd:long</td><td>the sample period (in ms) to use for message counters</td><td>10000</td></tr><tr><td>
         <a class="link" href="#configuring.expiry.reaper" title="22.3. Configuring The Expiry Reaper Thread">message-expiry-scan-period</a>
      </td><td>xsd:long</td><td>how often (in ms) to scan for expired messages</td><td>30000</td></tr><tr><td>
         <a class="link" href="#configuring.expiry.reaper" title="22.3. Configuring The Expiry Reaper Thread">message-expiry-thread-priority</a>
      </td><td>xsd:int</td><td>the priority of the thread expiring messages</td><td>3</td></tr><tr><td>
         <a class="link" href="#">name</a>
      </td><td>xsd:string</td><td>Node name. If set, it will be used in topology notifications.</td><td> </td></tr><tr><td>
         <a class="link" href="#paging.mode" title="24.3. Paging Mode">page-max-concurrent-io</a>
      </td><td>xsd:int</td><td>The max number of concurrent reads allowed on paging</td><td>5</td></tr><tr><td>
         <a class="link" href="#paging.main.config" title="24.2. Configuration">paging-directory</a>
      </td><td>xsd:string</td><td>the directory to store paged messages in</td><td>data/paging</td></tr><tr><td>
         <a class="link" href="#configuration.masked-password" title="50.1.3. Using Masked Passwords in Configuration Files">password-codec</a>
      </td><td>xsd:string</td><td>Class name and its parameters for the Decoder used to decode the masked password. Ignored if mask-password is false. The format of this property is a full qualified class name optionally followed by key/value pairs.</td><td>org.hornetq.utils.DefaultSensitiveStringCodec</td></tr><tr><td>
         <a class="link" href="#">perf-blast-pages</a>
      </td><td>xsd:int</td><td>XXX Only meant to be used by project developers</td><td>-1</td></tr><tr><td>
         <a class="link" href="#configuring.delivery.count.persistence" title="21.3. Delivery Count Persistence">persist-delivery-count-before-delivery</a>
      </td><td>xsd:boolean</td><td>True means that the delivery count is persisted before delivery. False means that this only happens after a message has been cancelled.</td><td>false</td></tr><tr><td>
         <a class="link" href="#persistence.enabled" title="15.6. Configuring HornetQ for Zero Persistence">persistence-enabled</a>
      </td><td>xsd:boolean</td><td>true means that the server will use the file based journal for persistence.</td><td>true</td></tr><tr><td>
         <a class="link" href="#duplicate.id.cache" title="37.2. Configuring the Duplicate ID Cache">persist-id-cache</a>
      </td><td>xsd:boolean</td><td>true means that ID's are persisted to the journal</td><td>true</td></tr><tr><td>
         <a class="link" href="#predefined.queues" title="25.1. Predefined Queues">queues</a>
      </td><td>Sequence of &lt;queue/&gt;</td><td>a list of pre configured queues to create</td><td> </td></tr><tr><td>
         <a class="link" href="#predefined.queues" title="25.1. Predefined Queues">queues.queue</a>
      </td><td>Complex element</td><td> </td><td> </td></tr><tr><td>
         <a class="link" href="#predefined.queues" title="25.1. Predefined Queues">queues.queue.name (required attribute)</a>
      </td><td>xsd:ID</td><td>unique name of this queue</td><td> </td></tr><tr><td>
         <a class="link" href="#predefined.queues" title="25.1. Predefined Queues">queues.queue.address</a>
      </td><td>xsd:string</td><td>address for the queue</td><td> </td></tr><tr><td>
         <a class="link" href="#predefined.queues" title="25.1. Predefined Queues">queues.queue.filter</a>
      </td><td>Complex element</td><td> </td><td> </td></tr><tr><td>
         <a class="link" href="#predefined.queues" title="25.1. Predefined Queues">queues.queue.filter.string (required attribute)</a>
      </td><td>xsd:string</td><td>optional core filter expression</td><td> </td></tr><tr><td>
         <a class="link" href="#predefined.queues" title="25.1. Predefined Queues">queues.queue.durable</a>
      </td><td>xsd:boolean</td><td>whether the queue is durable (persistent)</td><td>true</td></tr><tr><td>
         <a class="link" href="#intercepting-operations" title="Chapter 47. Intercepting Operations">remoting-incoming-interceptors</a>
      </td><td>Complex element</td><td>a list of &lt;class-name/&gt; elements with the names of classes to use for interceptor incoming remoting packetsunlimited sequence of &lt;class-name/&gt;</td><td> </td></tr><tr><td>
         <a class="link" href="#intercepting-operations" title="Chapter 47. Intercepting Operations">remoting-incoming-interceptors.class-name</a>
      </td><td>xsd:string</td><td>the fully qualified name of the interceptor class</td><td> </td></tr><tr><td>
         <a class="link" href="#intercepting-operations" title="Chapter 47. Intercepting Operations">remoting-interceptors</a>
      </td><td>Complex element</td><td>DEPRECATED. This option is deprecated, but it will still be honored. Any interceptor specified here will be considered an "incoming" interceptor. See &lt;remoting-incoming-interceptors&gt; and &lt;remoting-outgoing-interceptors&gt;.unlimited sequence of &lt;class-name/&gt;</td><td> </td></tr><tr><td>
         <a class="link" href="#intercepting-operations" title="Chapter 47. Intercepting Operations">remoting-interceptors.class-name</a>
      </td><td>xsd:string</td><td>the fully qualified name of the interceptor class</td><td> </td></tr><tr><td>
         <a class="link" href="#intercepting-operations" title="Chapter 47. Intercepting Operations">remoting-outgoing-interceptors</a>
      </td><td>Complex element</td><td>a list of &lt;class-name/&gt; elements with the names of classes to use for interceptor outcoming remoting packetsunlimited sequence of &lt;class-name/&gt;</td><td> </td></tr><tr><td>
         <a class="link" href="#intercepting-operations" title="Chapter 47. Intercepting Operations">remoting-outgoing-interceptors.class-name</a>
      </td><td>xsd:string</td><td>the fully qualified name of the interceptor class</td><td> </td></tr><tr><td>
         <a class="link" href="#">replication-clustername</a>
      </td><td>xsd:string</td><td>Name of the cluster configuration to use for replication. This setting is only necessary in case you configure multiple cluster connections. It is used by a replicating backups and by live servers that may attempt fail-back.</td><td> </td></tr><tr><td>
         <a class="link" href="#">resolveProtocols</a>
      </td><td>xsd:boolean</td><td>If true then the HornetQ Server will make use of any Protocol Managers that are in available on the classpath. If false then only the core protocol will be available, unless in Embedded mode where users can inject their own Protocol Managers.</td><td>true</td></tr><tr><td>
         <a class="link" href="#">run-sync-speed-test</a>
      </td><td>xsd:boolean</td><td>XXX Only meant to be used by project developers</td><td>false</td></tr><tr><td>
         <a class="link" href="#server.scheduled.thread.pool" title="41.1.1. Server Scheduled Thread Pool">scheduled-thread-pool-max-size</a>
      </td><td>xsd:int</td><td>Maximum number of threads to use for the scheduled thread pool</td><td>5</td></tr><tr><td>
         <a class="link" href="#security" title="Chapter 31. Security">security-enabled</a>
      </td><td>xsd:boolean</td><td>true means that security is enabled</td><td>true</td></tr><tr><td>
         <a class="link" href="#security" title="Chapter 31. Security">security-invalidation-interval</a>
      </td><td>xsd:long</td><td>how long (in ms) to wait before invalidating the security cache</td><td>10000</td></tr><tr><td>
         <a class="link" href="#security.settings.roles" title="31.1. Role based security for addresses">security-settings</a>
      </td><td>Sequence of &lt;security-setting/&gt;</td><td>a list of security settings</td><td> </td></tr><tr><td>
         <a class="link" href="#security.settings.roles" title="31.1. Role based security for addresses">security-settings.security-setting</a>
      </td><td>Sequence of &lt;permission/&gt;</td><td> </td><td> </td></tr><tr><td>
         <a class="link" href="#security.settings.roles" title="31.1. Role based security for addresses">security-settings.security-setting.match (required attribute)</a>
      </td><td>xsd:string</td><td>regular expression for matching security roles against addresses</td><td> </td></tr><tr><td>
         <a class="link" href="#security.settings.roles" title="31.1. Role based security for addresses">security-settings.security-setting.permission</a>
      </td><td>Complex element</td><td> </td><td> </td></tr><tr><td>
         <a class="link" href="#security.settings.roles" title="31.1. Role based security for addresses">security-settings.security-setting.permission.type (required attribute)</a>
      </td><td>xsd:string</td><td>the type of permission</td><td> </td></tr><tr><td>
         <a class="link" href="#security.settings.roles" title="31.1. Role based security for addresses">security-settings.security-setting.permission.roles (required attribute)</a>
      </td><td>xsd:string</td><td>a comma-separated list of roles to apply the permission to</td><td> </td></tr><tr><td>
         <a class="link" href="#">server-dump-interval</a>
      </td><td>xsd:long</td><td>Interval to log server specific information (e.g. memory usage etc)</td><td>-1 (ms)</td></tr><tr><td>
         <a class="link" href="#ha.mode.shared" title="39.1.3. Shared Store">shared-store</a>
      </td><td>xsd:boolean</td><td>'shared-store' applies to live and backup pairs, and it indicates if the live/backup pair share storage or if the data is replicated among them.</td><td>true</td></tr><tr><td>
         <a class="link" href="#server.scheduled.thread.pool" title="41.1.1. Server Scheduled Thread Pool">thread-pool-max-size</a>
      </td><td>xsd:int</td><td>Maximum number of threads to use for the thread pool. -1 means 'no limits'.</td><td>30</td></tr><tr><td>
         <a class="link" href="#transaction-config" title="Chapter 18. Resource Manager Configuration">transaction-timeout</a>
      </td><td>xsd:long</td><td>how long (in ms) before a transaction can be removed from the resource manager after create time</td><td>300000</td></tr><tr><td>
         <a class="link" href="#transaction-config" title="Chapter 18. Resource Manager Configuration">transaction-timeout-scan-period</a>
      </td><td>xsd:long</td><td>how often (in ms) to scan for timeout transactions</td><td>1000</td></tr><tr><td>
         <a class="link" href="#wildcard-routing" title="Chapter 12. Routing Messages With Wild Cards">wild-card-routing-enabled</a>
      </td><td>xsd:boolean</td><td>true means that the server supports wild card routing</td><td>true</td></tr></tbody></table></div></div><br class="table-break"/></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e17285"/>50.1.2. hornetq-jms.xml</h3></div></div></div><p>This is the configuration file used by the server side JMS service to load JMS
                Queues, Topics and Connection Factories.</p><div class="table"><a id="d0e17290"/><p class="title"><b>Table 50.2. JMS Server Configuration</b></p><div class="table-contents"><table summary="JMS Server Configuration" border="1"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th>Element Name</th><th>Element Type</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td>
                               <a class="link" href="#using-jms.server.configuration" title="7.2. JMS Server Configuration">connection-factory</a>
                            </td><td>ConnectionFactory</td><td>a list of connection factories to create and add to JNDI</td><td> </td></tr></tbody></table></div></div><br class="table-break"/><p/><p/><p>Continued..</p><div class="informaltable"><table border="1"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><td><a id="configuration.connection-factory.signature"/>
                               <a class="link" href="#using-jms.configure.factory.types" title="7.3. Connection Factory Types">connection-factory.signature (attribute)</a>
                            </td><td>String</td><td>Type of connection factory</td><td>generic</td></tr><tr><td><a id="configuration.connection-factory.signature.xa"/>
                               <a class="link" href="#using-jms.configure.factory.types" title="7.3. Connection Factory Types">connection-factory.xa</a>
                            </td><td>Boolean</td><td>If it is a XA connection factory</td><td>false</td></tr><tr><td><a id="configuration.connection-factory.auto-group"/>
                               <a class="link" href="#message-grouping.jmsconfigure" title="28.2. Using JMS">connection-factory.auto-group</a>
                            </td><td>Boolean</td><td>whether or not message grouping is automatically used</td><td>false</td></tr><tr><td><a class="link" href="#clusters" title="Chapter 38. Clusters">connection-factory.connectors</a>
                            </td><td>String</td><td>A list of connectors used by the connection factory</td><td> </td></tr><tr><td><a class="link" href="#clusters" title="Chapter 38. Clusters">connection-factory.connectors.connector-ref.connector-name (attribute)</a>
                            </td><td>String</td><td>Name of the connector to connect to the live server</td><td> </td></tr><tr><td><a class="link" href="#clusters" title="Chapter 38. Clusters">connection-factory.discovery-group-ref.discovery-group-name (attribute)</a>
                            </td><td>String</td><td>Name of discovery group used by this connection factory</td><td> </td></tr><tr><td><a id="configuration.connection-factory.discovery-initial-wait-timeout"/>
                               <a class="link" href="#clusters" title="Chapter 38. Clusters">connection-factory.discovery-initial-wait-timeout</a>
                            </td><td>Long</td><td>the initial time to wait (in ms) for discovery groups to wait for
                                broadcasts</td><td>10000</td></tr><tr><td><a id="configuration.connection-factory.block-on-acknowledge"/>
                               <a class="link" href="#send-guarantees.nontrans.acks" title="20.3. Guarantees of Non Transactional Acknowledgements">connection-factory.block-on-acknowledge</a>
                            </td><td>Boolean</td><td>whether or not messages are acknowledged synchronously</td><td>false</td></tr><tr><td><a id="configuration.connection-factory.block-on-non-durable-send"/>
                               <a class="link" href="#non-transactional-sends" title="20.2. Guarantees of Non Transactional Message Sends">connection-factory.block-on-non-durable-send</a>
                            </td><td>Boolean</td><td>whether or not non-durable messages are sent synchronously</td><td>false</td></tr><tr><td><a id="configuration.connection-factory.block-on-durable-send"/>
                               <a class="link" href="#non-transactional-sends" title="20.2. Guarantees of Non Transactional Message Sends">connection-factory.block-on-durable-send</a>
                            </td><td>Boolean</td><td>whether or not durable messages are sent synchronously</td><td>true</td></tr><tr><td><a id="configuration.connection-factory.call-timeout"/>connection-factory.call-timeout</td><td>Long</td><td>the timeout (in ms) for remote calls</td><td>30000</td></tr><tr><td><a id="configuration.connection-factory.client-failure-check-period"/>
                               <a class="link" href="#dead.connections" title="17.1. Cleaning up Dead Connection Resources on the Server">connection-factory.client-failure-check-period</a>
                            </td><td>Long</td><td>the period (in ms) after which the client will consider the
                                connection failed after not receiving packets from the
                                server</td><td>30000</td></tr><tr><td><a id="configuration.connection-factory.client-id"/>
                               <a class="link" href="#using-jms.clientid" title="7.7. Setting The Client ID">connection-factory.client-id</a>
                            </td><td>String</td><td>the pre-configured client ID for the connection factory</td><td>null</td></tr><tr><td><a id="configuration.connection-factory.connection-load-balancing-policy-class-name"/>
                               <a class="link" href="#clusters" title="Chapter 38. Clusters">
                                  connection-factory.connection-load-balancing-policy-class-name</a>
                            </td><td>String</td><td>the name of the load balancing class</td><td>org.hornetq.api.core.client.loadbalance.RoundRobinConnectionLoadBalancingPolicy</td></tr><tr><td><a id="configuration.connection-factory.connection-ttl"/>
                               <a class="link" href="#dead.connections" title="17.1. Cleaning up Dead Connection Resources on the Server">connection-factory.connection-ttl</a>
                            </td><td>Long</td><td>the time to live (in ms) for connections</td><td>1 * 60000</td></tr><tr><td><a id="configuration.connection-factory.consumer-max-rate"/>
                               <a class="link" href="#flow-control.rate.core.api" title="19.1.2.1. Using Core API">connection-factory.consumer-max-rate</a></td><td>Integer</td><td>the fastest rate a consumer may consume messages per
                                second</td><td>-1</td></tr><tr><td><a id="configuration.connection-factory.consumer-window-size"/>
                               <a class="link" href="#flow-control.core.api" title="19.1.1.1. Using Core API">connection-factory.consumer-window-size</a></td><td>Integer</td><td>the window size (in bytes) for consumer flow control</td><td>1024 * 1024</td></tr><tr><td><a id="configuration.connection-factory.dups-ok-batch-size"/>
                               <a class="link" href="#using-jms.dupsokbatchsize" title="7.8. Setting The Batch Size for DUPS_OK">connection-factory.dups-ok-batch-size</a></td><td>Integer</td><td>the batch size (in bytes) between acknowledgements when using
                                DUPS_OK_ACKNOWLEDGE mode</td><td>1024 * 1024</td></tr><tr><td><a class="link" href="#ha.automatic.failover" title="39.2.1. Automatic Client Failover">connection-factory.failover-on-initial-connection</a></td><td>Boolean</td><td>whether or not to failover to backup on event that initial connection to live server fails</td><td>false</td></tr><tr><td><a id="configuration.connection-factory.failover-on-server-shutdown"/>
                               <a class="link" href="#ha.automatic.failover" title="39.2.1. Automatic Client Failover">connection-factory.failover-on-server-shutdown</a></td><td>Boolean</td><td>whether or not to failover on server shutdown</td><td>false</td></tr><tr><td><a id="configuration.connection-factory.min-large-message-size"/>
                               <a class="link" href="#large-messages.core.config" title="23.2.1. Using Core API">connection-factory.min-large-message-size</a></td><td>Integer</td><td>the size (in bytes) before a message is treated as large</td><td>100 * 1024</td></tr><tr><td><a id="configuration.connection-factory.avoid-large-messages"/>
                               <a class="link" href="#large.message.configuring" title="23.1. Configuring the server">connection-factory.avoid-large-messages</a></td><td>Boolean</td><td>If compress large messages and send them as regular messages if possible</td><td>false</td></tr><tr><td><a class="link" href="#clusters" title="Chapter 38. Clusters">connection-factory.cache-large-message-client</a></td><td>Boolean</td><td>If true clients using this connection factory will hold the large
                                message body on temporary files.</td><td>false</td></tr><tr><td><a id="configuration.connection-factory.pre-acknowledge"/>
                               <a class="link" href="#pre-acknowledge.configure" title="29.1. Using PRE_ACKNOWLEDGE">connection-factory.pre-acknowledge</a></td><td>Boolean</td><td>whether messages are pre acknowledged by the server before
                                sending</td><td>false</td></tr><tr><td><a id="configuration.connection-factory.producer-max-rate"/>
                               <a class="link" href="#flow-control.producer.rate.core.api" title="19.2.2.1. Using Core API">connection-factory.producer-max-rate</a></td><td>Integer</td><td>the maximum rate of messages per second that can be sent</td><td>-1</td></tr><tr><td><a class="link" href="#client-reconnection" title="Chapter 34. Client Reconnection and Session Reattachment">connection-factory.producer-window-size</a></td><td>Integer</td><td>the window size in bytes for producers sending messages</td><td>1024 * 1024</td></tr><tr><td><a id="configuration.connection-factory.confirmation-window-size"/>
                               <a class="link" href="#client-reconnection" title="Chapter 34. Client Reconnection and Session Reattachment">connection-factory.confirmation-window-size</a>
                            </td><td>Integer</td><td>the window size (in bytes) for reattachment confirmations</td><td>1024 * 1024</td></tr><tr><td><a id="configuration.connection-factory.reconnect-attempts"/>
                               <a class="link" href="#client-reconnection" title="Chapter 34. Client Reconnection and Session Reattachment">connection-factory.reconnect-attempts</a>
                            </td><td>Integer</td><td>maximum number of retry attempts, -1 signifies infinite</td><td>0</td></tr><tr><td><a id="configuration.connection-factory.retry-interval"/>
                               <a class="link" href="#client-reconnection" title="Chapter 34. Client Reconnection and Session Reattachment">connection-factory.retry-interval</a>
                            </td><td>Long</td><td>the time (in ms) to retry a connection after failing</td><td>2000</td></tr><tr><td><a id="configuration.connection-factory.retry-interval-multiplier"/>
                               <a class="link" href="#client-reconnection" title="Chapter 34. Client Reconnection and Session Reattachment">connection-factory.retry-interval-multiplier</a>
                            </td><td>Double</td><td>multiplier to apply to successive retry intervals</td><td>1.0</td></tr><tr><td><a class="link" href="#client-reconnection" title="Chapter 34. Client Reconnection and Session Reattachment">connection-factory.max-retry-interval</a></td><td>Integer</td><td>The maximum retry interval in the case a retry-interval-multiplier has been specified</td><td>2000</td></tr><tr><td><a id="configuration.connection-factory.scheduled-thread-pool-max-size"/>
                               <a class="link" href="#thread-pooling.client.side" title="41.2. Client-Side Thread Management">connection-factory.scheduled-thread-pool-max-size</a>
                            </td><td>Integer</td><td>the size of the <span class="emphasis"><em>scheduled thread</em></span> pool</td><td>5</td></tr><tr><td><a id="configuration.connection-factory.thread-pool-max-size"/>
                               <a class="link" href="#thread-pooling.client.side" title="41.2. Client-Side Thread Management">connection-factory.thread-pool-max-size</a>
                            </td><td>Integer</td><td>the size of the thread pool</td><td>-1</td></tr><tr><td><a id="configuration.connection-factory.transaction-batch-size"/>
                               <a class="link" href="#using-jms.txbatchsize" title="7.9. Setting The Transaction Batch Size">
                                  connection-factory.transaction-batch-size</a>
                            </td><td>Integer</td><td>the batch size (in bytes) between acknowledgements when using a
                                transactional session</td><td>1024 * 1024</td></tr><tr><td><a id="configuration.connection-factory.use-global-pools"/>
                               <a class="link" href="#thread-pooling.client.side" title="41.2. Client-Side Thread Management">connection-factory.use-global-pools</a>
                            </td><td>Boolean</td><td>whether or not to use a global thread pool for threads</td><td>true</td></tr><tr><td><a class="link" href="#using-jms.server.configuration" title="7.2. JMS Server Configuration">queue</a></td><td>Queue</td><td>a queue to create and add to JNDI</td><td> </td></tr><tr><td><a class="link" href="#using-jms.server.configuration" title="7.2. JMS Server Configuration">queue.name
                                    (attribute)</a></td><td>String</td><td>unique name of the queue</td><td> </td></tr><tr><td><a class="link" href="#using-jms.server.configuration" title="7.2. JMS Server Configuration">queue.entry</a></td><td>String</td><td>context where the queue will be bound in JNDI (there can be
                                many)</td><td> </td></tr><tr><td><a class="link" href="#using-jms.server.configuration" title="7.2. JMS Server Configuration">queue.durable</a></td><td>Boolean</td><td>is the queue durable?</td><td>true</td></tr><tr><td><a class="link" href="#using-jms.server.configuration" title="7.2. JMS Server Configuration">queue.filter</a></td><td>String</td><td>optional filter expression for the queue</td><td> </td></tr><tr><td><a class="link" href="#using-jms.server.configuration" title="7.2. JMS Server Configuration">topic</a></td><td>Topic</td><td>a topic to create and add to JNDI</td><td> </td></tr><tr><td><a class="link" href="#using-jms.server.configuration" title="7.2. JMS Server Configuration">topic.name
                                    (attribute)</a></td><td>String</td><td>unique name of the topic</td><td> </td></tr><tr><td><a class="link" href="#using-jms.server.configuration" title="7.2. JMS Server Configuration">topic.entry</a></td><td>String</td><td>context where the topic will be bound in JNDI (there can be
                                many)</td><td> </td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="configuration.masked-password"/>50.1.3. Using Masked Passwords in Configuration Files</h3></div></div></div><p>By default all passwords in HornetQ server's configuration files are in plain text form. This usually poses no security issues as those
           files should be well protected from unauthorized accessing. However, in some circumstances a user doesn't want to expose its passwords to more
           eyes than necessary. </p><p>HornetQ can be configured to use 'masked' passwords in its configuration files. A masked password is an obscure string representation
           of a real password. To mask a password a user will use an 'encoder'. The encoder takes in the real password and outputs the masked version.
           A user can then replace the real password in the configuration files with the new masked password.
           When HornetQ loads a masked password, it uses a suitable 'decoder' to decode it into real password.</p><p>HornetQ provides a default password encoder and decoder. Optionally users can use or implement their own encoder and decoder for
           masking the passwords.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e17812"/>50.1.3.1. Password Masking in Server Configuration File</h4></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="d0e17815"/>50.1.3.1.1. The password masking property</h5></div></div></div><p>The server configuration file has a property that defines the default masking behaviors over the entire file scope.</p><p><code class="literal">mask-password</code>: this boolean type property indicates if a password should be masked or not. Set it to "true"
              if you want your passwords masked. The default value is "false".</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="d0e17824"/>50.1.3.1.2. Specific masking behaviors</h5></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a id="d0e17827"/>50.1.3.1.2.1. cluster-password</h6></div></div></div><p>The nature of the value of cluster-password is subject to the value of property 'mask-password'. If it is true
                 the cluster-password is masked.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a id="d0e17832"/>50.1.3.1.2.2. Passwords in connectors and acceptors</h6></div></div></div><p>In the server configuration, Connectors and Acceptors sometimes needs to specify passwords. For example
                 if a users wants to use an SSL-enabled NettyAcceptor, it can specify a key-store-password and a trust-store-password. Because
                 Acceptors and Connectors are pluggable implementations, each transport will have different password masking needs.</p><p>When a Connector or Acceptor configuration is initialised, HornetQ will add the "mask-password" and
                 "password-codec" values to the Connector or Acceptors params using the keys <code class="literal">hornetq.usemaskedpassword</code>
                 and <code class="literal">hornetq.passwordcodec</code> respectively. The Netty and InVM implementations will use these
                 as needed and any other implementations will have access to these to use if they so wish.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a id="d0e17845"/>50.1.3.1.2.3. Passwords in Core Bridge configurations</h6></div></div></div><p>Core Bridges are configured in the server configuration file and so the masking of its 'password' properties
                 follows the same rules as that of 'cluster-password'.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="d0e17850"/>50.1.3.1.3. Examples</h5></div></div></div><p>The following table summarizes the relations among the above-mentioned properties</p><div class="table"><a id="d0e17855"/><p class="title"><b>Table 50.3. </b></p><div class="table-contents"><table border="1"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th>mask-password</th><th>cluster-password</th><th>acceptor/connector passwords</th><th>bridge password</th></tr></thead><tbody><tr><td>absent</td><td>plain text</td><td>plain text</td><td>plain text</td></tr><tr><td>false</td><td>plain text</td><td>plain text</td><td>plain text</td></tr><tr><td>true</td><td>masked</td><td>masked</td><td>masked</td></tr></tbody></table></div></div><br class="table-break"/><p>Examples</p><p>Note: In the following examples if related attributed or properties are absent, it means they are not specified in the configure file.</p><p>example 1</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;cluster-password&gt;bbc&lt;/cluster-password&gt;</pre><p>This indicates the cluster password is a plain text value ("bbc").</p><p>example 2</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;mask-password&gt;true&lt;/mask-password&gt;
&lt;cluster-password&gt;80cf731af62c290&lt;/cluster-password&gt;</pre><p>This indicates the cluster password is a masked value and HornetQ will use its built-in decoder to decode it. All other
              passwords in the configuration file, Connectors, Acceptors and Bridges, will also use masked passwords.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e17915"/>50.1.3.2. JMS Bridge password masking</h4></div></div></div><p>The JMS Bridges are configured and deployed as separate beans so they need separate configuration to control the password masking.
           A JMS Bridge has two password parameters in its constructor, SourcePassword and TargetPassword. It uses the following two optional
           properties to control their masking:</p><p><code class="literal">useMaskedPassword</code> -- If set to "true" the passwords are masked. Default is false.</p><p><code class="literal">passwordCodec</code> -- Class name and its parameters for the Decoder used to decode the masked password. Ignored if
           <code class="literal">useMaskedPassword</code> is false. The format of this property is a full qualified class name optionally followed by key/value pairs,
           separated by semi-colons. For example:</p><code class="literal">
&lt;property name="useMaskedPassword"&gt;true&lt;/property&gt;
</code><p/><code class="literal">
&lt;property name="passwordCodec"&gt;com.foo.FooDecoder;key=value&lt;/property&gt;
</code><p>HornetQ will load this property and initialize the class with a parameter map containing the "key"-&gt;"value" pair.
           If <code class="literal">passwordCodec</code> is not specified, the built-in decoder is used.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e17941"/>50.1.3.3. Masking passwords in HornetQ ResourceAdapters and MDB activation configurations</h4></div></div></div><p>Both ra.xml and MDB activation configuration have a 'password' property that can be masked. They are controlled by the following two
           optional Resource Adapter properties in ra.xml:</p><p><code class="literal">UseMaskedPassword</code> -- If setting to "true" the passwords are masked. Default is false.</p><p><code class="literal">PasswordCodec</code> -- Class name and its parameters for the Decoder used to decode the masked password.
              Ignored if UseMaskedPassword is false. The format of this property is a full qualified class name optionally followed by key/value pairs.
              It is the same format as that for JMS Bridges. Example:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;config-property&gt;
  &lt;config-property-name&gt;UseMaskedPassword&lt;/config-property-name&gt;
  &lt;config-property-type&gt;boolean&lt;/config-property-type&gt;
  &lt;config-property-value&gt;true&lt;/config-property-value&gt;
&lt;/config-property&gt;
&lt;config-property&gt;
  &lt;config-property-name&gt;PasswordCodec&lt;/config-property-name&gt;
  &lt;config-property-type&gt;java.lang.String&lt;/config-property-type&gt;
  &lt;config-property-value&gt;com.foo.ADecoder;key=helloworld&lt;/config-property-value&gt;
&lt;/config-property&gt;</pre><p>With this configuration, both passwords in ra.xml and all of its MDBs will have to be in masked form.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e17958"/>50.1.3.4. Masking passwords in hornetq-users.xml</h4></div></div></div><p>HornetQ's built-in security manager uses plain configuration files where the user passwords are specified in plaintext
           forms by default. To mask those parameters the following two properties are needed:</p><p> <code class="literal">mask-password</code> -- If set to "true" all the passwords are masked. Default is false.</p><p> <code class="literal">password-codec</code> -- Class name and its parameters for the Decoder used to decode the masked password.
           Ignored if <code class="literal">mask-password</code> is false. The format of this property is a full qualified class name optionally
           followed by key/value pairs. It is the same format as that for JMS Bridges. Example:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;mask-password&gt;true&lt;/mask-password&gt;
&lt;password-codec&gt;org.hornetq.utils.DefaultSensitiveStringCodec;key=hello world&lt;/password-codec&gt;</pre><p>When so configured, the HornetQ security manager will initialize a DefaultSensitiveStringCodec with the parameters
           "key"-&gt;"hello world", then use it to decode all the masked passwords in this configuration file.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e17980"/>50.1.3.5. Choosing a decoder for password masking</h4></div></div></div><p>As described in the previous sections, all password masking requires a decoder. A decoder uses an algorithm to
           convert a masked password into its original clear text form in order to be used in various security operations. The algorithm
           used for decoding must match that for encoding. Otherwise the decoding may not be successful.</p><p>For user's convenience HornetQ provides a default built-in Decoder. However a user can if they so wish implement their own.</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="d0e17987"/>50.1.3.5.1. The built-in Decoder</h5></div></div></div><p>Whenever no decoder is specified in the configuration file, the built-in decoder is used. The class name for the built-in
              decoder is org.hornetq.utils.DefaultSensitiveStringCodec. It has both encoding and decoding capabilities. It uses java.crypto.Cipher
              utilities to encrypt (encode) a plaintext password and decrypt a mask string using same algorithm. Using this decoder/encoder is
              pretty straightforward. To get a mask for a password, just run the following in command line:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
java org.hornetq.utils.DefaultSensitiveStringCodec "your plaintext password"</pre><p>Make sure the classpath is correct. You'll get something like</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
Encoded password: 80cf731af62c290</pre><p>Just copy "80cf731af62c290" and replace your plaintext password with it.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="d0e18000"/>50.1.3.5.2. Using a different decoder</h5></div></div></div><p>It is possible to use a different decoder rather than the built-in one. Simply make sure the decoder
              is in HornetQ's classpath and configure the server to use it as follows:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;password-codec&gt;com.foo.SomeDecoder;key1=value1;key2=value2&lt;/password-codec&gt;</pre><p>If your decoder needs params passed to it you can do this via key/value pairs when configuring.
              For instance if your decoder needs say a "key-location" parameter, you can define like so:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;password-codec&gt;com.foo.NewDecoder;key-location=/some/url/to/keyfile&lt;/password-codec&gt;</pre><p>Then configure your cluster-password like this:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;mask-password&gt;true&lt;/mask-password&gt;
&lt;cluster-password&gt;masked_password&lt;/cluster-password&gt;</pre><p>When HornetQ reads the cluster-password it will initialize the NewDecoder and use it to decode "mask_password".
              It also process all passwords using the new defined decoder.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a id="d0e18017"/>50.1.3.5.3. Implementing your own codecs</h5></div></div></div><p>To use a different decoder than the built-in one, you either pick one from existing libraries or you implement it yourself.
              All decoders must implement the <code class="literal">org.hornetq.utils.SensitiveDataCodec&lt;T&gt;</code> interface:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
public interface SensitiveDataCodec&lt;T&gt;
{
   T decode(Object mask) throws Exception;

   void init(Map&lt;String, String&gt; params);
}</pre><p>This is a generic type interface but normally for a password you just need String type.
                  So a new decoder would be defined like </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
public class MyNewDecoder implements SensitiveDataCodec&lt;String&gt;
{
   public String decode(Object mask) throws Exception
   {
      //decode the mask into clear text password
      return "the password";
   }

   public void init(Map&lt;String, String&gt; params)
   {
      //initialization done here. It is called right after the decoder has been created.
   }
}</pre><p>Last but not least, once you get your own decoder, please add it to the classpath. Otherwise HornetQ will
             fail to load it!</p></div></div></div></div></div></div></body></html>