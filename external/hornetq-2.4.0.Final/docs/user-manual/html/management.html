<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Chapter 30. Management</title><link rel="stylesheet" href="css/jbossorg.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" http-equiv="Content-Type" content="text/html; charset=UTF-8"/><link rel="home" href="index.html" title="HornetQ User Manual"/><link rel="up" href="index.html" title="HornetQ User Manual"/><link rel="prev" href="pre-acknowledge.html" title="Chapter 29. Extra Acknowledge Modes"/><link rel="next" href="security.html" title="Chapter 31. Security"/></head><body><p id="title"><a href="http://www.jboss.org" class="site_href"><strong>JBoss.org</strong></a><a href="http://docs.jboss.org/" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="pre-acknowledge.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="security.html"><strong>Next</strong></a></li></ul><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="management"/>Chapter 30. Management</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="management.html#d0e5969">30.1. The Management API</a></span></dt><dd><dl><dt><span class="section"><a href="management.html#d0e6018">30.1.1. Core Management API</a></span></dt><dt><span class="section"><a href="management.html#d0e6509">30.1.2. JMS Management API</a></span></dt></dl></dd><dt><span class="section"><a href="management.html#management.jmx">30.2. Using Management Via JMX</a></span></dt><dd><dl><dt><span class="section"><a href="management.html#management.jmx.configuration">30.2.1. Configuring JMX</a></span></dt><dt><span class="section"><a href="management.html#d0e6927">30.2.2. Example</a></span></dt></dl></dd><dt><span class="section"><a href="management.html#d0e6934">30.3. Using Management Via Core API</a></span></dt><dd><dl><dt><span class="section"><a href="management.html#management.core.configuration">30.3.1. Configuring Core Management</a></span></dt></dl></dd><dt><span class="section"><a href="management.html#management.jms">30.4. Using Management Via JMS</a></span></dt><dd><dl><dt><span class="section"><a href="management.html#d0e7112">30.4.1. Configuring JMS Management</a></span></dt><dt><span class="section"><a href="management.html#d0e7119">30.4.2. Example</a></span></dt></dl></dd><dt><span class="section"><a href="management.html#management.notifications">30.5. Management Notifications</a></span></dt><dd><dl><dt><span class="section"><a href="management.html#d0e7146">30.5.1. JMX Notifications</a></span></dt><dt><span class="section"><a href="management.html#d0e7170">30.5.2. Core Messages Notifications</a></span></dt><dt><span class="section"><a href="management.html#d0e7199">30.5.3. JMS Messages Notifications</a></span></dt><dt><span class="section"><a href="management.html#d0e7223">30.5.4. Example</a></span></dt><dt><span class="section"><a href="management.html#d0e7233">30.5.5. Notification Types and Headers</a></span></dt></dl></dd><dt><span class="section"><a href="management.html#management.message-counters">30.6. Message Counters</a></span></dt><dd><dl><dt><span class="section"><a href="management.html#configuring.message.counters">30.6.1. Configuring Message Counters</a></span></dt><dt><span class="section"><a href="management.html#d0e7638">30.6.2. Example</a></span></dt></dl></dd><dt><span class="section"><a href="management.html#d0e7648">30.7. Administering HornetQ Resources Using The JBoss AS Admin Console</a></span></dt><dd><dl><dt><span class="section"><a href="management.html#d0e7657">30.7.1. JMS Queues</a></span></dt><dt><span class="section"><a href="management.html#d0e7681">30.7.2. JMS Topics</a></span></dt><dt><span class="section"><a href="management.html#d0e7686">30.7.3. JMS Connection Factories</a></span></dt></dl></dd></dl></div><p>HornetQ has an extensive management API that allows a user to modify a server
      configuration, create new resources (e.g. JMS queues and topics), inspect these resources
      (e.g. how many messages are currently held in a queue) and interact with it (e.g. to remove
      messages from a queue). All the operations allows a client to <span class="emphasis"><em>manage</em></span>
      HornetQ. It also allows clients to subscribe to management notifications.</p><p>There are 3 ways to manage HornetQ:</p><div class="itemizedlist"><ul><li><p>Using JMX -- JMX is the standard way to manage Java applications</p></li><li><p>Using the core API -- management operations are sent to HornetQ server using
               <span class="emphasis"><em>core messages</em></span></p></li><li><p>Using the JMS API -- management operations are sent to HornetQ server using
               <span class="emphasis"><em>JMS messages</em></span></p></li></ul></div><p>Although there are 3 different ways to manage HornetQ each API supports the same
      functionality. If it is possible to manage a resource using JMX it is also possible to achieve
      the same result using Core messages or JMS messages.</p><p>This choice depends on your requirements, your application settings and your environment to
      decide which way suits you best.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e5969"/>30.1. The Management API</h2></div></div></div><p>Regardless of the way you <span class="emphasis"><em>invoke</em></span> management operations, the
         management API is the same.</p><p>For each <span class="emphasis"><em>managed resource</em></span>, there exists a Java interface describing
         what can be invoked for this type of resource.</p><p>HornetQ exposes its managed resources in 2 packages:</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Core</em></span> resources are located in the <code class="literal">org.hornetq.api.core.management</code> package</p></li><li><p><span class="emphasis"><em>JMS</em></span> resources are located in the <code class="literal">org.hornetq.api.jms.management</code> package</p></li></ul></div><p>The way to invoke a <span class="emphasis"><em>management operations</em></span> depends whether JMX, core
         messages, or JMS messages are used.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>A few management operations requires a <code class="literal">filter</code> parameter to chose
            which messages are involved by the operation. Passing <code class="literal">null</code> or an
            empty string means that the management operation will be performed on <span class="emphasis"><em>all
               messages</em></span>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6018"/>30.1.1. Core Management API</h3></div></div></div><p>HornetQ defines a core management API to manage core resources. For full details of
            the API please consult the javadoc. In summary:</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="management.core.server"/>30.1.1.1. Core Server Management</h4></div></div></div><div class="itemizedlist"><ul><li><p>Listing, creating, deploying and destroying queues</p><p>A list of deployed core queues can be retrieved using the <code class="literal">getQueueNames()</code> method.</p><p>Core queues can be created or destroyed using the management operations
                        <code class="literal">createQueue()</code> or <code class="literal">deployQueue()</code> or
                        <code class="literal">destroyQueue()</code>)on the <code class="literal">HornetQServerControl</code> (with the ObjectName <code class="literal">org.hornetq:module=Core,type=Server</code> or the resource name <code class="literal">core.server</code>)</p><p><code class="literal">createQueue</code> will fail if the queue already exists while
                        <code class="literal">deployQueue</code> will do nothing.</p></li><li><p>Pausing and resuming Queues</p><p>The <code class="literal">QueueControl</code> can pause and resume the underlying
                     queue. When a queue is paused, it will receive messages but will not deliver
                     them. When it's resumed, it'll begin delivering the queued messages, if any.
                  </p></li><li><p>Listing and closing remote connections</p><p>Client's remote addresses can be retrieved using <code class="literal">listRemoteAddresses()</code>. It is also possible to close the
                     connections associated with a remote address using the <code class="literal">closeConnectionsForAddress()</code> method.</p><p>Alternatively, connection IDs can be listed using <code class="literal">listConnectionIDs()</code> and all the sessions for a given connection
                     ID can be listed using <code class="literal">listSessions()</code>.</p></li><li><p>Transaction heuristic operations</p><p>In case of a server crash, when the server restarts, it it possible that
                     some transaction requires manual intervention. The <code class="literal">listPreparedTransactions()</code> method lists the transactions which
                     are in the prepared states (the transactions are represented as opaque Base64
                     Strings.) To commit or rollback a given prepared transaction, the <code class="literal">commitPreparedTransaction()</code> or <code class="literal">rollbackPreparedTransaction()</code> method can be used to resolve
                     heuristic transactions. Heuristically completed transactions can be listed
                     using the <code class="literal">listHeuristicCommittedTransactions()</code> and <code class="literal">listHeuristicRolledBackTransactions</code> methods.</p></li><li><p>Enabling and resetting Message counters</p><p>Message counters can be enabled or disabled using the <code class="literal">enableMessageCounters()</code> or <code class="literal">disableMessageCounters()</code> method. To reset message counters, it is
                     possible to invoke <code class="literal">resetAllMessageCounters()</code> and <code class="literal">resetAllMessageCounterHistories()</code> methods.</p></li><li><p>Retrieving the server configuration and attributes</p><p>The <code class="literal">HornetQServerControl</code> exposes HornetQ server
                     configuration through all its attributes (e.g. <code class="literal">getVersion()</code>
                     method to retrieve the server's version, etc.)</p></li><li><p>Listing, creating and destroying Core bridges and diverts</p><p>A list of deployed core bridges (resp. diverts) can be retrieved using the <code class="literal">getBridgeNames()</code> (resp. <code class="literal">getDivertNames()</code>) method.</p><p>Core bridges (resp. diverts) can be created or destroyed using the management operations
                        <code class="literal">createBridge()</code> and <code class="literal">destroyBridge()</code> 
                        (resp. <code class="literal">createDivert()</code> and <code class="literal">destroyDivert()</code>) on the <code class="literal">HornetQServerControl</code> (with the ObjectName <code class="literal">org.hornetq:module=Core,type=Server</code> or the resource name <code class="literal">core.server</code>).</p></li><li><p>It is possible to stop the server and force failover to occur with any currently attached clients.</p><p>to do this use the <code class="literal">forceFailover()</code> on the <code class="literal">HornetQServerControl</code> (with the ObjectName <code class="literal">org.hornetq:module=Core,type=Server</code> or the resource name <code class="literal">core.server</code>) </p><p>
                       </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2>Since this method actually stops the server you will probably receive some sort of error
                       depending on which management service you use to call it.</div><p>
                   </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6193"/>30.1.1.2. Core Address Management</h4></div></div></div><p>Core addresses can be managed using the <code class="literal">AddressControl</code> class
               (with the ObjectName <code class="literal">org.hornetq:module=Core,type=Address,name="&lt;the
                  address name&gt;"</code> or the resource name <code class="literal">core.address.&lt;the
                  address name&gt;</code>). </p><div class="itemizedlist"><ul><li><p>Modifying roles and permissions for an address</p><p>You can add or remove roles associated to a queue using the <code class="literal">addRole()</code> or <code class="literal">removeRole()</code> methods. You can
                     list all the roles associated to the queue with the <code class="literal">getRoles()</code> method</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6222"/>30.1.1.3. Core Queue Management</h4></div></div></div><p>The bulk of the core management API deals with core queues. The <code class="literal">QueueControl</code> class defines the Core queue management operations (with
               the ObjectName <code class="literal">org.hornetq:module=Core,type=Queue,address="&lt;the bound
                  address&gt;",name="&lt;the queue name&gt;"</code> or the resource name <code class="literal">core.queue.&lt;the queue name&gt;</code>).</p><p>Most of the management operations on queues take either a single message ID (e.g.
               to remove a single message) or a filter (e.g. to expire all messages with a given
               property.)</p><div class="itemizedlist"><ul><li><p>Expiring, sending to a dead letter address and moving messages</p><p>Messages can be expired from a queue by using the <code class="literal">expireMessages()</code> method. If an expiry address is defined,
                     messages will be sent to it, otherwise they are discarded. The queue's
                     expiry address can be set with the <code class="literal">setExpiryAddress()</code>
                     method.</p><p>Messages can also be sent to a dead letter address with the <code class="literal">sendMessagesToDeadLetterAddress()</code> method. It returns the number
                     of messages which are sent to the dead letter address. If a dead letter address
                     is not defined, message are removed from the queue and discarded. The queue's
                     dead letter address can be set with the <code class="literal">setDeadLetterAddress()</code> method.</p><p>Messages can also be moved from a queue to another queue by using the
                        <code class="literal">moveMessages()</code> method.</p></li><li><p>Listing and removing messages</p><p>Messages can be listed from a queue by using the <code class="literal">listMessages()</code> method which returns an array of <code class="literal">Map</code>, one <code class="literal">Map</code> for each message.</p><p>Messages can also be removed from the queue by using the <code class="literal">removeMessages()</code> method which returns a <code class="literal">boolean</code> for the single message ID variant or the number of
                     removed messages for the filter variant. The <code class="literal">removeMessages()</code> method takes a <code class="literal">filter</code>
                     argument to remove only filtered messages. Setting the filter to an empty
                     string will in effect remove all messages.</p></li><li><p>Counting messages</p><p>The number of messages in a queue is returned by the <code class="literal">getMessageCount()</code> method. Alternatively, the <code class="literal">countMessages()</code> will return the number of messages in the queue
                     which <span class="emphasis"><em>match a given filter</em></span></p></li><li><p>Changing message priority</p><p>The message priority can be changed by using the <code class="literal">changeMessagesPriority()</code> method which returns a <code class="literal">boolean</code> for the single message ID variant or the number of
                     updated messages for the filter variant.</p></li><li><p>Message counters</p><p>Message counters can be listed for a queue with the <code class="literal">listMessageCounter()</code> and <code class="literal">listMessageCounterHistory()</code> methods (see <a class="xref" href="management.html#management.message-counters" title="30.6. Message Counters">Section 30.6, “Message Counters”</a>). The message counters can also be
                     reset for a single queue using the <code class="literal">resetMessageCounter()</code>
                     method.</p></li><li><p>Retrieving the queue attributes</p><p>The <code class="literal">QueueControl</code> exposes Core queue settings through its
                     attributes (e.g. <code class="literal">getFilter()</code> to retrieve the queue's filter
                     if it was created with one, <code class="literal">isDurable()</code> to know whether the
                     queue is durable or not, etc.)</p></li><li><p>Pausing and resuming Queues</p><p>The <code class="literal">QueueControl</code> can pause and resume the underlying
                     queue. When a queue is paused, it will receive messages but will not deliver
                     them. When it's resume, it'll begin delivering the queued messages, if any.
                  </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6353"/>30.1.1.4. Other Core Resources Management</h4></div></div></div><p>HornetQ allows to start and stop its remote resources (acceptors, diverts,
               bridges, etc.) so that a server can be taken off line for a given period of time
               without stopping it completely (e.g. if other management operations must be performed
               such as resolving heuristic transactions). These resources are:</p><div class="itemizedlist"><ul><li><p>Acceptors</p><p>They can be started or stopped using the <code class="literal">start()</code> or.
                        <code class="literal">stop()</code> method on the <code class="literal">AcceptorControl</code>
                     class (with the ObjectName <code class="literal">org.hornetq:module=Core,type=Acceptor,name="&lt;the acceptor
                        name&gt;"</code> or the resource name <code class="literal">core.acceptor.&lt;the
                        address name&gt;</code>). The acceptors parameters can be retrieved using
                     the <code class="literal">AcceptorControl</code> attributes (see <a class="xref" href="configuring-transports.html#configuring-transports.acceptors" title="16.1. Understanding Acceptors">Section 16.1, “Understanding Acceptors”</a>)</p></li><li><p>Diverts</p><p>They can be started or stopped using the <code class="literal">start()</code> or
                        <code class="literal">stop()</code> method on the <code class="literal">DivertControl</code>
                     class (with the ObjectName <code class="literal">org.hornetq:module=Core,type=Divert,name=&lt;the divert name&gt;</code>
                     or the resource name <code class="literal">core.divert.&lt;the divert name&gt;</code>).
                     Diverts parameters can be retrieved using the <code class="literal">DivertControl</code>
                     attributes (see <a class="xref" href="diverts.html" title="Chapter 35. Diverting and Splitting Message Flows">Chapter 35, <i>Diverting and Splitting Message Flows</i></a>)</p></li><li><p>Bridges</p><p>They can be started or stopped using the <code class="literal">start()</code> (resp.
                        <code class="literal">stop()</code>) method on the <code class="literal">BridgeControl</code>
                     class (with the ObjectName <code class="literal">org.hornetq:module=Core,type=Bridge,name="&lt;the bridge
                        name&gt;"</code> or the resource name <code class="literal">core.bridge.&lt;the bridge
                        name&gt;</code>). Bridges parameters can be retrieved using the <code class="literal">BridgeControl</code> attributes (see <a class="xref" href="core-bridges.html" title="Chapter 36. Core Bridges">Chapter 36, <i>Core Bridges</i></a>)</p></li><li><p>Broadcast groups</p><p>They can be started or stopped using the <code class="literal">start()</code> or
                        <code class="literal">stop()</code> method on the <code class="literal">BroadcastGroupControl</code> class (with the ObjectName <code class="literal">org.hornetq:module=Core,type=BroadcastGroup,name="&lt;the broadcast group
                        name&gt;"</code> or the resource name <code class="literal">core.broadcastgroup.&lt;the broadcast group name&gt;</code>). Broadcast
                     groups parameters can be retrieved using the <code class="literal">BroadcastGroupControl</code> attributes (see <a class="xref" href="clusters.html" title="Chapter 38. Clusters">Chapter 38, <i>Clusters</i></a>)</p></li><li><p>Discovery groups</p><p>They can be started or stopped using the <code class="literal">start()</code> or
                        <code class="literal">stop()</code> method on the <code class="literal">DiscoveryGroupControl</code> class (with the ObjectName <code class="literal">org.hornetq:module=Core,type=DiscoveryGroup,name="&lt;the discovery group
                        name&gt;"</code> or the resource name <code class="literal">core.discovery.&lt;the
                        discovery group name&gt;</code>). Discovery groups parameters can be
                     retrieved using the <code class="literal">DiscoveryGroupControl</code> attributes (see
                        <a class="xref" href="clusters.html" title="Chapter 38. Clusters">Chapter 38, <i>Clusters</i></a>)</p></li><li><p>Cluster connections</p><p>They can be started or stopped using the <code class="literal">start()</code> or
                        <code class="literal">stop()</code> method on the <code class="literal">ClusterConnectionControl</code> class (with the ObjectName <code class="literal">org.hornetq:module=Core,type=ClusterConnection,name="&lt;the cluster
                        connection name&gt;"</code> or the resource name <code class="literal">core.clusterconnection.&lt;the cluster connection name&gt;</code>).
                     Cluster connections parameters can be retrieved using the <code class="literal">ClusterConnectionControl</code> attributes (see <a class="xref" href="clusters.html" title="Chapter 38. Clusters">Chapter 38, <i>Clusters</i></a>)</p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6509"/>30.1.2. JMS Management API</h3></div></div></div><p>HornetQ defines a JMS Management API to manage JMS <span class="emphasis"><em>administrated
               objects</em></span> (i.e. JMS queues, topics and connection factories).</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6517"/>30.1.2.1. JMS Server Management</h4></div></div></div><p>JMS Resources (connection factories and destinations) can be created using the
                  <code class="literal">JMSServerControl</code> class (with the ObjectName <code class="literal">org.hornetq:module=JMS,type=Server</code> or the resource name <code class="literal">jms.server</code>).</p><div class="itemizedlist"><ul><li><p>Listing, creating, destroying connection factories</p><p>Names of the deployed connection factories can be retrieved by the <code class="literal">getConnectionFactoryNames()</code> method.</p><p>JMS connection factories can be created or destroyed using the <code class="literal">createConnectionFactory()</code> methods or <code class="literal">destroyConnectionFactory()</code> methods. These connection factories
                     are bound to JNDI so that JMS clients can look them up. If a graphical console
                     is used to create the connection factories, the transport parameters are
                     specified in the text field input as a comma-separated list of key=value (e.g.
                        <code class="literal">key1=10, key2="value", key3=false</code>). If there are multiple
                     transports defined, you need to enclose the key/value pairs between curly
                     braces. For example <code class="literal">{key=10}, {key=20}</code>. In that case, the
                     first <code class="literal">key</code> will be associated to the first transport
                     configuration and the second <code class="literal">key</code> will be associated to the
                     second transport configuration (see <a class="xref" href="configuring-transports.html" title="Chapter 16. Configuring the Transport">Chapter 16, <i>Configuring the Transport</i></a>
                     for a list of the transport parameters)</p></li><li><p>Listing, creating, destroying queues</p><p>Names of the deployed JMS queues can be retrieved by the <code class="literal">getQueueNames()</code> method.</p><p>JMS queues can be created or destroyed using the <code class="literal">createQueue()</code> methods or <code class="literal">destroyQueue()</code>
                     methods. These queues are bound to JNDI so that JMS clients can look them
                     up</p></li><li><p>Listing, creating/destroying topics</p><p>Names of the deployed topics can be retrieved by the <code class="literal">getTopicNames()</code> method.</p><p>JMS topics can be created or destroyed using the <code class="literal">createTopic()</code> or <code class="literal">destroyTopic()</code> methods. These
                     topics are bound to JNDI so that JMS clients can look them up</p></li><li><p>Listing and closing remote connections</p><p>JMS Clients remote addresses can be retrieved using <code class="literal">listRemoteAddresses()</code>. It is also possible to close the
                     connections associated with a remote address using the <code class="literal">closeConnectionsForAddress()</code> method.</p><p>Alternatively, connection IDs can be listed using <code class="literal">listConnectionIDs()</code> and all the sessions for a given connection
                     ID can be listed using <code class="literal">listSessions()</code>.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6613"/>30.1.2.2. JMS ConnectionFactory Management</h4></div></div></div><p>JMS Connection Factories can be managed using the <code class="literal">ConnectionFactoryControl</code> class (with the ObjectName <code class="literal">org.hornetq:module=JMS,type=ConnectionFactory,name="&lt;the connection factory
                  name&gt;"</code> or the resource name <code class="literal">jms.connectionfactory.&lt;the
                  connection factory name&gt;</code>).</p><div class="itemizedlist"><ul><li><p>Retrieving connection factory attributes</p><p>The <code class="literal">ConnectionFactoryControl</code> exposes JMS
                     ConnectionFactory configuration through its attributes (e.g. <code class="literal">getConsumerWindowSize()</code> to retrieve the consumer window size for
                     flow control, <code class="literal">isBlockOnNonDurableSend()</code> to know whether the
                     producers created from the connection factory will block or not when sending
                     non-durable messages, etc.)</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6642"/>30.1.2.3. JMS Queue Management</h4></div></div></div><p>JMS queues can be managed using the <code class="literal">JMSQueueControl</code> class (with
               the ObjectName <code class="literal">org.hornetq:module=JMS,type=Queue,name="&lt;the queue
                  name&gt;"</code> or the resource name <code class="literal">jms.queue.&lt;the queue
                  name&gt;</code>). </p><p><span class="emphasis"><em>The management operations on a JMS queue are very similar to the
                  operations on a core queue. </em></span></p><div class="itemizedlist"><ul><li><p>Expiring, sending to a dead letter address and moving messages</p><p>Messages can be expired from a queue by using the <code class="literal">expireMessages()</code> method. If an expiry address is defined,
                     messages will be sent to it, otherwise they are discarded. The queue's
                     expiry address can be set with the <code class="literal">setExpiryAddress()</code>
                     method.</p><p>Messages can also be sent to a dead letter address with the <code class="literal">sendMessagesToDeadLetterAddress()</code> method. It returns the number
                     of messages which are sent to the dead letter address. If a dead letter address
                     is not defined, message are removed from the queue and discarded. The queue's
                     dead letter address can be set with the <code class="literal">setDeadLetterAddress()</code> method.</p><p>Messages can also be moved from a queue to another queue by using the
                        <code class="literal">moveMessages()</code> method.</p></li><li><p>Listing and removing messages</p><p>Messages can be listed from a queue by using the <code class="literal">listMessages()</code> method which returns an array of <code class="literal">Map</code>, one <code class="literal">Map</code> for each message.</p><p>Messages can also be removed from the queue by using the <code class="literal">removeMessages()</code> method which returns a <code class="literal">boolean</code> for the single message ID variant or the number of
                     removed messages for the filter variant. The <code class="literal">removeMessages()</code> method takes a <code class="literal">filter</code>
                     argument to remove only filtered messages. Setting the filter to an empty
                     string will in effect remove all messages.</p></li><li><p>Counting messages</p><p>The number of messages in a queue is returned by the <code class="literal">getMessageCount()</code> method. Alternatively, the <code class="literal">countMessages()</code> will return the number of messages in the queue
                     which <span class="emphasis"><em>match a given filter</em></span></p></li><li><p>Changing message priority</p><p>The message priority can be changed by using the <code class="literal">changeMessagesPriority()</code> method which returns a <code class="literal">boolean</code> for the single message ID variant or the number of
                     updated messages for the filter variant.</p></li><li><p>Message counters</p><p>Message counters can be listed for a queue with the <code class="literal">listMessageCounter()</code> and <code class="literal">listMessageCounterHistory()</code> methods (see <a class="xref" href="management.html#management.message-counters" title="30.6. Message Counters">Section 30.6, “Message Counters”</a>)</p></li><li><p>Retrieving the queue attributes</p><p>The <code class="literal">JMSQueueControl</code> exposes JMS queue settings through
                     its attributes (e.g. <code class="literal">isTemporary()</code> to know whether the queue
                     is temporary or not, <code class="literal">isDurable()</code> to know whether the queue is
                     durable or not, etc.)</p></li><li><p>Pausing and resuming queues</p><p>The <code class="literal">JMSQueueControl</code> can pause and resume the underlying
                     queue. When the queue is paused it will continue to receive messages but will
                     not deliver them. When resumed again it will deliver the enqueued messages, if
                     any. </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6771"/>30.1.2.4. JMS Topic Management</h4></div></div></div><p>JMS Topics can be managed using the <code class="literal">TopicControl</code> class (with
               the ObjectName <code class="literal">org.hornetq:module=JMS,type=Topic,name="&lt;the topic
                  name&gt;"</code> or the resource name <code class="literal">jms.topic.&lt;the topic
                  name&gt;</code>).</p><div class="itemizedlist"><ul><li><p>Listing subscriptions and messages</p><p>JMS topics subscriptions can be listed using the <code class="literal">listAllSubscriptions()</code>, <code class="literal">listDurableSubscriptions()</code>, <code class="literal">listNonDurableSubscriptions()</code> methods. These methods return
                     arrays of <code class="literal">Object</code> representing the subscriptions information
                     (subscription name, client ID, durability, message count, etc.). It is also
                     possible to list the JMS messages for a given subscription with the <code class="literal">listMessagesForSubscription()</code> method.</p></li><li><p>Dropping subscriptions</p><p>Durable subscriptions can be dropped from the topic using the <code class="literal">dropDurableSubscription()</code> method.</p></li><li><p>Counting subscriptions messages</p><p>The <code class="literal">countMessagesForSubscription()</code> method can be used to
                     know the number of messages held for a given subscription (with an optional
                     message selector to know the number of messages matching the selector)</p></li></ul></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="management.jmx"/>30.2. Using Management Via JMX</h2></div></div></div><p>HornetQ can be managed using <a class="ulink" href="http://www.oracle.com/technetwork/java/javase/tech/javamanagement-140525.html">JMX</a>. </p><p>The management API is exposed by HornetQ using MBeans interfaces. HornetQ registers its
         resources with the domain <code class="literal">org.hornetq</code>.</p><p>For example, the <code class="literal">ObjectName</code> to manage a JMS Queue <code class="literal">exampleQueue</code> is:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
org.hornetq:module=JMS,type=Queue,name="exampleQueue"</pre><p>and the MBean is:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
org.hornetq.api.jms.management.JMSQueueControl</pre><p>The MBean's <code class="literal">ObjectName</code> are built using the helper class <code class="literal">org.hornetq.api.core.management.ObjectNameBuilder</code>. You can also use <code class="literal">jconsole</code> to find the <code class="literal">ObjectName</code> of the MBeans you want to
         manage. </p><p>Managing HornetQ using JMX is identical to management of any Java Applications using
         JMX. It can be done by reflection or by creating proxies of the MBeans.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="management.jmx.configuration"/>30.2.1. Configuring JMX</h3></div></div></div><p>By default, JMX is enabled to manage HornetQ. It can be disabled by setting <code class="literal">jmx-management-enabled</code> to <code class="literal">false</code> in <code class="literal">hornetq-configuration.xml</code>:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;!-- false to disable JMX management for HornetQ --&gt;
&lt;jmx-management-enabled&gt;false&lt;/jmx-management-enabled&gt;</pre><p>If JMX is enabled, HornetQ can be managed locally using <code class="literal">jconsole</code>.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Remote connections to JMX are not enabled by default for security reasons. Please refer
            to <a class="ulink" href="http://docs.oracle.com/javase/6/docs/technotes/guides/management/agent.html">Java Management guide</a> to configure the server for remote management (system
            properties must be set in <code class="literal">run.sh</code> or <code class="literal">run.bat</code>
            scripts).</p></div><p>By default, HornetQ server uses the JMX domain "org.hornetq". To manage several
            HornetQ servers from the <span class="emphasis"><em>same</em></span> MBeanServer, the JMX domain can be
            configured for each individual HornetQ server by setting <code class="literal">jmx-domain</code>
            in <code class="literal">hornetq-configuration.xml</code>: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;!-- use a specific JMX domain for HornetQ MBeans --&gt;
&lt;jmx-domain&gt;my.org.hornetq&lt;/jmx-domain&gt;</pre><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e6911"/>30.2.1.1. MBeanServer configuration</h4></div></div></div><p>When HornetQ is run in standalone, it uses the Java Virtual Machine's <code class="literal">Platform MBeanServer</code> to register its MBeans. This is configured in
               JBoss Microcontainer Beans file (see <a class="xref" href="using-server.html#server.microcontainer.configuration" title="6.7. JBoss Microcontainer Beans File">Section 6.7, “JBoss Microcontainer Beans File”</a>):</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;!-- MBeanServer --&gt;
&lt;bean name="MBeanServer" class="javax.management.MBeanServer"&gt;
   &lt;constructor factoryClass="java.lang.management.ManagementFactory"
                   factoryMethod="getPlatformMBeanServer" /&gt;
&lt;/bean&gt;</pre><p>When it is integrated in JBoss AS 5+, it uses the Application Server's own MBean
               Server so that it can be managed using AS 5's jmx-console:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;!-- MBeanServer --&gt;
&lt;bean name="MBeanServer" class="javax.management.MBeanServer"&gt;
   &lt;constructor factoryClass="org.jboss.mx.util.MBeanServerLocator"
                   factoryMethod="locateJBoss" /&gt;
&lt;/bean&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e6927"/>30.2.2. Example</h3></div></div></div><p>See <a class="xref" href="examples.html#examples.jmx" title="11.1.35. JMX Management">Section 11.1.35, “JMX Management”</a> for an example which shows how to use a remote
            connection to JMX and MBean proxies to manage HornetQ.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e6934"/>30.3. Using Management Via Core API</h2></div></div></div><p>The core management API in HornetQ is called by sending Core messages to a special
         address, the <span class="emphasis"><em>management address</em></span>.</p><p><span class="emphasis"><em>Management messages</em></span> are regular Core messages with well-known
         properties that the server needs to understand to interact with the management API:</p><div class="itemizedlist"><ul><li><p>The name of the managed resource</p></li><li><p>The name of the management operation</p></li><li><p>The parameters of the management operation</p></li></ul></div><p>When such a management message is sent to the management address, HornetQ server will
         handle it, extract the information, invoke the operation on the managed resources and send
         a <span class="emphasis"><em>management reply</em></span> to the management message's reply-to address
         (specified by <code class="literal">ClientMessageImpl.REPLYTO_HEADER_NAME</code>). </p><p>A <code class="literal">ClientConsumer</code> can be used to consume the management reply and
         retrieve the result of the operation (if any) stored in the reply's body. For portability,
         results are returned as a <a class="ulink" href="http://json.org">JSON</a> String rather than Java
         Serialization (the <code class="literal">org.hornetq.api.core.management.ManagementHelper</code> can
         be used to convert the JSON string to Java objects).</p><p>These steps can be simplified to make it easier to invoke management operations using
         Core messages:</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>Create a <code class="literal">ClientRequestor</code> to send messages to the management
               address and receive replies</p></li><li><p>Create a <code class="literal">ClientMessage</code></p></li><li><p>Use the helper class <code class="literal">org.hornetq.api.core.management.ManagementHelper</code> to fill the message
               with the management properties</p></li><li><p>Send the message using the <code class="literal">ClientRequestor</code></p></li><li><p>Use the helper class <code class="literal">org.hornetq.api.core.management.ManagementHelper</code> to retrieve the
               operation result from the management reply</p></li></ol></div><p>For example, to find out the number of messages in the core queue <code class="literal">exampleQueue</code>:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
ClientSession session = ...
ClientRequestor requestor = new ClientRequestor(session, "jms.queue.hornetq.management");
ClientMessage message = session.createMessage(false);
ManagementHelper.putAttribute(message, "core.queue.exampleQueue", "messageCount");
session.start();
ClientMessage reply = requestor.request(m);
int count = (Integer) ManagementHelper.getResult(reply);
System.out.println("There are " + count + " messages in exampleQueue");</pre><p>Management operation name and parameters must conform to the Java interfaces defined in
         the <code class="literal">management</code> packages.</p><p>Names of the resources are built using the helper class <code class="literal">org.hornetq.api.core.management.ResourceNames</code> and are straightforward
            (<code class="literal">core.queue.exampleQueue</code> for the Core Queue <code class="literal">exampleQueue</code>, <code class="literal">jms.topic.exampleTopic</code> for the JMS Topic
            <code class="literal">exampleTopic</code>, etc.).</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="management.core.configuration"/>30.3.1. Configuring Core Management</h3></div></div></div><p>The management address to send management messages is configured in <code class="literal">hornetq-configuration.xml</code>:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;management-address&gt;jms.queue.hornetq.management&lt;/management-address&gt;</pre><p>By default, the address is <code class="literal">jms.queue.hornetq.management</code> (it is
            prepended by "jms.queue" so that JMS clients can also send management messages).</p><p>The management address requires a <span class="emphasis"><em>special</em></span> user permission
               <code class="literal">manage</code> to be able to receive and handle management messages. This
            is also configured in hornetq-configuration.xml:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;!-- users with the admin role will be allowed to manage --&gt;
&lt;!-- HornetQ using management messages        --&gt;
&lt;security-setting match="jms.queue.hornetq.management"&gt;
   &lt;permission type="manage" roles="admin" /&gt;
&lt;/security-setting&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="management.jms"/>30.4. Using Management Via JMS</h2></div></div></div><p>Using JMS messages to manage HornetQ is very similar to using core API.</p><p>An important difference is that JMS requires a JMS queue to send the messages to
         (instead of an address for the core API).</p><p>The <span class="emphasis"><em>management queue</em></span> is a special queue and needs to be
         instantiated directly by the client:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
Queue managementQueue = HornetQJMSClient.createQueue("hornetq.management");</pre><p>All the other steps are the same than for the Core API but they use JMS API
         instead:</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>create a <code class="literal">QueueRequestor</code> to send messages to the management
               address and receive replies</p></li><li><p>create a <code class="literal">Message</code></p></li><li><p>use the helper class <code class="literal">org.hornetq.api.jms.management.JMSManagementHelper</code> to fill the message
               with the management properties</p></li><li><p>send the message using the <code class="literal">QueueRequestor</code></p></li><li><p>use the helper class <code class="literal">org.hornetq.api.jms.management.JMSManagementHelper</code> to retrieve the
               operation result from the management reply</p></li></ol></div><p>For example, to know the number of messages in the JMS queue <code class="literal">exampleQueue</code>:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
Queue managementQueue = HornetQJMSClient.createQueue("hornetq.management");

QueueSession session = ...
QueueRequestor requestor = new QueueRequestor(session, managementQueue);
connection.start();
Message message = session.createMessage();
JMSManagementHelper.putAttribute(message, "jms.queue.exampleQueue", "messageCount");
Message reply = requestor.request(message);
int count = (Integer)JMSManagementHelper.getResult(reply);
System.out.println("There are " + count + " messages in exampleQueue");</pre><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7112"/>30.4.1. Configuring JMS Management</h3></div></div></div><p>Whether JMS or the core API is used for management, the configuration steps are the
            same (see <a class="xref" href="management.html#management.core.configuration" title="30.3.1. Configuring Core Management">Section 30.3.1, “Configuring Core Management”</a>).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7119"/>30.4.2. Example</h3></div></div></div><p>See <a class="xref" href="examples.html#examples.management" title="11.1.38. Management">Section 11.1.38, “Management”</a> for an example which shows how to use JMS
            messages to manage HornetQ server.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="management.notifications"/>30.5. Management Notifications</h2></div></div></div><p>HornetQ emits <span class="emphasis"><em>notifications</em></span> to inform listeners of potentially
         interesting events (creation of new resources, security violation, etc.).</p><p>These notifications can be received by 3 different ways:</p><div class="itemizedlist"><ul><li><p>JMX notifications</p></li><li><p>Core messages</p></li><li><p>JMS messages</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7146"/>30.5.1. JMX Notifications</h3></div></div></div><p>If JMX is enabled (see <a class="xref" href="management.html#management.jmx.configuration" title="30.2.1. Configuring JMX">Section 30.2.1, “Configuring JMX”</a>), JMX
            notifications can be received by subscribing to 2 MBeans:</p><div class="itemizedlist"><ul><li><p><code class="literal">org.hornetq:module=Core,type=Server</code> for notifications on
                     <span class="emphasis"><em>Core</em></span> resources</p></li><li><p><code class="literal">org.hornetq:module=JMS,type=Server</code> for notifications on
                     <span class="emphasis"><em>JMS</em></span> resources</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7170"/>30.5.2. Core Messages Notifications</h3></div></div></div><p>HornetQ defines a special <span class="emphasis"><em>management notification address</em></span>. Core
            queues can be bound to this address so that clients will receive management
            notifications as Core messages</p><p>A Core client which wants to receive management notifications must create a core
            queue bound to the management notification address. It can then receive the
            notifications from its queue.</p><p>Notifications messages are regular core messages with additional properties
            corresponding to the notification (its type, when it occurred, the resources which were
            concerned, etc.).</p><p>Since notifications are regular core messages, it is possible to use message
            selectors to filter out notifications and receives only a subset of all the
            notifications emitted by the server.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="management.notifications.core.configuration"/>30.5.2.1. Configuring The Core Management Notification Address</h4></div></div></div><p>The management notification address to receive management notifications is
               configured in <code class="literal">hornetq-configuration.xml</code>:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;management-notification-address&gt;hornetq.notifications&lt;/management-notification-address&gt;</pre><p>By default, the address is <code class="literal">hornetq.notifications</code>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7199"/>30.5.3. JMS Messages Notifications</h3></div></div></div><p>HornetQ's notifications can also be received using JMS messages.</p><p>It is similar to receiving notifications using Core API but an important difference
            is that JMS requires a JMS Destination to receive the messages (preferably a
            Topic).</p><p>To use a JMS Destination to receive management notifications, you must change the server's
            management notification address to start with <code class="literal">jms.queue</code> if it is a JMS Queue
            or <code class="literal">jms.topic</code> if it is a JMS Topic:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;!-- notifications will be consumed from "notificationsTopic" JMS Topic --&gt;
&lt;management-notification-address&gt;jms.topic.notificationsTopic&lt;/management-notification-address&gt;</pre><p>Once the notification topic is created, you can receive messages from it or set a
               <code class="literal">MessageListener</code>:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
Topic notificationsTopic = HornetQJMSClient.createTopic("notificationsTopic");

Session session = ...
MessageConsumer notificationConsumer = session.createConsumer(notificationsTopic);
notificationConsumer.setMessageListener(new MessageListener()
{
   public void onMessage(Message notif)
   {
      System.out.println("------------------------");
      System.out.println("Received notification:");
      try
      {
         Enumeration propertyNames = notif.getPropertyNames();
         while (propertyNames.hasMoreElements())
         {
            String propertyName = (String)propertyNames.nextElement();
            System.out.format("  %s: %s\n", propertyName, notif.getObjectProperty(propertyName));
         }
      }
      catch (JMSException e)
      {
      }
      System.out.println("------------------------");
   }
});</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7223"/>30.5.4. Example</h3></div></div></div><p>See <a class="xref" href="examples.html#examples.management-notifications" title="11.1.39. Management Notification">Section 11.1.39, “Management Notification”</a> for an example which shows
               how to use a JMS <code class="literal">MessageListener</code> to receive management notifications
               from HornetQ server.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7233"/>30.5.5. Notification Types and Headers</h3></div></div></div><p>Below is a list of all the different kinds of notifications as well as which headers are
                on the messages.  Every notification has a <code class="literal">_HQ_NotifType</code> (value noted in parentheses)
                and <code class="literal">_HQ_NotifTimestamp</code> header.  The timestamp is the un-formatted result of a call
                to <code class="literal">java.lang.System.currentTimeMillis()</code>.</p><div class="itemizedlist"><ul><li><p><code class="literal">BINDING_ADDED</code> (0)</p><p><code class="literal">_HQ_Binding_Type</code>, <code class="literal">_HQ_Address</code>,
                       <code class="literal">_HQ_ClusterName</code>, <code class="literal">_HQ_RoutingName</code>,
                       <code class="literal">_HQ_Binding_ID</code>, <code class="literal">_HQ_Distance</code>,
                       <code class="literal">_HQ_FilterString</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">BINDING_REMOVED</code> (1)</p><p><code class="literal">_HQ_Address</code>, <code class="literal">_HQ_ClusterName</code>,
                       <code class="literal">_HQ_RoutingName</code>, <code class="literal">_HQ_Binding_ID</code>,
                       <code class="literal">_HQ_Distance</code>, <code class="literal">_HQ_FilterString</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">CONSUMER_CREATED</code> (2)</p><p><code class="literal">_HQ_Address</code>, <code class="literal">_HQ_ClusterName</code>,
                       <code class="literal">_HQ_RoutingName</code>, <code class="literal">_HQ_Distance</code>,
                       <code class="literal">_HQ_ConsumerCount</code>, <code class="literal">_HQ_User</code>,
                       <code class="literal">_HQ_RemoteAddress</code>, <code class="literal">_HQ_SessionName</code>,
                       <code class="literal">_HQ_FilterString</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">CONSUMER_CLOSED</code> (3)</p><p><code class="literal">_HQ_Address</code>, <code class="literal">_HQ_ClusterName</code>,
                       <code class="literal">_HQ_RoutingName</code>, <code class="literal">_HQ_Distance</code>,
                       <code class="literal">_HQ_ConsumerCount</code>, <code class="literal">_HQ_User</code>,
                       <code class="literal">_HQ_RemoteAddress</code>, <code class="literal">_HQ_SessionName</code>,
                       <code class="literal">_HQ_FilterString</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">SECURITY_AUTHENTICATION_VIOLATION</code> (6)</p><p><code class="literal">_HQ_User</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">SECURITY_PERMISSION_VIOLATION</code> (7)</p><p><code class="literal">_HQ_Address</code>, <code class="literal">_HQ_CheckType</code>,
                       <code class="literal">_HQ_User</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">DISCOVERY_GROUP_STARTED</code> (8)</p><p><code class="literal">name</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">DISCOVERY_GROUP_STOPPED</code> (9)</p><p><code class="literal">name</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">BROADCAST_GROUP_STARTED</code> (10)</p><p><code class="literal">name</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">BROADCAST_GROUP_STOPPED</code> (11)</p><p><code class="literal">name</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">BRIDGE_STARTED</code> (12)</p><p><code class="literal">name</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">BRIDGE_STOPPED</code> (13)</p><p><code class="literal">name</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">CLUSTER_CONNECTION_STARTED</code> (14)</p><p><code class="literal">name</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">CLUSTER_CONNECTION_STOPPED</code> (15)</p><p><code class="literal">name</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">ACCEPTOR_STARTED</code> (16)</p><p><code class="literal">factory</code>, <code class="literal">id</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">ACCEPTOR_STOPPED</code> (17)</p><p><code class="literal">factory</code>, <code class="literal">id</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">PROPOSAL</code> (18)</p><p><code class="literal">_JBM_ProposalGroupId</code>, <code class="literal">_JBM_ProposalValue</code>,
                       <code class="literal">_HQ_Binding_Type</code>, <code class="literal">_HQ_Address</code>,
                       <code class="literal">_HQ_Distance</code></p></li></ul></div><div class="itemizedlist"><ul><li><p><code class="literal">PROPOSAL_RESPONSE</code> (19)</p><p><code class="literal">_JBM_ProposalGroupId</code>, <code class="literal">_JBM_ProposalValue</code>,
                       <code class="literal">_JBM_ProposalAltValue</code>, <code class="literal">_HQ_Binding_Type</code>,
                       <code class="literal">_HQ_Address</code>, <code class="literal">_HQ_Distance</code></p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="management.message-counters"/>30.6. Message Counters</h2></div></div></div><p>Message counters can be used to obtain information on queues <span class="emphasis"><em>over
            time</em></span> as HornetQ keeps a history on queue metrics.</p><p>They can be used to show <span class="emphasis"><em>trends</em></span> on queues. For example, using the
         management API, it would be possible to query the number of messages in a queue at regular
         interval. However, this would not be enough to know if the queue is used: the number of
         messages can remain constant because nobody is sending or receiving messages from the queue
         or because there are as many messages sent to the queue than messages consumed from it. The
         number of messages in the queue remains the same in both cases but its use is widely
         different.</p><p>Message counters gives additional information about the queues:</p><div class="itemizedlist"><ul><li><p><code class="literal">count</code></p><p>The <span class="emphasis"><em>total</em></span> number of messages added to the queue since the
               server was started</p></li><li><p><code class="literal">countDelta</code></p><p>the number of messages added to the queue <span class="emphasis"><em>since the last message counter
                  update</em></span></p></li><li><p><code class="literal">messageCount</code></p><p>The <span class="emphasis"><em>current</em></span> number of messages in the queue</p></li><li><p><code class="literal">messageCountDelta</code></p><p>The <span class="emphasis"><em>overall</em></span> number of messages added/removed from the queue
                  <span class="emphasis"><em>since the last message counter update</em></span>. For example, if
                  <code class="literal">messageCountDelta</code> is equal to <code class="literal">-10</code> this means that
               overall 10 messages have been removed from the queue (e.g. 2 messages were added and
               12 were removed)</p></li><li><p><code class="literal">lastAddTimestamp</code></p><p>The timestamp of the last time a message was added to the queue</p></li><li><p><code class="literal">udpateTimestamp</code></p><p>The timestamp of the last message counter update</p></li></ul></div><p>These attributes can be used to determine other meaningful data as well.  For example, to know
      specifically how many messages were <span class="emphasis"><em>consumed</em></span> from the queue since the last update
      simply subtract the <code class="literal">messageCountDelta</code> from <code class="literal">countDelta</code>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="configuring.message.counters"/>30.6.1. Configuring Message Counters</h3></div></div></div><p>By default, message counters are disabled as it might have a small negative effect on
            memory.</p><p>To enable message counters, you can set it to <code class="literal">true</code> in <code class="literal">hornetq-configuration.xml</code>:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;message-counter-enabled&gt;true&lt;/message-counter-enabled&gt;</pre><p>Message counters keeps a history of the queue metrics (10 days by default) and
            samples all the queues at regular interval (10 seconds by default). If message counters
            are enabled, these values should be configured to suit your messaging use case in
               <code class="literal">hornetq-configuration.xml</code>:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
&lt;!-- keep history for a week --&gt;
&lt;message-counter-max-day-history&gt;7&lt;/message-counter-max-day-history&gt;
&lt;!-- sample the queues every minute (60000ms) --&gt;
&lt;message-counter-sample-period&gt;60000&lt;/message-counter-sample-period&gt;</pre><p>Message counters can be retrieved using the Management API. For example, to retrieve
            message counters on a JMS Queue using JMX:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">
// retrieve a connection to HornetQ's MBeanServer
MBeanServerConnection mbsc = ...
JMSQueueControlMBean queueControl = (JMSQueueControl)MBeanServerInvocationHandler.newProxyInstance(mbsc,
   on,
   JMSQueueControl.class,
   false);
// message counters are retrieved as a JSON String                                                                                                      
String counters = queueControl.listMessageCounter();
// use the MessageCounterInfo helper class to manipulate message counters more easily
MessageCounterInfo messageCounter = MessageCounterInfo.fromJSON(counters);         
System.out.format("%s message(s) in the queue (since last sample: %s)\n",
messageCounter.getMessageCount(),
messageCounter.getMessageCountDelta());</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7638"/>30.6.2. Example</h3></div></div></div><p>See <a class="xref" href="examples.html#examples.message-counters" title="11.1.40. Message Counter">Section 11.1.40, “Message Counter”</a> for an example which shows how to use
            message counters to retrieve information on a JMS <code class="literal">Queue</code>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e7648"/>30.7. Administering HornetQ Resources Using The JBoss AS Admin Console</h2></div></div></div><p>Its possible to create and configure HornetQ resources via the admin console within the JBoss Application Server.</p><p>The Admin Console will allow you to create destinations (JMS Topics and Queues) and JMS Connection Factories.</p><p>Once logged in to the admin console you will see a JMS Manager item in the left hand tree. All HornetQ resources
      will be configured via this. This will have a child items for JMS Queues, Topics and Connection Factories, clicking
         on each node will reveal which resources are currently available. The following sections explain how to create
         and configure each resource in turn.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7657"/>30.7.1. JMS Queues</h3></div></div></div><p>To create a new JMS Queue click on the JMS Queues item to reveal the available queues. On the right hand
            panel you will see an add a new resource button, click on this and then choose the default(JMS Queue) template
         and click continue. The important things to fill in here are the name of the queue and the JNDI name of the
            queue. The JNDI name is what you will use to look up the queue in JNDI from your client. For most queues this
            will be the only info you will need to provide as sensible defaults are provided for the others. You will also
            see a security roles section near the bottom. If you do not provide any roles for this queue then the servers
         default security configuration will be used, after you have created the queue these will be shown in the configuration.
         All configuration values, except the name and JNDI name, can be changed via the configuration tab after clicking
            on the queue in the admin console. The following section explains these in more detail</p><p>After highlighting the configuration you will see the following screen</p><p>
            </p><div align="center"><img src="images/console1.png" align="middle"/></div><p>
        </p><p>The name and JNDI name can't be changed, if you want to change these recreate the queue with the appropriate
         settings. The rest of the configuration options, apart from security roles, relate to address settings for a particular
         address. The default address settings are picked up from the servers configuration, if you change any of these
         settings or create a queue via the console a new Address Settings entry will be added. For a full explanation on
         Address Settings see <a class="xref" href="queue-attributes.html#queue-attributes.address-settings" title="25.3. Configuring Queues Via Address Settings">Section 25.3, “Configuring Queues Via Address Settings”</a></p><p>To delete a queue simply click on the delete button beside the queue name in the main JMS Queues screen.
         This will also delete any address settings or security settings previously created for the queues address</p><p>The last part of the configuration options are security roles. If non are provided on creation then the
            servers default security settings will be shown. If these are changed or updated then new security settings are
         created for the address of this queue. For more information on security setting see <a class="xref" href="security.html" title="Chapter 31. Security">Chapter 31, <i>Security</i></a> </p><p>It is also possible via the metrics tab to view statistics for this queue. This will show statistics such
            as message count, consumer count etc.</p><p>Operations can be performed on a queue via the control tab. This will allow you to start and stop the queue,
         list,move,expire and delete messages from the queue and other useful operations. To invoke an operation click on
         the button for the operation you want, this will take you to a screen where you can parameters for the operation can be set.
         Once set clicking the ok button will invoke the operation, results appear at the bottom of the screen.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7681"/>30.7.2. JMS Topics</h3></div></div></div><p>Creating and configuring JMS Topics is almost identical to creating queues. The only difference is that the
         configuration will be applied to the queue representing a subscription.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e7686"/>30.7.3. JMS Connection Factories</h3></div></div></div><p>The format for creating connection factories is the same as for JMS Queues and topics apart from the configuration
         being different. For as list of all the connection factory settings see the configuration index </p></div></div></div><ul class="docnav"><li class="previous"><a accesskey="p" href="pre-acknowledge.html"><strong>Prev</strong>Chapter 29. Extra Acknowledge Modes</a></li><li class="up"><a accesskey="u" href="#"><strong>Top of page</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Front page</strong></a></li><li class="next"><a accesskey="n" href="security.html"><strong>Next</strong>Chapter 31. Security</a></li></ul></body></html>